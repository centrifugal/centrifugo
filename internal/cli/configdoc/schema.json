[
  {
    "field": "http_server",
    "name": "http_server",
    "go_name": "HTTP",
    "level": 1,
    "type": "HTTPServer",
    "default": "",
    "comment": "HTTP is a configuration for Centrifugo HTTP server.",
    "is_complex_type": true,
    "children": [
      {
        "field": "http_server.address",
        "name": "address",
        "go_name": "Address",
        "level": 2,
        "type": "string",
        "default": "",
        "comment": "Address to bind HTTP server to.",
        "is_complex_type": false
      },
      {
        "field": "http_server.port",
        "name": "port",
        "go_name": "Port",
        "level": 2,
        "type": "int",
        "default": "8000",
        "comment": "Port to bind HTTP server to.",
        "is_complex_type": false
      },
      {
        "field": "http_server.internal_address",
        "name": "internal_address",
        "go_name": "InternalAddress",
        "level": 2,
        "type": "string",
        "default": "",
        "comment": "InternalAddress to bind internal HTTP server to. Internal server is used to serve endpoints\nwhich are normally should not be exposed to the outside world.",
        "is_complex_type": false
      },
      {
        "field": "http_server.internal_port",
        "name": "internal_port",
        "go_name": "InternalPort",
        "level": 2,
        "type": "string",
        "default": "",
        "comment": "InternalPort to bind internal HTTP server to.",
        "is_complex_type": false
      },
      {
        "field": "http_server.tls",
        "name": "tls",
        "go_name": "TLS",
        "level": 2,
        "type": "TLSConfig",
        "default": "",
        "comment": "TLS configuration for HTTP server.",
        "is_complex_type": true,
        "children": [
          {
            "field": "http_server.tls.enabled",
            "name": "enabled",
            "go_name": "Enabled",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "Enabled turns on using TLS.",
            "is_complex_type": false
          },
          {
            "field": "http_server.tls.cert_pem",
            "name": "cert_pem",
            "go_name": "CertPem",
            "level": 3,
            "type": "PEMData",
            "default": "",
            "comment": "CertPem is a PEM certificate.",
            "is_complex_type": false
          },
          {
            "field": "http_server.tls.key_pem",
            "name": "key_pem",
            "go_name": "KeyPem",
            "level": 3,
            "type": "PEMData",
            "default": "",
            "comment": "KeyPem is a path to a file with key in PEM format.",
            "is_complex_type": false
          },
          {
            "field": "http_server.tls.server_ca_pem",
            "name": "server_ca_pem",
            "go_name": "ServerCAPem",
            "level": 3,
            "type": "PEMData",
            "default": "",
            "comment": "ServerCAPem is a server root CA certificate in PEM format.\nThe client uses this certificate to verify the server's certificate during the TLS handshake.",
            "is_complex_type": false
          },
          {
            "field": "http_server.tls.client_ca_pem",
            "name": "client_ca_pem",
            "go_name": "ClientCAPem",
            "level": 3,
            "type": "PEMData",
            "default": "",
            "comment": "ClientCAPem is a client CA certificate in PEM format.\nThe server uses this certificate to verify the client's certificate during the TLS handshake.",
            "is_complex_type": false
          },
          {
            "field": "http_server.tls.insecure_skip_verify",
            "name": "insecure_skip_verify",
            "go_name": "InsecureSkipVerify",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "InsecureSkipVerify turns off server certificate verification.",
            "is_complex_type": false
          },
          {
            "field": "http_server.tls.server_name",
            "name": "server_name",
            "go_name": "ServerName",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "ServerName is used to verify the hostname on the returned certificates.",
            "is_complex_type": false
          }
        ]
      },
      {
        "field": "http_server.tls_autocert",
        "name": "tls_autocert",
        "go_name": "TLSAutocert",
        "level": 2,
        "type": "TLSAutocert",
        "default": "",
        "comment": "TLSAutocert for automatic TLS certificates from ACME provider (ex. Let's Encrypt).",
        "is_complex_type": true,
        "children": [
          {
            "field": "http_server.tls_autocert.enabled",
            "name": "enabled",
            "go_name": "Enabled",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "",
            "is_complex_type": false
          },
          {
            "field": "http_server.tls_autocert.host_whitelist",
            "name": "host_whitelist",
            "go_name": "HostWhitelist",
            "level": 3,
            "type": "[]string",
            "default": "",
            "comment": "",
            "is_complex_type": false
          },
          {
            "field": "http_server.tls_autocert.cache_dir",
            "name": "cache_dir",
            "go_name": "CacheDir",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "",
            "is_complex_type": false
          },
          {
            "field": "http_server.tls_autocert.email",
            "name": "email",
            "go_name": "Email",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "",
            "is_complex_type": false
          },
          {
            "field": "http_server.tls_autocert.server_name",
            "name": "server_name",
            "go_name": "ServerName",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "",
            "is_complex_type": false
          },
          {
            "field": "http_server.tls_autocert.http",
            "name": "http",
            "go_name": "HTTP",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "",
            "is_complex_type": false
          },
          {
            "field": "http_server.tls_autocert.http_addr",
            "name": "http_addr",
            "go_name": "HTTPAddr",
            "level": 3,
            "type": "string",
            "default": ":80",
            "comment": "",
            "is_complex_type": false
          }
        ]
      },
      {
        "field": "http_server.tls_external",
        "name": "tls_external",
        "go_name": "TLSExternal",
        "level": 2,
        "type": "bool",
        "default": "",
        "comment": "TLSExternal enables TLS only for external HTTP endpoints.",
        "is_complex_type": false
      },
      {
        "field": "http_server.internal_tls",
        "name": "internal_tls",
        "go_name": "InternalTLS",
        "level": 2,
        "type": "TLSConfig",
        "default": "",
        "comment": "InternalTLS is a custom configuration for internal HTTP endpoints. If not set InternalTLS will be the same as TLS.",
        "is_complex_type": true,
        "children": [
          {
            "field": "http_server.internal_tls.enabled",
            "name": "enabled",
            "go_name": "Enabled",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "Enabled turns on using TLS.",
            "is_complex_type": false
          },
          {
            "field": "http_server.internal_tls.cert_pem",
            "name": "cert_pem",
            "go_name": "CertPem",
            "level": 3,
            "type": "PEMData",
            "default": "",
            "comment": "CertPem is a PEM certificate.",
            "is_complex_type": false
          },
          {
            "field": "http_server.internal_tls.key_pem",
            "name": "key_pem",
            "go_name": "KeyPem",
            "level": 3,
            "type": "PEMData",
            "default": "",
            "comment": "KeyPem is a path to a file with key in PEM format.",
            "is_complex_type": false
          },
          {
            "field": "http_server.internal_tls.server_ca_pem",
            "name": "server_ca_pem",
            "go_name": "ServerCAPem",
            "level": 3,
            "type": "PEMData",
            "default": "",
            "comment": "ServerCAPem is a server root CA certificate in PEM format.\nThe client uses this certificate to verify the server's certificate during the TLS handshake.",
            "is_complex_type": false
          },
          {
            "field": "http_server.internal_tls.client_ca_pem",
            "name": "client_ca_pem",
            "go_name": "ClientCAPem",
            "level": 3,
            "type": "PEMData",
            "default": "",
            "comment": "ClientCAPem is a client CA certificate in PEM format.\nThe server uses this certificate to verify the client's certificate during the TLS handshake.",
            "is_complex_type": false
          },
          {
            "field": "http_server.internal_tls.insecure_skip_verify",
            "name": "insecure_skip_verify",
            "go_name": "InsecureSkipVerify",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "InsecureSkipVerify turns off server certificate verification.",
            "is_complex_type": false
          },
          {
            "field": "http_server.internal_tls.server_name",
            "name": "server_name",
            "go_name": "ServerName",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "ServerName is used to verify the hostname on the returned certificates.",
            "is_complex_type": false
          }
        ]
      },
      {
        "field": "http_server.http3",
        "name": "http3",
        "go_name": "HTTP3",
        "level": 2,
        "type": "HTTP3",
        "default": "",
        "comment": "HTTP3 allows enabling HTTP/3 support. EXPERIMENTAL.",
        "is_complex_type": true,
        "children": [
          {
            "field": "http_server.http3.enabled",
            "name": "enabled",
            "go_name": "Enabled",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "",
            "is_complex_type": false
          }
        ]
      }
    ]
  },
  {
    "field": "log",
    "name": "log",
    "go_name": "Log",
    "level": 1,
    "type": "Log",
    "default": "",
    "comment": "Log is a configuration for logging.",
    "is_complex_type": true,
    "children": [
      {
        "field": "log.level",
        "name": "level",
        "go_name": "Level",
        "level": 2,
        "type": "string",
        "default": "info",
        "comment": "Level is a log level for Centrifugo logger. Supported values: `none`, `trace`, `debug`, `info`, `warn`, `error`.",
        "is_complex_type": false
      },
      {
        "field": "log.file",
        "name": "file",
        "go_name": "File",
        "level": 2,
        "type": "string",
        "default": "",
        "comment": "File is a path to log file. If not set logs go to stdout.",
        "is_complex_type": false
      }
    ]
  },
  {
    "field": "engine",
    "name": "engine",
    "go_name": "Engine",
    "level": 1,
    "type": "Engine",
    "default": "",
    "comment": "Engine is a configuration for Centrifugo engine. It's a handy combination of Broker and PresenceManager.\nCurrently only memory and redis engines are supported – both implement all the features. For more granular\ncontrol use `broker` and `presence_manager` options.",
    "is_complex_type": true,
    "children": [
      {
        "field": "engine.type",
        "name": "type",
        "go_name": "Type",
        "level": 2,
        "type": "string",
        "default": "memory",
        "comment": "Type of broker to use. Can be `memory` or `redis` at this point.",
        "is_complex_type": false
      },
      {
        "field": "engine.redis",
        "name": "redis",
        "go_name": "Redis",
        "level": 2,
        "type": "RedisEngine",
        "default": "",
        "comment": "Redis is a configuration for `redis` broker.",
        "is_complex_type": true,
        "children": [
          {
            "field": "engine.redis.prefix",
            "name": "prefix",
            "go_name": "Prefix",
            "level": 3,
            "type": "string",
            "default": "centrifugo",
            "comment": "Prefix for all Redis keys and channels.",
            "is_complex_type": false
          },
          {
            "field": "engine.redis.address",
            "name": "address",
            "go_name": "Address",
            "level": 3,
            "type": "[]string",
            "default": "redis://127.0.0.1:6379",
            "comment": "Address is a list of Redis shard addresses. In most cases a single shard is used. But when many\naddresses provided Centrifugo will distribute keys between shards using consistent hashing.",
            "is_complex_type": false
          },
          {
            "field": "engine.redis.connect_timeout",
            "name": "connect_timeout",
            "go_name": "ConnectTimeout",
            "level": 3,
            "type": "Duration",
            "default": "1s",
            "comment": "ConnectTimeout is a timeout for establishing connection to Redis.",
            "is_complex_type": false
          },
          {
            "field": "engine.redis.io_timeout",
            "name": "io_timeout",
            "go_name": "IOTimeout",
            "level": 3,
            "type": "Duration",
            "default": "4s",
            "comment": "IOTimeout is a timeout for all read/write operations against Redis (can be considered as a request timeout).",
            "is_complex_type": false
          },
          {
            "field": "engine.redis.db",
            "name": "db",
            "go_name": "DB",
            "level": 3,
            "type": "int",
            "default": "0",
            "comment": "DB is a Redis database to use. Generally it's not recommended to use non-zero DB. Note, that Redis\nPUB/SUB is global for all databases in a single Redis instance. So when using non-zero DB make sure\nthat different Centrifugo setups use different prefixes.",
            "is_complex_type": false
          },
          {
            "field": "engine.redis.user",
            "name": "user",
            "go_name": "User",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "User is a Redis user.",
            "is_complex_type": false
          },
          {
            "field": "engine.redis.password",
            "name": "password",
            "go_name": "Password",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "Password is a Redis password.",
            "is_complex_type": false
          },
          {
            "field": "engine.redis.client_name",
            "name": "client_name",
            "go_name": "ClientName",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "ClientName allows changing a Redis client name used when connecting.",
            "is_complex_type": false
          },
          {
            "field": "engine.redis.force_resp2",
            "name": "force_resp2",
            "go_name": "ForceResp2",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "ForceResp2 forces use of Redis Resp2 protocol for communication.",
            "is_complex_type": false
          },
          {
            "field": "engine.redis.cluster_address",
            "name": "cluster_address",
            "go_name": "ClusterAddress",
            "level": 3,
            "type": "[]string",
            "default": "",
            "comment": "ClusterAddress is a list of Redis cluster addresses. When several provided - data will be sharded\nbetween them using consistent hashing. Several Cluster addresses within one shard may be passed\ncomma-separated.",
            "is_complex_type": false
          },
          {
            "field": "engine.redis.tls",
            "name": "tls",
            "go_name": "TLS",
            "level": 3,
            "type": "TLSConfig",
            "default": "",
            "comment": "TLS is a configuration for Redis TLS support.",
            "is_complex_type": true,
            "children": [
              {
                "field": "engine.redis.tls.enabled",
                "name": "enabled",
                "go_name": "Enabled",
                "level": 4,
                "type": "bool",
                "default": "",
                "comment": "Enabled turns on using TLS.",
                "is_complex_type": false
              },
              {
                "field": "engine.redis.tls.cert_pem",
                "name": "cert_pem",
                "go_name": "CertPem",
                "level": 4,
                "type": "PEMData",
                "default": "",
                "comment": "CertPem is a PEM certificate.",
                "is_complex_type": false
              },
              {
                "field": "engine.redis.tls.key_pem",
                "name": "key_pem",
                "go_name": "KeyPem",
                "level": 4,
                "type": "PEMData",
                "default": "",
                "comment": "KeyPem is a path to a file with key in PEM format.",
                "is_complex_type": false
              },
              {
                "field": "engine.redis.tls.server_ca_pem",
                "name": "server_ca_pem",
                "go_name": "ServerCAPem",
                "level": 4,
                "type": "PEMData",
                "default": "",
                "comment": "ServerCAPem is a server root CA certificate in PEM format.\nThe client uses this certificate to verify the server's certificate during the TLS handshake.",
                "is_complex_type": false
              },
              {
                "field": "engine.redis.tls.client_ca_pem",
                "name": "client_ca_pem",
                "go_name": "ClientCAPem",
                "level": 4,
                "type": "PEMData",
                "default": "",
                "comment": "ClientCAPem is a client CA certificate in PEM format.\nThe server uses this certificate to verify the client's certificate during the TLS handshake.",
                "is_complex_type": false
              },
              {
                "field": "engine.redis.tls.insecure_skip_verify",
                "name": "insecure_skip_verify",
                "go_name": "InsecureSkipVerify",
                "level": 4,
                "type": "bool",
                "default": "",
                "comment": "InsecureSkipVerify turns off server certificate verification.",
                "is_complex_type": false
              },
              {
                "field": "engine.redis.tls.server_name",
                "name": "server_name",
                "go_name": "ServerName",
                "level": 4,
                "type": "string",
                "default": "",
                "comment": "ServerName is used to verify the hostname on the returned certificates.",
                "is_complex_type": false
              }
            ]
          },
          {
            "field": "engine.redis.sentinel_address",
            "name": "sentinel_address",
            "go_name": "SentinelAddress",
            "level": 3,
            "type": "[]string",
            "default": "",
            "comment": "SentinelAddress allows setting Redis Sentinel addresses. When provided - Sentinel will be used.\nWhen multiple addresses provided - data will be sharded between them using consistent hashing.\nSeveral Sentinel addresses within one shard may be passed comma-separated.",
            "is_complex_type": false
          },
          {
            "field": "engine.redis.sentinel_user",
            "name": "sentinel_user",
            "go_name": "SentinelUser",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "SentinelUser is a Redis Sentinel user.",
            "is_complex_type": false
          },
          {
            "field": "engine.redis.sentinel_password",
            "name": "sentinel_password",
            "go_name": "SentinelPassword",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "SentinelPassword is a Redis Sentinel password.",
            "is_complex_type": false
          },
          {
            "field": "engine.redis.sentinel_master_name",
            "name": "sentinel_master_name",
            "go_name": "SentinelMasterName",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "SentinelMasterName is a Redis master name in Sentinel setup.",
            "is_complex_type": false
          },
          {
            "field": "engine.redis.sentinel_client_name",
            "name": "sentinel_client_name",
            "go_name": "SentinelClientName",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "SentinelClientName is a Redis Sentinel client name used when connecting.",
            "is_complex_type": false
          },
          {
            "field": "engine.redis.sentinel_tls",
            "name": "sentinel_tls",
            "go_name": "SentinelTLS",
            "level": 3,
            "type": "TLSConfig",
            "default": "",
            "comment": "SentinelTLS is a configuration for Redis Sentinel TLS support.",
            "is_complex_type": true,
            "children": [
              {
                "field": "engine.redis.sentinel_tls.enabled",
                "name": "enabled",
                "go_name": "Enabled",
                "level": 4,
                "type": "bool",
                "default": "",
                "comment": "Enabled turns on using TLS.",
                "is_complex_type": false
              },
              {
                "field": "engine.redis.sentinel_tls.cert_pem",
                "name": "cert_pem",
                "go_name": "CertPem",
                "level": 4,
                "type": "PEMData",
                "default": "",
                "comment": "CertPem is a PEM certificate.",
                "is_complex_type": false
              },
              {
                "field": "engine.redis.sentinel_tls.key_pem",
                "name": "key_pem",
                "go_name": "KeyPem",
                "level": 4,
                "type": "PEMData",
                "default": "",
                "comment": "KeyPem is a path to a file with key in PEM format.",
                "is_complex_type": false
              },
              {
                "field": "engine.redis.sentinel_tls.server_ca_pem",
                "name": "server_ca_pem",
                "go_name": "ServerCAPem",
                "level": 4,
                "type": "PEMData",
                "default": "",
                "comment": "ServerCAPem is a server root CA certificate in PEM format.\nThe client uses this certificate to verify the server's certificate during the TLS handshake.",
                "is_complex_type": false
              },
              {
                "field": "engine.redis.sentinel_tls.client_ca_pem",
                "name": "client_ca_pem",
                "go_name": "ClientCAPem",
                "level": 4,
                "type": "PEMData",
                "default": "",
                "comment": "ClientCAPem is a client CA certificate in PEM format.\nThe server uses this certificate to verify the client's certificate during the TLS handshake.",
                "is_complex_type": false
              },
              {
                "field": "engine.redis.sentinel_tls.insecure_skip_verify",
                "name": "insecure_skip_verify",
                "go_name": "InsecureSkipVerify",
                "level": 4,
                "type": "bool",
                "default": "",
                "comment": "InsecureSkipVerify turns off server certificate verification.",
                "is_complex_type": false
              },
              {
                "field": "engine.redis.sentinel_tls.server_name",
                "name": "server_name",
                "go_name": "ServerName",
                "level": 4,
                "type": "string",
                "default": "",
                "comment": "ServerName is used to verify the hostname on the returned certificates.",
                "is_complex_type": false
              }
            ]
          },
          {
            "field": "engine.redis.replica_client",
            "name": "replica_client",
            "go_name": "ReplicaClient",
            "level": 3,
            "type": "RedisReplicaClient",
            "default": "",
            "comment": "ReplicaClient is a configuration for Redis replica client.",
            "is_complex_type": true,
            "children": [
              {
                "field": "engine.redis.replica_client.enabled",
                "name": "enabled",
                "go_name": "Enabled",
                "level": 4,
                "type": "bool",
                "default": "",
                "comment": "Enabled enables replica client.",
                "is_complex_type": false
              }
            ]
          },
          {
            "field": "engine.redis.history_use_lists",
            "name": "history_use_lists",
            "go_name": "UseLists",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "UseLists enables usage of Redis Lists for history storage. Lists do not support pagination,\nidempotent publish and reverse order history retrieval.",
            "is_complex_type": false
          },
          {
            "field": "engine.redis.presence_ttl",
            "name": "presence_ttl",
            "go_name": "PresenceTTL",
            "level": 3,
            "type": "Duration",
            "default": "60s",
            "comment": "PresenceTTL is a period of time while presence information is considered valid.",
            "is_complex_type": false
          },
          {
            "field": "engine.redis.presence_hash_field_ttl",
            "name": "presence_hash_field_ttl",
            "go_name": "PresenceHashFieldTTL",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "PresenceHashFieldTTL enables using hash per-field expiration for presence.",
            "is_complex_type": false
          },
          {
            "field": "engine.redis.presence_user_mapping",
            "name": "presence_user_mapping",
            "go_name": "PresenceUserMapping",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "PresenceUserMapping enables optimization for presence stats keeping a separate hash of subscribed users in Redis.",
            "is_complex_type": false
          }
        ]
      }
    ]
  },
  {
    "field": "broker",
    "name": "broker",
    "go_name": "Broker",
    "level": 1,
    "type": "Broker",
    "default": "",
    "comment": "Broker allows to configure a message broker to use. Broker is responsible for PUB/SUB functionality\nand channel message history and idempotency cache.\nBy default, memory Broker is used. Memory broker is superfast, but it's not distributed and all\ndata stored in memory (thus lost after node restart). Redis Broker provides seamless horizontal\nscalability, fault-tolerance, and persistence over Centrifugo restarts. Centrifugo also supports\nNats Broker which only implements at most once PUB/SUB semantics.",
    "is_complex_type": true,
    "children": [
      {
        "field": "broker.enabled",
        "name": "enabled",
        "go_name": "Enabled",
        "level": 2,
        "type": "bool",
        "default": "",
        "comment": "",
        "is_complex_type": false
      },
      {
        "field": "broker.type",
        "name": "type",
        "go_name": "Type",
        "level": 2,
        "type": "string",
        "default": "memory",
        "comment": "Type of broker to use. Can be \"memory\", \"redis\", \"nats\" at this point.",
        "is_complex_type": false
      },
      {
        "field": "broker.redis",
        "name": "redis",
        "go_name": "Redis",
        "level": 2,
        "type": "RedisBroker",
        "default": "",
        "comment": "Redis is a configuration for \"redis\" broker.",
        "is_complex_type": true,
        "children": [
          {
            "field": "broker.redis.prefix",
            "name": "prefix",
            "go_name": "Prefix",
            "level": 3,
            "type": "string",
            "default": "centrifugo",
            "comment": "Prefix for all Redis keys and channels.",
            "is_complex_type": false
          },
          {
            "field": "broker.redis.address",
            "name": "address",
            "go_name": "Address",
            "level": 3,
            "type": "[]string",
            "default": "redis://127.0.0.1:6379",
            "comment": "Address is a list of Redis shard addresses. In most cases a single shard is used. But when many\naddresses provided Centrifugo will distribute keys between shards using consistent hashing.",
            "is_complex_type": false
          },
          {
            "field": "broker.redis.connect_timeout",
            "name": "connect_timeout",
            "go_name": "ConnectTimeout",
            "level": 3,
            "type": "Duration",
            "default": "1s",
            "comment": "ConnectTimeout is a timeout for establishing connection to Redis.",
            "is_complex_type": false
          },
          {
            "field": "broker.redis.io_timeout",
            "name": "io_timeout",
            "go_name": "IOTimeout",
            "level": 3,
            "type": "Duration",
            "default": "4s",
            "comment": "IOTimeout is a timeout for all read/write operations against Redis (can be considered as a request timeout).",
            "is_complex_type": false
          },
          {
            "field": "broker.redis.db",
            "name": "db",
            "go_name": "DB",
            "level": 3,
            "type": "int",
            "default": "0",
            "comment": "DB is a Redis database to use. Generally it's not recommended to use non-zero DB. Note, that Redis\nPUB/SUB is global for all databases in a single Redis instance. So when using non-zero DB make sure\nthat different Centrifugo setups use different prefixes.",
            "is_complex_type": false
          },
          {
            "field": "broker.redis.user",
            "name": "user",
            "go_name": "User",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "User is a Redis user.",
            "is_complex_type": false
          },
          {
            "field": "broker.redis.password",
            "name": "password",
            "go_name": "Password",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "Password is a Redis password.",
            "is_complex_type": false
          },
          {
            "field": "broker.redis.client_name",
            "name": "client_name",
            "go_name": "ClientName",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "ClientName allows changing a Redis client name used when connecting.",
            "is_complex_type": false
          },
          {
            "field": "broker.redis.force_resp2",
            "name": "force_resp2",
            "go_name": "ForceResp2",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "ForceResp2 forces use of Redis Resp2 protocol for communication.",
            "is_complex_type": false
          },
          {
            "field": "broker.redis.cluster_address",
            "name": "cluster_address",
            "go_name": "ClusterAddress",
            "level": 3,
            "type": "[]string",
            "default": "",
            "comment": "ClusterAddress is a list of Redis cluster addresses. When several provided - data will be sharded\nbetween them using consistent hashing. Several Cluster addresses within one shard may be passed\ncomma-separated.",
            "is_complex_type": false
          },
          {
            "field": "broker.redis.tls",
            "name": "tls",
            "go_name": "TLS",
            "level": 3,
            "type": "TLSConfig",
            "default": "",
            "comment": "TLS is a configuration for Redis TLS support.",
            "is_complex_type": true,
            "children": [
              {
                "field": "broker.redis.tls.enabled",
                "name": "enabled",
                "go_name": "Enabled",
                "level": 4,
                "type": "bool",
                "default": "",
                "comment": "Enabled turns on using TLS.",
                "is_complex_type": false
              },
              {
                "field": "broker.redis.tls.cert_pem",
                "name": "cert_pem",
                "go_name": "CertPem",
                "level": 4,
                "type": "PEMData",
                "default": "",
                "comment": "CertPem is a PEM certificate.",
                "is_complex_type": false
              },
              {
                "field": "broker.redis.tls.key_pem",
                "name": "key_pem",
                "go_name": "KeyPem",
                "level": 4,
                "type": "PEMData",
                "default": "",
                "comment": "KeyPem is a path to a file with key in PEM format.",
                "is_complex_type": false
              },
              {
                "field": "broker.redis.tls.server_ca_pem",
                "name": "server_ca_pem",
                "go_name": "ServerCAPem",
                "level": 4,
                "type": "PEMData",
                "default": "",
                "comment": "ServerCAPem is a server root CA certificate in PEM format.\nThe client uses this certificate to verify the server's certificate during the TLS handshake.",
                "is_complex_type": false
              },
              {
                "field": "broker.redis.tls.client_ca_pem",
                "name": "client_ca_pem",
                "go_name": "ClientCAPem",
                "level": 4,
                "type": "PEMData",
                "default": "",
                "comment": "ClientCAPem is a client CA certificate in PEM format.\nThe server uses this certificate to verify the client's certificate during the TLS handshake.",
                "is_complex_type": false
              },
              {
                "field": "broker.redis.tls.insecure_skip_verify",
                "name": "insecure_skip_verify",
                "go_name": "InsecureSkipVerify",
                "level": 4,
                "type": "bool",
                "default": "",
                "comment": "InsecureSkipVerify turns off server certificate verification.",
                "is_complex_type": false
              },
              {
                "field": "broker.redis.tls.server_name",
                "name": "server_name",
                "go_name": "ServerName",
                "level": 4,
                "type": "string",
                "default": "",
                "comment": "ServerName is used to verify the hostname on the returned certificates.",
                "is_complex_type": false
              }
            ]
          },
          {
            "field": "broker.redis.sentinel_address",
            "name": "sentinel_address",
            "go_name": "SentinelAddress",
            "level": 3,
            "type": "[]string",
            "default": "",
            "comment": "SentinelAddress allows setting Redis Sentinel addresses. When provided - Sentinel will be used.\nWhen multiple addresses provided - data will be sharded between them using consistent hashing.\nSeveral Sentinel addresses within one shard may be passed comma-separated.",
            "is_complex_type": false
          },
          {
            "field": "broker.redis.sentinel_user",
            "name": "sentinel_user",
            "go_name": "SentinelUser",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "SentinelUser is a Redis Sentinel user.",
            "is_complex_type": false
          },
          {
            "field": "broker.redis.sentinel_password",
            "name": "sentinel_password",
            "go_name": "SentinelPassword",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "SentinelPassword is a Redis Sentinel password.",
            "is_complex_type": false
          },
          {
            "field": "broker.redis.sentinel_master_name",
            "name": "sentinel_master_name",
            "go_name": "SentinelMasterName",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "SentinelMasterName is a Redis master name in Sentinel setup.",
            "is_complex_type": false
          },
          {
            "field": "broker.redis.sentinel_client_name",
            "name": "sentinel_client_name",
            "go_name": "SentinelClientName",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "SentinelClientName is a Redis Sentinel client name used when connecting.",
            "is_complex_type": false
          },
          {
            "field": "broker.redis.sentinel_tls",
            "name": "sentinel_tls",
            "go_name": "SentinelTLS",
            "level": 3,
            "type": "TLSConfig",
            "default": "",
            "comment": "SentinelTLS is a configuration for Redis Sentinel TLS support.",
            "is_complex_type": true,
            "children": [
              {
                "field": "broker.redis.sentinel_tls.enabled",
                "name": "enabled",
                "go_name": "Enabled",
                "level": 4,
                "type": "bool",
                "default": "",
                "comment": "Enabled turns on using TLS.",
                "is_complex_type": false
              },
              {
                "field": "broker.redis.sentinel_tls.cert_pem",
                "name": "cert_pem",
                "go_name": "CertPem",
                "level": 4,
                "type": "PEMData",
                "default": "",
                "comment": "CertPem is a PEM certificate.",
                "is_complex_type": false
              },
              {
                "field": "broker.redis.sentinel_tls.key_pem",
                "name": "key_pem",
                "go_name": "KeyPem",
                "level": 4,
                "type": "PEMData",
                "default": "",
                "comment": "KeyPem is a path to a file with key in PEM format.",
                "is_complex_type": false
              },
              {
                "field": "broker.redis.sentinel_tls.server_ca_pem",
                "name": "server_ca_pem",
                "go_name": "ServerCAPem",
                "level": 4,
                "type": "PEMData",
                "default": "",
                "comment": "ServerCAPem is a server root CA certificate in PEM format.\nThe client uses this certificate to verify the server's certificate during the TLS handshake.",
                "is_complex_type": false
              },
              {
                "field": "broker.redis.sentinel_tls.client_ca_pem",
                "name": "client_ca_pem",
                "go_name": "ClientCAPem",
                "level": 4,
                "type": "PEMData",
                "default": "",
                "comment": "ClientCAPem is a client CA certificate in PEM format.\nThe server uses this certificate to verify the client's certificate during the TLS handshake.",
                "is_complex_type": false
              },
              {
                "field": "broker.redis.sentinel_tls.insecure_skip_verify",
                "name": "insecure_skip_verify",
                "go_name": "InsecureSkipVerify",
                "level": 4,
                "type": "bool",
                "default": "",
                "comment": "InsecureSkipVerify turns off server certificate verification.",
                "is_complex_type": false
              },
              {
                "field": "broker.redis.sentinel_tls.server_name",
                "name": "server_name",
                "go_name": "ServerName",
                "level": 4,
                "type": "string",
                "default": "",
                "comment": "ServerName is used to verify the hostname on the returned certificates.",
                "is_complex_type": false
              }
            ]
          },
          {
            "field": "broker.redis.replica_client",
            "name": "replica_client",
            "go_name": "ReplicaClient",
            "level": 3,
            "type": "RedisReplicaClient",
            "default": "",
            "comment": "ReplicaClient is a configuration for Redis replica client.",
            "is_complex_type": true,
            "children": [
              {
                "field": "broker.redis.replica_client.enabled",
                "name": "enabled",
                "go_name": "Enabled",
                "level": 4,
                "type": "bool",
                "default": "",
                "comment": "Enabled enables replica client.",
                "is_complex_type": false
              }
            ]
          },
          {
            "field": "broker.redis.history_use_lists",
            "name": "history_use_lists",
            "go_name": "UseLists",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "UseLists enables usage of Redis Lists for history storage. Lists do not support pagination,\nidempotent publish and reverse order history retrieval.",
            "is_complex_type": false
          }
        ]
      },
      {
        "field": "broker.nats",
        "name": "nats",
        "go_name": "Nats",
        "level": 2,
        "type": "NatsBroker",
        "default": "",
        "comment": "Nats is a configuration for NATS broker. It does not support history/recovery/cache.",
        "is_complex_type": true,
        "children": [
          {
            "field": "broker.nats.prefix",
            "name": "prefix",
            "go_name": "Prefix",
            "level": 3,
            "type": "string",
            "default": "centrifugo",
            "comment": "Prefix allows customizing channel prefix in Nats to work with a single Nats from different\nunrelated Centrifugo setups.",
            "is_complex_type": false
          },
          {
            "field": "broker.nats.url",
            "name": "url",
            "go_name": "URL",
            "level": 3,
            "type": "string",
            "default": "nats://localhost:4222",
            "comment": "URL is a Nats server URL.",
            "is_complex_type": false
          },
          {
            "field": "broker.nats.dial_timeout",
            "name": "dial_timeout",
            "go_name": "DialTimeout",
            "level": 3,
            "type": "Duration",
            "default": "1s",
            "comment": "DialTimeout is a timeout for establishing connection to Nats.",
            "is_complex_type": false
          },
          {
            "field": "broker.nats.write_timeout",
            "name": "write_timeout",
            "go_name": "WriteTimeout",
            "level": 3,
            "type": "Duration",
            "default": "1s",
            "comment": "WriteTimeout is a timeout for write operation to Nats.",
            "is_complex_type": false
          },
          {
            "field": "broker.nats.tls",
            "name": "tls",
            "go_name": "TLS",
            "level": 3,
            "type": "TLSConfig",
            "default": "",
            "comment": "TLS for the Nats connection. TLS is not used if nil.",
            "is_complex_type": true,
            "children": [
              {
                "field": "broker.nats.tls.enabled",
                "name": "enabled",
                "go_name": "Enabled",
                "level": 4,
                "type": "bool",
                "default": "",
                "comment": "Enabled turns on using TLS.",
                "is_complex_type": false
              },
              {
                "field": "broker.nats.tls.cert_pem",
                "name": "cert_pem",
                "go_name": "CertPem",
                "level": 4,
                "type": "PEMData",
                "default": "",
                "comment": "CertPem is a PEM certificate.",
                "is_complex_type": false
              },
              {
                "field": "broker.nats.tls.key_pem",
                "name": "key_pem",
                "go_name": "KeyPem",
                "level": 4,
                "type": "PEMData",
                "default": "",
                "comment": "KeyPem is a path to a file with key in PEM format.",
                "is_complex_type": false
              },
              {
                "field": "broker.nats.tls.server_ca_pem",
                "name": "server_ca_pem",
                "go_name": "ServerCAPem",
                "level": 4,
                "type": "PEMData",
                "default": "",
                "comment": "ServerCAPem is a server root CA certificate in PEM format.\nThe client uses this certificate to verify the server's certificate during the TLS handshake.",
                "is_complex_type": false
              },
              {
                "field": "broker.nats.tls.client_ca_pem",
                "name": "client_ca_pem",
                "go_name": "ClientCAPem",
                "level": 4,
                "type": "PEMData",
                "default": "",
                "comment": "ClientCAPem is a client CA certificate in PEM format.\nThe server uses this certificate to verify the client's certificate during the TLS handshake.",
                "is_complex_type": false
              },
              {
                "field": "broker.nats.tls.insecure_skip_verify",
                "name": "insecure_skip_verify",
                "go_name": "InsecureSkipVerify",
                "level": 4,
                "type": "bool",
                "default": "",
                "comment": "InsecureSkipVerify turns off server certificate verification.",
                "is_complex_type": false
              },
              {
                "field": "broker.nats.tls.server_name",
                "name": "server_name",
                "go_name": "ServerName",
                "level": 4,
                "type": "string",
                "default": "",
                "comment": "ServerName is used to verify the hostname on the returned certificates.",
                "is_complex_type": false
              }
            ]
          },
          {
            "field": "broker.nats.allow_wildcards",
            "name": "allow_wildcards",
            "go_name": "AllowWildcards",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "AllowWildcards allows to enable wildcard subscriptions. By default, wildcard subscriptions\nare not allowed. Using wildcard subscriptions can't be combined with join/leave events and presence\nbecause subscriptions do not belong to a concrete channel after with wildcards, while join/leave events\nrequire concrete channel to be published. And presence does not make a lot of sense for wildcard\nsubscriptions - there could be subscribers which use different mask, but still receive subset of updates.\nIt's required to use channels without wildcards to for mentioned features to work properly. When\nusing wildcard subscriptions a special care is needed regarding security - pay additional\nattention to a proper permission management.",
            "is_complex_type": false
          },
          {
            "field": "broker.nats.raw_mode",
            "name": "raw_mode",
            "go_name": "RawMode",
            "level": 3,
            "type": "RawModeConfig",
            "default": "",
            "comment": "RawMode allows enabling raw communication with Nats. When on, Centrifugo subscribes to channels\nwithout adding any prefixes to channel name. Proper prefixes must be managed by the application in this\ncase. Data consumed from Nats is sent directly to subscribers without any processing. When publishing\nto Nats Centrifugo does not add any prefixes to channel names also. Centrifugo features like Publication\ntags, Publication ClientInfo, join/leave events are not supported in raw mode.",
            "is_complex_type": true,
            "children": [
              {
                "field": "broker.nats.raw_mode.enabled",
                "name": "enabled",
                "go_name": "Enabled",
                "level": 4,
                "type": "bool",
                "default": "",
                "comment": "Enabled enables raw mode when true.",
                "is_complex_type": false
              },
              {
                "field": "broker.nats.raw_mode.channel_replacements",
                "name": "channel_replacements",
                "go_name": "ChannelReplacements",
                "level": 4,
                "type": "MapStringString",
                "default": "{}",
                "comment": "ChannelReplacements is a map where keys are strings to replace and values are replacements.\nFor example, you have Centrifugo namespace \"chat\" and using channel \"chat:index\", but you want to\nuse channel \"chat.index\" in Nats. Then you can define SymbolReplacements map like this: `{\":\": \".\"}`.\nIn this case Centrifugo will replace all \":\" symbols in channel name with \".\" before sending to Nats.\nBroker keeps reverse mapping to the original channel to broadcast to proper channels when processing\nmessages received from Nats.",
                "is_complex_type": false
              },
              {
                "field": "broker.nats.raw_mode.prefix",
                "name": "prefix",
                "go_name": "Prefix",
                "level": 4,
                "type": "string",
                "default": "",
                "comment": "Prefix is a string that will be added to all channels when publishing messages to Nats, subscribing\nto channels in Nats. It's also stripped from channel name when processing messages received from Nats.\nBy default, no prefix is used.",
                "is_complex_type": false
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "field": "presence_manager",
    "name": "presence_manager",
    "go_name": "PresenceManager",
    "level": 1,
    "type": "PresenceManager",
    "default": "",
    "comment": "PresenceManager allows to configure a presence manager to use. Presence manager is responsible for\npresence information storage and retrieval. By default, memory PresenceManager is used. Memory\nPresenceManager is superfast, but it's not distributed. Redis PresenceManager provides a seamless\nhorizontal scalability.",
    "is_complex_type": true,
    "children": [
      {
        "field": "presence_manager.enabled",
        "name": "enabled",
        "go_name": "Enabled",
        "level": 2,
        "type": "bool",
        "default": "",
        "comment": "",
        "is_complex_type": false
      },
      {
        "field": "presence_manager.type",
        "name": "type",
        "go_name": "Type",
        "level": 2,
        "type": "string",
        "default": "memory",
        "comment": "Type of presence manager to use. Can be \"memory\" or \"redis\" at this point.",
        "is_complex_type": false
      },
      {
        "field": "presence_manager.redis",
        "name": "redis",
        "go_name": "Redis",
        "level": 2,
        "type": "RedisPresenceManager",
        "default": "",
        "comment": "Redis is a configuration for \"redis\" broker.",
        "is_complex_type": true,
        "children": [
          {
            "field": "presence_manager.redis.prefix",
            "name": "prefix",
            "go_name": "Prefix",
            "level": 3,
            "type": "string",
            "default": "centrifugo",
            "comment": "Prefix for all Redis keys and channels.",
            "is_complex_type": false
          },
          {
            "field": "presence_manager.redis.address",
            "name": "address",
            "go_name": "Address",
            "level": 3,
            "type": "[]string",
            "default": "redis://127.0.0.1:6379",
            "comment": "Address is a list of Redis shard addresses. In most cases a single shard is used. But when many\naddresses provided Centrifugo will distribute keys between shards using consistent hashing.",
            "is_complex_type": false
          },
          {
            "field": "presence_manager.redis.connect_timeout",
            "name": "connect_timeout",
            "go_name": "ConnectTimeout",
            "level": 3,
            "type": "Duration",
            "default": "1s",
            "comment": "ConnectTimeout is a timeout for establishing connection to Redis.",
            "is_complex_type": false
          },
          {
            "field": "presence_manager.redis.io_timeout",
            "name": "io_timeout",
            "go_name": "IOTimeout",
            "level": 3,
            "type": "Duration",
            "default": "4s",
            "comment": "IOTimeout is a timeout for all read/write operations against Redis (can be considered as a request timeout).",
            "is_complex_type": false
          },
          {
            "field": "presence_manager.redis.db",
            "name": "db",
            "go_name": "DB",
            "level": 3,
            "type": "int",
            "default": "0",
            "comment": "DB is a Redis database to use. Generally it's not recommended to use non-zero DB. Note, that Redis\nPUB/SUB is global for all databases in a single Redis instance. So when using non-zero DB make sure\nthat different Centrifugo setups use different prefixes.",
            "is_complex_type": false
          },
          {
            "field": "presence_manager.redis.user",
            "name": "user",
            "go_name": "User",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "User is a Redis user.",
            "is_complex_type": false
          },
          {
            "field": "presence_manager.redis.password",
            "name": "password",
            "go_name": "Password",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "Password is a Redis password.",
            "is_complex_type": false
          },
          {
            "field": "presence_manager.redis.client_name",
            "name": "client_name",
            "go_name": "ClientName",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "ClientName allows changing a Redis client name used when connecting.",
            "is_complex_type": false
          },
          {
            "field": "presence_manager.redis.force_resp2",
            "name": "force_resp2",
            "go_name": "ForceResp2",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "ForceResp2 forces use of Redis Resp2 protocol for communication.",
            "is_complex_type": false
          },
          {
            "field": "presence_manager.redis.cluster_address",
            "name": "cluster_address",
            "go_name": "ClusterAddress",
            "level": 3,
            "type": "[]string",
            "default": "",
            "comment": "ClusterAddress is a list of Redis cluster addresses. When several provided - data will be sharded\nbetween them using consistent hashing. Several Cluster addresses within one shard may be passed\ncomma-separated.",
            "is_complex_type": false
          },
          {
            "field": "presence_manager.redis.tls",
            "name": "tls",
            "go_name": "TLS",
            "level": 3,
            "type": "TLSConfig",
            "default": "",
            "comment": "TLS is a configuration for Redis TLS support.",
            "is_complex_type": true,
            "children": [
              {
                "field": "presence_manager.redis.tls.enabled",
                "name": "enabled",
                "go_name": "Enabled",
                "level": 4,
                "type": "bool",
                "default": "",
                "comment": "Enabled turns on using TLS.",
                "is_complex_type": false
              },
              {
                "field": "presence_manager.redis.tls.cert_pem",
                "name": "cert_pem",
                "go_name": "CertPem",
                "level": 4,
                "type": "PEMData",
                "default": "",
                "comment": "CertPem is a PEM certificate.",
                "is_complex_type": false
              },
              {
                "field": "presence_manager.redis.tls.key_pem",
                "name": "key_pem",
                "go_name": "KeyPem",
                "level": 4,
                "type": "PEMData",
                "default": "",
                "comment": "KeyPem is a path to a file with key in PEM format.",
                "is_complex_type": false
              },
              {
                "field": "presence_manager.redis.tls.server_ca_pem",
                "name": "server_ca_pem",
                "go_name": "ServerCAPem",
                "level": 4,
                "type": "PEMData",
                "default": "",
                "comment": "ServerCAPem is a server root CA certificate in PEM format.\nThe client uses this certificate to verify the server's certificate during the TLS handshake.",
                "is_complex_type": false
              },
              {
                "field": "presence_manager.redis.tls.client_ca_pem",
                "name": "client_ca_pem",
                "go_name": "ClientCAPem",
                "level": 4,
                "type": "PEMData",
                "default": "",
                "comment": "ClientCAPem is a client CA certificate in PEM format.\nThe server uses this certificate to verify the client's certificate during the TLS handshake.",
                "is_complex_type": false
              },
              {
                "field": "presence_manager.redis.tls.insecure_skip_verify",
                "name": "insecure_skip_verify",
                "go_name": "InsecureSkipVerify",
                "level": 4,
                "type": "bool",
                "default": "",
                "comment": "InsecureSkipVerify turns off server certificate verification.",
                "is_complex_type": false
              },
              {
                "field": "presence_manager.redis.tls.server_name",
                "name": "server_name",
                "go_name": "ServerName",
                "level": 4,
                "type": "string",
                "default": "",
                "comment": "ServerName is used to verify the hostname on the returned certificates.",
                "is_complex_type": false
              }
            ]
          },
          {
            "field": "presence_manager.redis.sentinel_address",
            "name": "sentinel_address",
            "go_name": "SentinelAddress",
            "level": 3,
            "type": "[]string",
            "default": "",
            "comment": "SentinelAddress allows setting Redis Sentinel addresses. When provided - Sentinel will be used.\nWhen multiple addresses provided - data will be sharded between them using consistent hashing.\nSeveral Sentinel addresses within one shard may be passed comma-separated.",
            "is_complex_type": false
          },
          {
            "field": "presence_manager.redis.sentinel_user",
            "name": "sentinel_user",
            "go_name": "SentinelUser",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "SentinelUser is a Redis Sentinel user.",
            "is_complex_type": false
          },
          {
            "field": "presence_manager.redis.sentinel_password",
            "name": "sentinel_password",
            "go_name": "SentinelPassword",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "SentinelPassword is a Redis Sentinel password.",
            "is_complex_type": false
          },
          {
            "field": "presence_manager.redis.sentinel_master_name",
            "name": "sentinel_master_name",
            "go_name": "SentinelMasterName",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "SentinelMasterName is a Redis master name in Sentinel setup.",
            "is_complex_type": false
          },
          {
            "field": "presence_manager.redis.sentinel_client_name",
            "name": "sentinel_client_name",
            "go_name": "SentinelClientName",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "SentinelClientName is a Redis Sentinel client name used when connecting.",
            "is_complex_type": false
          },
          {
            "field": "presence_manager.redis.sentinel_tls",
            "name": "sentinel_tls",
            "go_name": "SentinelTLS",
            "level": 3,
            "type": "TLSConfig",
            "default": "",
            "comment": "SentinelTLS is a configuration for Redis Sentinel TLS support.",
            "is_complex_type": true,
            "children": [
              {
                "field": "presence_manager.redis.sentinel_tls.enabled",
                "name": "enabled",
                "go_name": "Enabled",
                "level": 4,
                "type": "bool",
                "default": "",
                "comment": "Enabled turns on using TLS.",
                "is_complex_type": false
              },
              {
                "field": "presence_manager.redis.sentinel_tls.cert_pem",
                "name": "cert_pem",
                "go_name": "CertPem",
                "level": 4,
                "type": "PEMData",
                "default": "",
                "comment": "CertPem is a PEM certificate.",
                "is_complex_type": false
              },
              {
                "field": "presence_manager.redis.sentinel_tls.key_pem",
                "name": "key_pem",
                "go_name": "KeyPem",
                "level": 4,
                "type": "PEMData",
                "default": "",
                "comment": "KeyPem is a path to a file with key in PEM format.",
                "is_complex_type": false
              },
              {
                "field": "presence_manager.redis.sentinel_tls.server_ca_pem",
                "name": "server_ca_pem",
                "go_name": "ServerCAPem",
                "level": 4,
                "type": "PEMData",
                "default": "",
                "comment": "ServerCAPem is a server root CA certificate in PEM format.\nThe client uses this certificate to verify the server's certificate during the TLS handshake.",
                "is_complex_type": false
              },
              {
                "field": "presence_manager.redis.sentinel_tls.client_ca_pem",
                "name": "client_ca_pem",
                "go_name": "ClientCAPem",
                "level": 4,
                "type": "PEMData",
                "default": "",
                "comment": "ClientCAPem is a client CA certificate in PEM format.\nThe server uses this certificate to verify the client's certificate during the TLS handshake.",
                "is_complex_type": false
              },
              {
                "field": "presence_manager.redis.sentinel_tls.insecure_skip_verify",
                "name": "insecure_skip_verify",
                "go_name": "InsecureSkipVerify",
                "level": 4,
                "type": "bool",
                "default": "",
                "comment": "InsecureSkipVerify turns off server certificate verification.",
                "is_complex_type": false
              },
              {
                "field": "presence_manager.redis.sentinel_tls.server_name",
                "name": "server_name",
                "go_name": "ServerName",
                "level": 4,
                "type": "string",
                "default": "",
                "comment": "ServerName is used to verify the hostname on the returned certificates.",
                "is_complex_type": false
              }
            ]
          },
          {
            "field": "presence_manager.redis.replica_client",
            "name": "replica_client",
            "go_name": "ReplicaClient",
            "level": 3,
            "type": "RedisReplicaClient",
            "default": "",
            "comment": "ReplicaClient is a configuration for Redis replica client.",
            "is_complex_type": true,
            "children": [
              {
                "field": "presence_manager.redis.replica_client.enabled",
                "name": "enabled",
                "go_name": "Enabled",
                "level": 4,
                "type": "bool",
                "default": "",
                "comment": "Enabled enables replica client.",
                "is_complex_type": false
              }
            ]
          },
          {
            "field": "presence_manager.redis.presence_ttl",
            "name": "presence_ttl",
            "go_name": "PresenceTTL",
            "level": 3,
            "type": "Duration",
            "default": "60s",
            "comment": "PresenceTTL is a period of time while presence information is considered valid.",
            "is_complex_type": false
          },
          {
            "field": "presence_manager.redis.presence_hash_field_ttl",
            "name": "presence_hash_field_ttl",
            "go_name": "PresenceHashFieldTTL",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "PresenceHashFieldTTL enables using hash per-field expiration for presence.",
            "is_complex_type": false
          },
          {
            "field": "presence_manager.redis.presence_user_mapping",
            "name": "presence_user_mapping",
            "go_name": "PresenceUserMapping",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "PresenceUserMapping enables optimization for presence stats keeping a separate hash of subscribed users in Redis.",
            "is_complex_type": false
          }
        ]
      }
    ]
  },
  {
    "field": "client",
    "name": "client",
    "go_name": "Client",
    "level": 1,
    "type": "Client",
    "default": "",
    "comment": "Client contains real-time client connection related configuration.",
    "is_complex_type": true,
    "children": [
      {
        "field": "client.proxy",
        "name": "proxy",
        "go_name": "Proxy",
        "level": 2,
        "type": "ClientProxyContainer",
        "default": "",
        "comment": "Proxy is a configuration for client connection-wide proxies.",
        "is_complex_type": true,
        "children": [
          {
            "field": "client.proxy.connect",
            "name": "connect",
            "go_name": "Connect",
            "level": 3,
            "type": "ConnectProxy",
            "default": "",
            "comment": "Connect proxy when enabled is used to proxy connect requests from client to the application backend.\nOnly requests without JWT token are proxied at this point.",
            "is_complex_type": true,
            "children": [
              {
                "field": "client.proxy.connect.enabled",
                "name": "enabled",
                "go_name": "Enabled",
                "level": 4,
                "type": "bool",
                "default": "",
                "comment": "Enabled must be true to tell Centrifugo to enable the configured proxy.",
                "is_complex_type": false
              },
              {
                "field": "client.proxy.connect.endpoint",
                "name": "endpoint",
                "go_name": "Endpoint",
                "level": 4,
                "type": "string",
                "default": "",
                "comment": "Endpoint - HTTP address or GRPC service endpoint.",
                "is_complex_type": false
              },
              {
                "field": "client.proxy.connect.timeout",
                "name": "timeout",
                "go_name": "Timeout",
                "level": 4,
                "type": "Duration",
                "default": "1s",
                "comment": "Timeout for proxy request.",
                "is_complex_type": false
              },
              {
                "field": "client.proxy.connect.http_headers",
                "name": "http_headers",
                "go_name": "HttpHeaders",
                "level": 4,
                "type": "[]string",
                "default": "",
                "comment": "HttpHeaders is a list of HTTP headers to proxy. No headers used by proxy by default.\nIf GRPC proxy is used then request HTTP headers set to outgoing request metadata.",
                "is_complex_type": false
              },
              {
                "field": "client.proxy.connect.grpc_metadata",
                "name": "grpc_metadata",
                "go_name": "GrpcMetadata",
                "level": 4,
                "type": "[]string",
                "default": "",
                "comment": "GrpcMetadata is a list of GRPC metadata keys to proxy. No meta keys used by proxy by\ndefault. If HTTP proxy is used then these keys become outgoing request HTTP headers.",
                "is_complex_type": false
              },
              {
                "field": "client.proxy.connect.binary_encoding",
                "name": "binary_encoding",
                "go_name": "BinaryEncoding",
                "level": 4,
                "type": "bool",
                "default": "",
                "comment": "BinaryEncoding makes proxy send data as base64 string (assuming it contains custom\nnon-JSON payload).",
                "is_complex_type": false
              },
              {
                "field": "client.proxy.connect.include_connection_meta",
                "name": "include_connection_meta",
                "go_name": "IncludeConnectionMeta",
                "level": 4,
                "type": "bool",
                "default": "",
                "comment": "IncludeConnectionMeta to each proxy request (except connect proxy where it's obtained).",
                "is_complex_type": false
              },
              {
                "field": "client.proxy.connect.http",
                "name": "http",
                "go_name": "HTTP",
                "level": 4,
                "type": "ProxyCommonHTTP",
                "default": "",
                "comment": "",
                "is_complex_type": true,
                "children": [
                  {
                    "field": "client.proxy.connect.http.tls",
                    "name": "tls",
                    "go_name": "TLS",
                    "level": 5,
                    "type": "TLSConfig",
                    "default": "",
                    "comment": "TLS for HTTP client.",
                    "is_complex_type": true,
                    "children": [
                      {
                        "field": "client.proxy.connect.http.tls.enabled",
                        "name": "enabled",
                        "go_name": "Enabled",
                        "level": 6,
                        "type": "bool",
                        "default": "",
                        "comment": "Enabled turns on using TLS.",
                        "is_complex_type": false
                      },
                      {
                        "field": "client.proxy.connect.http.tls.cert_pem",
                        "name": "cert_pem",
                        "go_name": "CertPem",
                        "level": 6,
                        "type": "PEMData",
                        "default": "",
                        "comment": "CertPem is a PEM certificate.",
                        "is_complex_type": false
                      },
                      {
                        "field": "client.proxy.connect.http.tls.key_pem",
                        "name": "key_pem",
                        "go_name": "KeyPem",
                        "level": 6,
                        "type": "PEMData",
                        "default": "",
                        "comment": "KeyPem is a path to a file with key in PEM format.",
                        "is_complex_type": false
                      },
                      {
                        "field": "client.proxy.connect.http.tls.server_ca_pem",
                        "name": "server_ca_pem",
                        "go_name": "ServerCAPem",
                        "level": 6,
                        "type": "PEMData",
                        "default": "",
                        "comment": "ServerCAPem is a server root CA certificate in PEM format.\nThe client uses this certificate to verify the server's certificate during the TLS handshake.",
                        "is_complex_type": false
                      },
                      {
                        "field": "client.proxy.connect.http.tls.client_ca_pem",
                        "name": "client_ca_pem",
                        "go_name": "ClientCAPem",
                        "level": 6,
                        "type": "PEMData",
                        "default": "",
                        "comment": "ClientCAPem is a client CA certificate in PEM format.\nThe server uses this certificate to verify the client's certificate during the TLS handshake.",
                        "is_complex_type": false
                      },
                      {
                        "field": "client.proxy.connect.http.tls.insecure_skip_verify",
                        "name": "insecure_skip_verify",
                        "go_name": "InsecureSkipVerify",
                        "level": 6,
                        "type": "bool",
                        "default": "",
                        "comment": "InsecureSkipVerify turns off server certificate verification.",
                        "is_complex_type": false
                      },
                      {
                        "field": "client.proxy.connect.http.tls.server_name",
                        "name": "server_name",
                        "go_name": "ServerName",
                        "level": 6,
                        "type": "string",
                        "default": "",
                        "comment": "ServerName is used to verify the hostname on the returned certificates.",
                        "is_complex_type": false
                      }
                    ]
                  },
                  {
                    "field": "client.proxy.connect.http.static_headers",
                    "name": "static_headers",
                    "go_name": "StaticHeaders",
                    "level": 5,
                    "type": "MapStringString",
                    "default": "{}",
                    "comment": "StaticHeaders is a static set of key/value pairs to attach to HTTP proxy request as\nheaders. Headers received from HTTP client request or metadata from GRPC client request\nboth have priority over values set in StaticHttpHeaders map.",
                    "is_complex_type": false
                  },
                  {
                    "field": "client.proxy.connect.http.status_to_code_transforms",
                    "name": "status_to_code_transforms",
                    "go_name": "StatusToCodeTransforms",
                    "level": 5,
                    "type": "[]HttpStatusToCodeTransform",
                    "default": "[]",
                    "comment": "StatusToCodeTransforms allow to map HTTP status codes from proxy to Disconnect or Error messages.",
                    "is_complex_type": true,
                    "children": [
                      {
                        "field": "client.proxy.connect.http.status_to_code_transforms[].status_code",
                        "name": "status_code",
                        "go_name": "StatusCode",
                        "level": 6,
                        "type": "int",
                        "default": "",
                        "comment": "StatusCode is an HTTP status code to transform.",
                        "is_complex_type": false
                      },
                      {
                        "field": "client.proxy.connect.http.status_to_code_transforms[].to_error",
                        "name": "to_error",
                        "go_name": "ToError",
                        "level": 6,
                        "type": "TransformError",
                        "default": "",
                        "comment": "ToError is a transform to protocol error.",
                        "is_complex_type": true,
                        "children": [
                          {
                            "field": "client.proxy.connect.http.status_to_code_transforms[].to_error.code",
                            "name": "code",
                            "go_name": "Code",
                            "level": 7,
                            "type": "uint32",
                            "default": "",
                            "comment": "Code of error.",
                            "is_complex_type": false
                          },
                          {
                            "field": "client.proxy.connect.http.status_to_code_transforms[].to_error.message",
                            "name": "message",
                            "go_name": "Message",
                            "level": 7,
                            "type": "string",
                            "default": "",
                            "comment": "Message is a human-readable message of error.",
                            "is_complex_type": false
                          },
                          {
                            "field": "client.proxy.connect.http.status_to_code_transforms[].to_error.temporary",
                            "name": "temporary",
                            "go_name": "Temporary",
                            "level": 7,
                            "type": "bool",
                            "default": "",
                            "comment": "Temporary is a flag to mark error as temporary.",
                            "is_complex_type": false
                          }
                        ]
                      },
                      {
                        "field": "client.proxy.connect.http.status_to_code_transforms[].to_disconnect",
                        "name": "to_disconnect",
                        "go_name": "ToDisconnect",
                        "level": 6,
                        "type": "TransformDisconnect",
                        "default": "",
                        "comment": "ToDisconnect is a transform to protocol disconnect.",
                        "is_complex_type": true,
                        "children": [
                          {
                            "field": "client.proxy.connect.http.status_to_code_transforms[].to_disconnect.code",
                            "name": "code",
                            "go_name": "Code",
                            "level": 7,
                            "type": "uint32",
                            "default": "",
                            "comment": "Code of disconnect.",
                            "is_complex_type": false
                          },
                          {
                            "field": "client.proxy.connect.http.status_to_code_transforms[].to_disconnect.reason",
                            "name": "reason",
                            "go_name": "Reason",
                            "level": 7,
                            "type": "string",
                            "default": "",
                            "comment": "Reason is a human-readable reason of disconnect.",
                            "is_complex_type": false
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "field": "client.proxy.connect.grpc",
                "name": "grpc",
                "go_name": "GRPC",
                "level": 4,
                "type": "ProxyCommonGRPC",
                "default": "",
                "comment": "",
                "is_complex_type": true,
                "children": [
                  {
                    "field": "client.proxy.connect.grpc.tls",
                    "name": "tls",
                    "go_name": "TLS",
                    "level": 5,
                    "type": "TLSConfig",
                    "default": "",
                    "comment": "TLS is a common configuration for GRPC client TLS.",
                    "is_complex_type": true,
                    "children": [
                      {
                        "field": "client.proxy.connect.grpc.tls.enabled",
                        "name": "enabled",
                        "go_name": "Enabled",
                        "level": 6,
                        "type": "bool",
                        "default": "",
                        "comment": "Enabled turns on using TLS.",
                        "is_complex_type": false
                      },
                      {
                        "field": "client.proxy.connect.grpc.tls.cert_pem",
                        "name": "cert_pem",
                        "go_name": "CertPem",
                        "level": 6,
                        "type": "PEMData",
                        "default": "",
                        "comment": "CertPem is a PEM certificate.",
                        "is_complex_type": false
                      },
                      {
                        "field": "client.proxy.connect.grpc.tls.key_pem",
                        "name": "key_pem",
                        "go_name": "KeyPem",
                        "level": 6,
                        "type": "PEMData",
                        "default": "",
                        "comment": "KeyPem is a path to a file with key in PEM format.",
                        "is_complex_type": false
                      },
                      {
                        "field": "client.proxy.connect.grpc.tls.server_ca_pem",
                        "name": "server_ca_pem",
                        "go_name": "ServerCAPem",
                        "level": 6,
                        "type": "PEMData",
                        "default": "",
                        "comment": "ServerCAPem is a server root CA certificate in PEM format.\nThe client uses this certificate to verify the server's certificate during the TLS handshake.",
                        "is_complex_type": false
                      },
                      {
                        "field": "client.proxy.connect.grpc.tls.client_ca_pem",
                        "name": "client_ca_pem",
                        "go_name": "ClientCAPem",
                        "level": 6,
                        "type": "PEMData",
                        "default": "",
                        "comment": "ClientCAPem is a client CA certificate in PEM format.\nThe server uses this certificate to verify the client's certificate during the TLS handshake.",
                        "is_complex_type": false
                      },
                      {
                        "field": "client.proxy.connect.grpc.tls.insecure_skip_verify",
                        "name": "insecure_skip_verify",
                        "go_name": "InsecureSkipVerify",
                        "level": 6,
                        "type": "bool",
                        "default": "",
                        "comment": "InsecureSkipVerify turns off server certificate verification.",
                        "is_complex_type": false
                      },
                      {
                        "field": "client.proxy.connect.grpc.tls.server_name",
                        "name": "server_name",
                        "go_name": "ServerName",
                        "level": 6,
                        "type": "string",
                        "default": "",
                        "comment": "ServerName is used to verify the hostname on the returned certificates.",
                        "is_complex_type": false
                      }
                    ]
                  },
                  {
                    "field": "client.proxy.connect.grpc.credentials_key",
                    "name": "credentials_key",
                    "go_name": "CredentialsKey",
                    "level": 5,
                    "type": "string",
                    "default": "",
                    "comment": "CredentialsKey is a custom key to add into per-RPC credentials.",
                    "is_complex_type": false
                  },
                  {
                    "field": "client.proxy.connect.grpc.credentials_value",
                    "name": "credentials_value",
                    "go_name": "CredentialsValue",
                    "level": 5,
                    "type": "string",
                    "default": "",
                    "comment": "CredentialsValue is a custom value for GrpcCredentialsKey.",
                    "is_complex_type": false
                  },
                  {
                    "field": "client.proxy.connect.grpc.compression",
                    "name": "compression",
                    "go_name": "Compression",
                    "level": 5,
                    "type": "bool",
                    "default": "",
                    "comment": "Compression enables compression for outgoing calls (gzip).",
                    "is_complex_type": false
                  }
                ]
              }
            ]
          },
          {
            "field": "client.proxy.refresh",
            "name": "refresh",
            "go_name": "Refresh",
            "level": 3,
            "type": "RefreshProxy",
            "default": "",
            "comment": "Refresh proxy when enabled is used to proxy client connection refresh decisions to the application backend.",
            "is_complex_type": true,
            "children": [
              {
                "field": "client.proxy.refresh.enabled",
                "name": "enabled",
                "go_name": "Enabled",
                "level": 4,
                "type": "bool",
                "default": "",
                "comment": "Enabled must be true to tell Centrifugo to enable the configured proxy.",
                "is_complex_type": false
              },
              {
                "field": "client.proxy.refresh.endpoint",
                "name": "endpoint",
                "go_name": "Endpoint",
                "level": 4,
                "type": "string",
                "default": "",
                "comment": "Endpoint - HTTP address or GRPC service endpoint.",
                "is_complex_type": false
              },
              {
                "field": "client.proxy.refresh.timeout",
                "name": "timeout",
                "go_name": "Timeout",
                "level": 4,
                "type": "Duration",
                "default": "1s",
                "comment": "Timeout for proxy request.",
                "is_complex_type": false
              },
              {
                "field": "client.proxy.refresh.http_headers",
                "name": "http_headers",
                "go_name": "HttpHeaders",
                "level": 4,
                "type": "[]string",
                "default": "",
                "comment": "HttpHeaders is a list of HTTP headers to proxy. No headers used by proxy by default.\nIf GRPC proxy is used then request HTTP headers set to outgoing request metadata.",
                "is_complex_type": false
              },
              {
                "field": "client.proxy.refresh.grpc_metadata",
                "name": "grpc_metadata",
                "go_name": "GrpcMetadata",
                "level": 4,
                "type": "[]string",
                "default": "",
                "comment": "GrpcMetadata is a list of GRPC metadata keys to proxy. No meta keys used by proxy by\ndefault. If HTTP proxy is used then these keys become outgoing request HTTP headers.",
                "is_complex_type": false
              },
              {
                "field": "client.proxy.refresh.binary_encoding",
                "name": "binary_encoding",
                "go_name": "BinaryEncoding",
                "level": 4,
                "type": "bool",
                "default": "",
                "comment": "BinaryEncoding makes proxy send data as base64 string (assuming it contains custom\nnon-JSON payload).",
                "is_complex_type": false
              },
              {
                "field": "client.proxy.refresh.include_connection_meta",
                "name": "include_connection_meta",
                "go_name": "IncludeConnectionMeta",
                "level": 4,
                "type": "bool",
                "default": "",
                "comment": "IncludeConnectionMeta to each proxy request (except connect proxy where it's obtained).",
                "is_complex_type": false
              },
              {
                "field": "client.proxy.refresh.http",
                "name": "http",
                "go_name": "HTTP",
                "level": 4,
                "type": "ProxyCommonHTTP",
                "default": "",
                "comment": "",
                "is_complex_type": true,
                "children": [
                  {
                    "field": "client.proxy.refresh.http.tls",
                    "name": "tls",
                    "go_name": "TLS",
                    "level": 5,
                    "type": "TLSConfig",
                    "default": "",
                    "comment": "TLS for HTTP client.",
                    "is_complex_type": true,
                    "children": [
                      {
                        "field": "client.proxy.refresh.http.tls.enabled",
                        "name": "enabled",
                        "go_name": "Enabled",
                        "level": 6,
                        "type": "bool",
                        "default": "",
                        "comment": "Enabled turns on using TLS.",
                        "is_complex_type": false
                      },
                      {
                        "field": "client.proxy.refresh.http.tls.cert_pem",
                        "name": "cert_pem",
                        "go_name": "CertPem",
                        "level": 6,
                        "type": "PEMData",
                        "default": "",
                        "comment": "CertPem is a PEM certificate.",
                        "is_complex_type": false
                      },
                      {
                        "field": "client.proxy.refresh.http.tls.key_pem",
                        "name": "key_pem",
                        "go_name": "KeyPem",
                        "level": 6,
                        "type": "PEMData",
                        "default": "",
                        "comment": "KeyPem is a path to a file with key in PEM format.",
                        "is_complex_type": false
                      },
                      {
                        "field": "client.proxy.refresh.http.tls.server_ca_pem",
                        "name": "server_ca_pem",
                        "go_name": "ServerCAPem",
                        "level": 6,
                        "type": "PEMData",
                        "default": "",
                        "comment": "ServerCAPem is a server root CA certificate in PEM format.\nThe client uses this certificate to verify the server's certificate during the TLS handshake.",
                        "is_complex_type": false
                      },
                      {
                        "field": "client.proxy.refresh.http.tls.client_ca_pem",
                        "name": "client_ca_pem",
                        "go_name": "ClientCAPem",
                        "level": 6,
                        "type": "PEMData",
                        "default": "",
                        "comment": "ClientCAPem is a client CA certificate in PEM format.\nThe server uses this certificate to verify the client's certificate during the TLS handshake.",
                        "is_complex_type": false
                      },
                      {
                        "field": "client.proxy.refresh.http.tls.insecure_skip_verify",
                        "name": "insecure_skip_verify",
                        "go_name": "InsecureSkipVerify",
                        "level": 6,
                        "type": "bool",
                        "default": "",
                        "comment": "InsecureSkipVerify turns off server certificate verification.",
                        "is_complex_type": false
                      },
                      {
                        "field": "client.proxy.refresh.http.tls.server_name",
                        "name": "server_name",
                        "go_name": "ServerName",
                        "level": 6,
                        "type": "string",
                        "default": "",
                        "comment": "ServerName is used to verify the hostname on the returned certificates.",
                        "is_complex_type": false
                      }
                    ]
                  },
                  {
                    "field": "client.proxy.refresh.http.static_headers",
                    "name": "static_headers",
                    "go_name": "StaticHeaders",
                    "level": 5,
                    "type": "MapStringString",
                    "default": "{}",
                    "comment": "StaticHeaders is a static set of key/value pairs to attach to HTTP proxy request as\nheaders. Headers received from HTTP client request or metadata from GRPC client request\nboth have priority over values set in StaticHttpHeaders map.",
                    "is_complex_type": false
                  },
                  {
                    "field": "client.proxy.refresh.http.status_to_code_transforms",
                    "name": "status_to_code_transforms",
                    "go_name": "StatusToCodeTransforms",
                    "level": 5,
                    "type": "[]HttpStatusToCodeTransform",
                    "default": "[]",
                    "comment": "StatusToCodeTransforms allow to map HTTP status codes from proxy to Disconnect or Error messages.",
                    "is_complex_type": true,
                    "children": [
                      {
                        "field": "client.proxy.refresh.http.status_to_code_transforms[].status_code",
                        "name": "status_code",
                        "go_name": "StatusCode",
                        "level": 6,
                        "type": "int",
                        "default": "",
                        "comment": "StatusCode is an HTTP status code to transform.",
                        "is_complex_type": false
                      },
                      {
                        "field": "client.proxy.refresh.http.status_to_code_transforms[].to_error",
                        "name": "to_error",
                        "go_name": "ToError",
                        "level": 6,
                        "type": "TransformError",
                        "default": "",
                        "comment": "ToError is a transform to protocol error.",
                        "is_complex_type": true,
                        "children": [
                          {
                            "field": "client.proxy.refresh.http.status_to_code_transforms[].to_error.code",
                            "name": "code",
                            "go_name": "Code",
                            "level": 7,
                            "type": "uint32",
                            "default": "",
                            "comment": "Code of error.",
                            "is_complex_type": false
                          },
                          {
                            "field": "client.proxy.refresh.http.status_to_code_transforms[].to_error.message",
                            "name": "message",
                            "go_name": "Message",
                            "level": 7,
                            "type": "string",
                            "default": "",
                            "comment": "Message is a human-readable message of error.",
                            "is_complex_type": false
                          },
                          {
                            "field": "client.proxy.refresh.http.status_to_code_transforms[].to_error.temporary",
                            "name": "temporary",
                            "go_name": "Temporary",
                            "level": 7,
                            "type": "bool",
                            "default": "",
                            "comment": "Temporary is a flag to mark error as temporary.",
                            "is_complex_type": false
                          }
                        ]
                      },
                      {
                        "field": "client.proxy.refresh.http.status_to_code_transforms[].to_disconnect",
                        "name": "to_disconnect",
                        "go_name": "ToDisconnect",
                        "level": 6,
                        "type": "TransformDisconnect",
                        "default": "",
                        "comment": "ToDisconnect is a transform to protocol disconnect.",
                        "is_complex_type": true,
                        "children": [
                          {
                            "field": "client.proxy.refresh.http.status_to_code_transforms[].to_disconnect.code",
                            "name": "code",
                            "go_name": "Code",
                            "level": 7,
                            "type": "uint32",
                            "default": "",
                            "comment": "Code of disconnect.",
                            "is_complex_type": false
                          },
                          {
                            "field": "client.proxy.refresh.http.status_to_code_transforms[].to_disconnect.reason",
                            "name": "reason",
                            "go_name": "Reason",
                            "level": 7,
                            "type": "string",
                            "default": "",
                            "comment": "Reason is a human-readable reason of disconnect.",
                            "is_complex_type": false
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "field": "client.proxy.refresh.grpc",
                "name": "grpc",
                "go_name": "GRPC",
                "level": 4,
                "type": "ProxyCommonGRPC",
                "default": "",
                "comment": "",
                "is_complex_type": true,
                "children": [
                  {
                    "field": "client.proxy.refresh.grpc.tls",
                    "name": "tls",
                    "go_name": "TLS",
                    "level": 5,
                    "type": "TLSConfig",
                    "default": "",
                    "comment": "TLS is a common configuration for GRPC client TLS.",
                    "is_complex_type": true,
                    "children": [
                      {
                        "field": "client.proxy.refresh.grpc.tls.enabled",
                        "name": "enabled",
                        "go_name": "Enabled",
                        "level": 6,
                        "type": "bool",
                        "default": "",
                        "comment": "Enabled turns on using TLS.",
                        "is_complex_type": false
                      },
                      {
                        "field": "client.proxy.refresh.grpc.tls.cert_pem",
                        "name": "cert_pem",
                        "go_name": "CertPem",
                        "level": 6,
                        "type": "PEMData",
                        "default": "",
                        "comment": "CertPem is a PEM certificate.",
                        "is_complex_type": false
                      },
                      {
                        "field": "client.proxy.refresh.grpc.tls.key_pem",
                        "name": "key_pem",
                        "go_name": "KeyPem",
                        "level": 6,
                        "type": "PEMData",
                        "default": "",
                        "comment": "KeyPem is a path to a file with key in PEM format.",
                        "is_complex_type": false
                      },
                      {
                        "field": "client.proxy.refresh.grpc.tls.server_ca_pem",
                        "name": "server_ca_pem",
                        "go_name": "ServerCAPem",
                        "level": 6,
                        "type": "PEMData",
                        "default": "",
                        "comment": "ServerCAPem is a server root CA certificate in PEM format.\nThe client uses this certificate to verify the server's certificate during the TLS handshake.",
                        "is_complex_type": false
                      },
                      {
                        "field": "client.proxy.refresh.grpc.tls.client_ca_pem",
                        "name": "client_ca_pem",
                        "go_name": "ClientCAPem",
                        "level": 6,
                        "type": "PEMData",
                        "default": "",
                        "comment": "ClientCAPem is a client CA certificate in PEM format.\nThe server uses this certificate to verify the client's certificate during the TLS handshake.",
                        "is_complex_type": false
                      },
                      {
                        "field": "client.proxy.refresh.grpc.tls.insecure_skip_verify",
                        "name": "insecure_skip_verify",
                        "go_name": "InsecureSkipVerify",
                        "level": 6,
                        "type": "bool",
                        "default": "",
                        "comment": "InsecureSkipVerify turns off server certificate verification.",
                        "is_complex_type": false
                      },
                      {
                        "field": "client.proxy.refresh.grpc.tls.server_name",
                        "name": "server_name",
                        "go_name": "ServerName",
                        "level": 6,
                        "type": "string",
                        "default": "",
                        "comment": "ServerName is used to verify the hostname on the returned certificates.",
                        "is_complex_type": false
                      }
                    ]
                  },
                  {
                    "field": "client.proxy.refresh.grpc.credentials_key",
                    "name": "credentials_key",
                    "go_name": "CredentialsKey",
                    "level": 5,
                    "type": "string",
                    "default": "",
                    "comment": "CredentialsKey is a custom key to add into per-RPC credentials.",
                    "is_complex_type": false
                  },
                  {
                    "field": "client.proxy.refresh.grpc.credentials_value",
                    "name": "credentials_value",
                    "go_name": "CredentialsValue",
                    "level": 5,
                    "type": "string",
                    "default": "",
                    "comment": "CredentialsValue is a custom value for GrpcCredentialsKey.",
                    "is_complex_type": false
                  },
                  {
                    "field": "client.proxy.refresh.grpc.compression",
                    "name": "compression",
                    "go_name": "Compression",
                    "level": 5,
                    "type": "bool",
                    "default": "",
                    "comment": "Compression enables compression for outgoing calls (gzip).",
                    "is_complex_type": false
                  }
                ]
              }
            ]
          }
        ]
      },
      {
        "field": "client.allowed_origins",
        "name": "allowed_origins",
        "go_name": "AllowedOrigins",
        "level": 2,
        "type": "[]string",
        "default": "",
        "comment": "AllowedOrigins is a list of allowed origins for client connections.",
        "is_complex_type": false
      },
      {
        "field": "client.token",
        "name": "token",
        "go_name": "Token",
        "level": 2,
        "type": "Token",
        "default": "",
        "comment": "Token is a configuration for token generation and verification. When enabled, this configuration\nis used for both connection and subscription tokens. See also SubscriptionToken to use a separate\nconfiguration for subscription tokens.",
        "is_complex_type": true,
        "children": [
          {
            "field": "client.token.hmac_secret_key",
            "name": "hmac_secret_key",
            "go_name": "HMACSecretKey",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "",
            "is_complex_type": false
          },
          {
            "field": "client.token.rsa_public_key",
            "name": "rsa_public_key",
            "go_name": "RSAPublicKey",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "",
            "is_complex_type": false
          },
          {
            "field": "client.token.ecdsa_public_key",
            "name": "ecdsa_public_key",
            "go_name": "ECDSAPublicKey",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "",
            "is_complex_type": false
          },
          {
            "field": "client.token.jwks_public_endpoint",
            "name": "jwks_public_endpoint",
            "go_name": "JWKSPublicEndpoint",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "",
            "is_complex_type": false
          },
          {
            "field": "client.token.audience",
            "name": "audience",
            "go_name": "Audience",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "",
            "is_complex_type": false
          },
          {
            "field": "client.token.audience_regex",
            "name": "audience_regex",
            "go_name": "AudienceRegex",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "",
            "is_complex_type": false
          },
          {
            "field": "client.token.issuer",
            "name": "issuer",
            "go_name": "Issuer",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "",
            "is_complex_type": false
          },
          {
            "field": "client.token.issuer_regex",
            "name": "issuer_regex",
            "go_name": "IssuerRegex",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "",
            "is_complex_type": false
          },
          {
            "field": "client.token.user_id_claim",
            "name": "user_id_claim",
            "go_name": "UserIDClaim",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "",
            "is_complex_type": false
          }
        ]
      },
      {
        "field": "client.subscription_token",
        "name": "subscription_token",
        "go_name": "SubscriptionToken",
        "level": 2,
        "type": "SubscriptionToken",
        "default": "",
        "comment": "SubscriptionToken is a configuration for subscription token generation and verification. When enabled,\nCentrifugo will use this configuration for subscription tokens only. Configuration in Token is then only\nused for connection tokens.",
        "is_complex_type": true,
        "children": [
          {
            "field": "client.subscription_token.enabled",
            "name": "enabled",
            "go_name": "Enabled",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "Enabled allows enabling separate configuration for subscription tokens.",
            "is_complex_type": false
          },
          {
            "field": "client.subscription_token.hmac_secret_key",
            "name": "hmac_secret_key",
            "go_name": "HMACSecretKey",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "",
            "is_complex_type": false
          },
          {
            "field": "client.subscription_token.rsa_public_key",
            "name": "rsa_public_key",
            "go_name": "RSAPublicKey",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "",
            "is_complex_type": false
          },
          {
            "field": "client.subscription_token.ecdsa_public_key",
            "name": "ecdsa_public_key",
            "go_name": "ECDSAPublicKey",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "",
            "is_complex_type": false
          },
          {
            "field": "client.subscription_token.jwks_public_endpoint",
            "name": "jwks_public_endpoint",
            "go_name": "JWKSPublicEndpoint",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "",
            "is_complex_type": false
          },
          {
            "field": "client.subscription_token.audience",
            "name": "audience",
            "go_name": "Audience",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "",
            "is_complex_type": false
          },
          {
            "field": "client.subscription_token.audience_regex",
            "name": "audience_regex",
            "go_name": "AudienceRegex",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "",
            "is_complex_type": false
          },
          {
            "field": "client.subscription_token.issuer",
            "name": "issuer",
            "go_name": "Issuer",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "",
            "is_complex_type": false
          },
          {
            "field": "client.subscription_token.issuer_regex",
            "name": "issuer_regex",
            "go_name": "IssuerRegex",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "",
            "is_complex_type": false
          },
          {
            "field": "client.subscription_token.user_id_claim",
            "name": "user_id_claim",
            "go_name": "UserIDClaim",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "",
            "is_complex_type": false
          }
        ]
      },
      {
        "field": "client.allow_anonymous_connect_without_token",
        "name": "allow_anonymous_connect_without_token",
        "go_name": "AllowAnonymousConnectWithoutToken",
        "level": 2,
        "type": "bool",
        "default": "",
        "comment": "AllowAnonymousConnectWithoutToken allows to connect to Centrifugo without a token. In this case connection will\nbe accepted but client will be anonymous (i.e. will have empty user ID).",
        "is_complex_type": false
      },
      {
        "field": "client.disallow_anonymous_connection_tokens",
        "name": "disallow_anonymous_connection_tokens",
        "go_name": "DisallowAnonymousConnectionTokens",
        "level": 2,
        "type": "bool",
        "default": "",
        "comment": "DisallowAnonymousConnectionTokens disallows anonymous connection tokens. When enabled, Centrifugo will not\naccept connection tokens with empty user ID.",
        "is_complex_type": false
      },
      {
        "field": "client.ping_interval",
        "name": "ping_interval",
        "go_name": "PingInterval",
        "level": 2,
        "type": "Duration",
        "default": "25s",
        "comment": "PingInterval tells how often to issue server-to-client pings.\nTo disable sending app-level pings use -1.",
        "is_complex_type": false
      },
      {
        "field": "client.pong_timeout",
        "name": "pong_timeout",
        "go_name": "PongTimeout",
        "level": 2,
        "type": "Duration",
        "default": "8s",
        "comment": "PongTimeout sets time for pong check after issuing a ping. To disable pong checks use -1.\nPongTimeout must be less than PingInterval in current implementation.",
        "is_complex_type": false
      },
      {
        "field": "client.expired_close_delay",
        "name": "expired_close_delay",
        "go_name": "ExpiredCloseDelay",
        "level": 2,
        "type": "Duration",
        "default": "25s",
        "comment": "ExpiredConnectionCloseDelay is a delay before closing connection after it becomes expired.",
        "is_complex_type": false
      },
      {
        "field": "client.expired_sub_close_delay",
        "name": "expired_sub_close_delay",
        "go_name": "ExpiredSubCloseDelay",
        "level": 2,
        "type": "Duration",
        "default": "25s",
        "comment": "ExpiredSubCloseDelay is a delay before closing subscription after it becomes expired.",
        "is_complex_type": false
      },
      {
        "field": "client.stale_close_delay",
        "name": "stale_close_delay",
        "go_name": "StaleCloseDelay",
        "level": 2,
        "type": "Duration",
        "default": "10s",
        "comment": "StaleConnectionCloseDelay is a delay before closing stale connection (which does not authenticate after connecting).",
        "is_complex_type": false
      },
      {
        "field": "client.channel_limit",
        "name": "channel_limit",
        "go_name": "ChannelLimit",
        "level": 2,
        "type": "int",
        "default": "128",
        "comment": "ChannelLimit is a maximum number of channels client can subscribe to.",
        "is_complex_type": false
      },
      {
        "field": "client.queue_max_size",
        "name": "queue_max_size",
        "go_name": "QueueMaxSize",
        "level": 2,
        "type": "int",
        "default": "1048576",
        "comment": "QueueMaxSize is a maximum size of message queue for client connection in bytes.",
        "is_complex_type": false
      },
      {
        "field": "client.presence_update_interval",
        "name": "presence_update_interval",
        "go_name": "PresenceUpdateInterval",
        "level": 2,
        "type": "Duration",
        "default": "27s",
        "comment": "PresenceUpdateInterval is a period of time how often to update presence info for subscriptions of connected client.",
        "is_complex_type": false
      },
      {
        "field": "client.concurrency",
        "name": "concurrency",
        "go_name": "Concurrency",
        "level": 2,
        "type": "int",
        "default": "",
        "comment": "Concurrency is a maximum number of concurrent operations for client connection. If not set only one operation can be processed at a time.",
        "is_complex_type": false
      },
      {
        "field": "client.channel_position_check_delay",
        "name": "channel_position_check_delay",
        "go_name": "ChannelPositionCheckDelay",
        "level": 2,
        "type": "Duration",
        "default": "40s",
        "comment": "ChannelPositionCheckDelay is a delay between channel position checks for client subscriptions.",
        "is_complex_type": false
      },
      {
        "field": "client.channel_position_max_time_lag",
        "name": "channel_position_max_time_lag",
        "go_name": "ChannelPositionMaxTimeLag",
        "level": 2,
        "type": "Duration",
        "default": "",
        "comment": "ChannelPositionMaxTimeLag is a maximum allowed time lag for publications for subscribers with positioning on. When\nexceeded we mark connection with insufficient state. By default, not used - i.e. Centrifugo does not take lag into\naccount for positioning. See pub_sub_time_lag_seconds as a helpful Prometheus metric.",
        "is_complex_type": false
      },
      {
        "field": "client.connection_limit",
        "name": "connection_limit",
        "go_name": "ConnectionLimit",
        "level": 2,
        "type": "int",
        "default": "",
        "comment": "ConnectionLimit is a maximum number of connections Centrifugo node can accept.",
        "is_complex_type": false
      },
      {
        "field": "client.user_connection_limit",
        "name": "user_connection_limit",
        "go_name": "UserConnectionLimit",
        "level": 2,
        "type": "int",
        "default": "",
        "comment": "UserConnectionLimit is a maximum number of connections Centrifugo node can accept from a single user.",
        "is_complex_type": false
      },
      {
        "field": "client.connection_rate_limit",
        "name": "connection_rate_limit",
        "go_name": "ConnectionRateLimit",
        "level": 2,
        "type": "int",
        "default": "",
        "comment": "ConnectionRateLimit is a maximum number of connections per second Centrifugo node can accept.",
        "is_complex_type": false
      },
      {
        "field": "client.connect_include_server_time",
        "name": "connect_include_server_time",
        "go_name": "ConnectIncludeServerTime",
        "level": 2,
        "type": "bool",
        "default": "",
        "comment": "ConnectIncludeServerTime allows to include server time in connect reply of client protocol.",
        "is_complex_type": false
      },
      {
        "field": "client.history_max_publication_limit",
        "name": "history_max_publication_limit",
        "go_name": "HistoryMaxPublicationLimit",
        "level": 2,
        "type": "int",
        "default": "300",
        "comment": "HistoryMaxPublicationLimit is a maximum number of publications Centrifugo returns in client history requests.",
        "is_complex_type": false
      },
      {
        "field": "client.recovery_max_publication_limit",
        "name": "recovery_max_publication_limit",
        "go_name": "RecoveryMaxPublicationLimit",
        "level": 2,
        "type": "int",
        "default": "300",
        "comment": "RecoveryMaxPublicationLimit is a maximum number of publications Centrifugo returns during client recovery.",
        "is_complex_type": false
      },
      {
        "field": "client.insecure_skip_token_signature_verify",
        "name": "insecure_skip_token_signature_verify",
        "go_name": "InsecureSkipTokenSignatureVerify",
        "level": 2,
        "type": "bool",
        "default": "",
        "comment": "InsecureSkipTokenSignatureVerify allows to skip token signature verification. This can be useful for testing purposes.",
        "is_complex_type": false
      },
      {
        "field": "client.user_id_http_header",
        "name": "user_id_http_header",
        "go_name": "UserIDHTTPHeader",
        "level": 2,
        "type": "string",
        "default": "",
        "comment": "UserIDHTTPHeader is a name of HTTP header to extract user ID from. If set Centrifugo will try to extract user ID from this header.",
        "is_complex_type": false
      },
      {
        "field": "client.insecure",
        "name": "insecure",
        "go_name": "Insecure",
        "level": 2,
        "type": "bool",
        "default": "",
        "comment": "Insecure allows to disable auth features in client protocol. Obviously - must not be used in production until you know what you do.",
        "is_complex_type": false
      },
      {
        "field": "client.subscribe_to_user_personal_channel",
        "name": "subscribe_to_user_personal_channel",
        "go_name": "SubscribeToUserPersonalChannel",
        "level": 2,
        "type": "SubscribeToUserPersonalChannel",
        "default": "",
        "comment": "SubscribeToUserPersonalChannel is a configuration for a feature to automatically subscribe user to a personal channel\nusing server-side subscription.",
        "is_complex_type": true,
        "children": [
          {
            "field": "client.subscribe_to_user_personal_channel.enabled",
            "name": "enabled",
            "go_name": "Enabled",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "Enabled allows to enable the feature.",
            "is_complex_type": false
          },
          {
            "field": "client.subscribe_to_user_personal_channel.personal_channel_namespace",
            "name": "personal_channel_namespace",
            "go_name": "PersonalChannelNamespace",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "PersonalChannelNamespace is a namespace for personal channels.",
            "is_complex_type": false
          },
          {
            "field": "client.subscribe_to_user_personal_channel.single_connection",
            "name": "single_connection",
            "go_name": "SingleConnection",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "SingleConnection allows enabling a mode when Centrifugo will try to maintain a single connection from user.",
            "is_complex_type": false
          }
        ]
      },
      {
        "field": "client.connect_code_to_unidirectional_disconnect",
        "name": "connect_code_to_unidirectional_disconnect",
        "go_name": "ConnectCodeToUnidirectionalDisconnect",
        "level": 2,
        "type": "ConnectCodeToUnidirectionalDisconnect",
        "default": "",
        "comment": "ConnectCodeToUnidirectionalDisconnect is a configuration for a feature to transform connect error codes to the disconnect code\nfor unidirectional transports.",
        "is_complex_type": true,
        "children": [
          {
            "field": "client.connect_code_to_unidirectional_disconnect.enabled",
            "name": "enabled",
            "go_name": "Enabled",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "Enabled allows to enable the feature.",
            "is_complex_type": false
          },
          {
            "field": "client.connect_code_to_unidirectional_disconnect.transforms",
            "name": "transforms",
            "go_name": "Transforms",
            "level": 3,
            "type": "[]UniConnectCodeToDisconnectTransform",
            "default": "[]",
            "comment": "Transforms is a list of connect error code to disconnect code transforms.",
            "is_complex_type": true,
            "children": [
              {
                "field": "client.connect_code_to_unidirectional_disconnect.transforms[].code",
                "name": "code",
                "go_name": "Code",
                "level": 4,
                "type": "uint32",
                "default": "",
                "comment": "Code is a connect error code.",
                "is_complex_type": false
              },
              {
                "field": "client.connect_code_to_unidirectional_disconnect.transforms[].to",
                "name": "to",
                "go_name": "To",
                "level": 4,
                "type": "TransformDisconnect",
                "default": "",
                "comment": "To is a disconnect to transform the code to.",
                "is_complex_type": true,
                "children": [
                  {
                    "field": "client.connect_code_to_unidirectional_disconnect.transforms[].to.code",
                    "name": "code",
                    "go_name": "Code",
                    "level": 5,
                    "type": "uint32",
                    "default": "",
                    "comment": "Code of disconnect.",
                    "is_complex_type": false
                  },
                  {
                    "field": "client.connect_code_to_unidirectional_disconnect.transforms[].to.reason",
                    "name": "reason",
                    "go_name": "Reason",
                    "level": 5,
                    "type": "string",
                    "default": "",
                    "comment": "Reason is a human-readable reason of disconnect.",
                    "is_complex_type": false
                  }
                ]
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "field": "channel",
    "name": "channel",
    "go_name": "Channel",
    "level": 1,
    "type": "Channel",
    "default": "",
    "comment": "Channel contains real-time channel related configuration.",
    "is_complex_type": true,
    "children": [
      {
        "field": "channel.proxy",
        "name": "proxy",
        "go_name": "Proxy",
        "level": 2,
        "type": "ChannelProxyContainer",
        "default": "",
        "comment": "Proxy configuration for channel-related events. All types inside can be referenced by the name \"default\".",
        "is_complex_type": true,
        "children": [
          {
            "field": "channel.proxy.subscribe",
            "name": "subscribe",
            "go_name": "Subscribe",
            "level": 3,
            "type": "Proxy",
            "default": "",
            "comment": "Subscribe proxy configuration.",
            "is_complex_type": true,
            "children": [
              {
                "field": "channel.proxy.subscribe.endpoint",
                "name": "endpoint",
                "go_name": "Endpoint",
                "level": 4,
                "type": "string",
                "default": "",
                "comment": "Endpoint - HTTP address or GRPC service endpoint.",
                "is_complex_type": false
              },
              {
                "field": "channel.proxy.subscribe.timeout",
                "name": "timeout",
                "go_name": "Timeout",
                "level": 4,
                "type": "Duration",
                "default": "1s",
                "comment": "Timeout for proxy request.",
                "is_complex_type": false
              },
              {
                "field": "channel.proxy.subscribe.http_headers",
                "name": "http_headers",
                "go_name": "HttpHeaders",
                "level": 4,
                "type": "[]string",
                "default": "",
                "comment": "HttpHeaders is a list of HTTP headers to proxy. No headers used by proxy by default.\nIf GRPC proxy is used then request HTTP headers set to outgoing request metadata.",
                "is_complex_type": false
              },
              {
                "field": "channel.proxy.subscribe.grpc_metadata",
                "name": "grpc_metadata",
                "go_name": "GrpcMetadata",
                "level": 4,
                "type": "[]string",
                "default": "",
                "comment": "GrpcMetadata is a list of GRPC metadata keys to proxy. No meta keys used by proxy by\ndefault. If HTTP proxy is used then these keys become outgoing request HTTP headers.",
                "is_complex_type": false
              },
              {
                "field": "channel.proxy.subscribe.binary_encoding",
                "name": "binary_encoding",
                "go_name": "BinaryEncoding",
                "level": 4,
                "type": "bool",
                "default": "",
                "comment": "BinaryEncoding makes proxy send data as base64 string (assuming it contains custom\nnon-JSON payload).",
                "is_complex_type": false
              },
              {
                "field": "channel.proxy.subscribe.include_connection_meta",
                "name": "include_connection_meta",
                "go_name": "IncludeConnectionMeta",
                "level": 4,
                "type": "bool",
                "default": "",
                "comment": "IncludeConnectionMeta to each proxy request (except connect proxy where it's obtained).",
                "is_complex_type": false
              },
              {
                "field": "channel.proxy.subscribe.http",
                "name": "http",
                "go_name": "HTTP",
                "level": 4,
                "type": "ProxyCommonHTTP",
                "default": "",
                "comment": "",
                "is_complex_type": true,
                "children": [
                  {
                    "field": "channel.proxy.subscribe.http.tls",
                    "name": "tls",
                    "go_name": "TLS",
                    "level": 5,
                    "type": "TLSConfig",
                    "default": "",
                    "comment": "TLS for HTTP client.",
                    "is_complex_type": true,
                    "children": [
                      {
                        "field": "channel.proxy.subscribe.http.tls.enabled",
                        "name": "enabled",
                        "go_name": "Enabled",
                        "level": 6,
                        "type": "bool",
                        "default": "",
                        "comment": "Enabled turns on using TLS.",
                        "is_complex_type": false
                      },
                      {
                        "field": "channel.proxy.subscribe.http.tls.cert_pem",
                        "name": "cert_pem",
                        "go_name": "CertPem",
                        "level": 6,
                        "type": "PEMData",
                        "default": "",
                        "comment": "CertPem is a PEM certificate.",
                        "is_complex_type": false
                      },
                      {
                        "field": "channel.proxy.subscribe.http.tls.key_pem",
                        "name": "key_pem",
                        "go_name": "KeyPem",
                        "level": 6,
                        "type": "PEMData",
                        "default": "",
                        "comment": "KeyPem is a path to a file with key in PEM format.",
                        "is_complex_type": false
                      },
                      {
                        "field": "channel.proxy.subscribe.http.tls.server_ca_pem",
                        "name": "server_ca_pem",
                        "go_name": "ServerCAPem",
                        "level": 6,
                        "type": "PEMData",
                        "default": "",
                        "comment": "ServerCAPem is a server root CA certificate in PEM format.\nThe client uses this certificate to verify the server's certificate during the TLS handshake.",
                        "is_complex_type": false
                      },
                      {
                        "field": "channel.proxy.subscribe.http.tls.client_ca_pem",
                        "name": "client_ca_pem",
                        "go_name": "ClientCAPem",
                        "level": 6,
                        "type": "PEMData",
                        "default": "",
                        "comment": "ClientCAPem is a client CA certificate in PEM format.\nThe server uses this certificate to verify the client's certificate during the TLS handshake.",
                        "is_complex_type": false
                      },
                      {
                        "field": "channel.proxy.subscribe.http.tls.insecure_skip_verify",
                        "name": "insecure_skip_verify",
                        "go_name": "InsecureSkipVerify",
                        "level": 6,
                        "type": "bool",
                        "default": "",
                        "comment": "InsecureSkipVerify turns off server certificate verification.",
                        "is_complex_type": false
                      },
                      {
                        "field": "channel.proxy.subscribe.http.tls.server_name",
                        "name": "server_name",
                        "go_name": "ServerName",
                        "level": 6,
                        "type": "string",
                        "default": "",
                        "comment": "ServerName is used to verify the hostname on the returned certificates.",
                        "is_complex_type": false
                      }
                    ]
                  },
                  {
                    "field": "channel.proxy.subscribe.http.static_headers",
                    "name": "static_headers",
                    "go_name": "StaticHeaders",
                    "level": 5,
                    "type": "MapStringString",
                    "default": "{}",
                    "comment": "StaticHeaders is a static set of key/value pairs to attach to HTTP proxy request as\nheaders. Headers received from HTTP client request or metadata from GRPC client request\nboth have priority over values set in StaticHttpHeaders map.",
                    "is_complex_type": false
                  },
                  {
                    "field": "channel.proxy.subscribe.http.status_to_code_transforms",
                    "name": "status_to_code_transforms",
                    "go_name": "StatusToCodeTransforms",
                    "level": 5,
                    "type": "[]HttpStatusToCodeTransform",
                    "default": "[]",
                    "comment": "StatusToCodeTransforms allow to map HTTP status codes from proxy to Disconnect or Error messages.",
                    "is_complex_type": true,
                    "children": [
                      {
                        "field": "channel.proxy.subscribe.http.status_to_code_transforms[].status_code",
                        "name": "status_code",
                        "go_name": "StatusCode",
                        "level": 6,
                        "type": "int",
                        "default": "",
                        "comment": "StatusCode is an HTTP status code to transform.",
                        "is_complex_type": false
                      },
                      {
                        "field": "channel.proxy.subscribe.http.status_to_code_transforms[].to_error",
                        "name": "to_error",
                        "go_name": "ToError",
                        "level": 6,
                        "type": "TransformError",
                        "default": "",
                        "comment": "ToError is a transform to protocol error.",
                        "is_complex_type": true,
                        "children": [
                          {
                            "field": "channel.proxy.subscribe.http.status_to_code_transforms[].to_error.code",
                            "name": "code",
                            "go_name": "Code",
                            "level": 7,
                            "type": "uint32",
                            "default": "",
                            "comment": "Code of error.",
                            "is_complex_type": false
                          },
                          {
                            "field": "channel.proxy.subscribe.http.status_to_code_transforms[].to_error.message",
                            "name": "message",
                            "go_name": "Message",
                            "level": 7,
                            "type": "string",
                            "default": "",
                            "comment": "Message is a human-readable message of error.",
                            "is_complex_type": false
                          },
                          {
                            "field": "channel.proxy.subscribe.http.status_to_code_transforms[].to_error.temporary",
                            "name": "temporary",
                            "go_name": "Temporary",
                            "level": 7,
                            "type": "bool",
                            "default": "",
                            "comment": "Temporary is a flag to mark error as temporary.",
                            "is_complex_type": false
                          }
                        ]
                      },
                      {
                        "field": "channel.proxy.subscribe.http.status_to_code_transforms[].to_disconnect",
                        "name": "to_disconnect",
                        "go_name": "ToDisconnect",
                        "level": 6,
                        "type": "TransformDisconnect",
                        "default": "",
                        "comment": "ToDisconnect is a transform to protocol disconnect.",
                        "is_complex_type": true,
                        "children": [
                          {
                            "field": "channel.proxy.subscribe.http.status_to_code_transforms[].to_disconnect.code",
                            "name": "code",
                            "go_name": "Code",
                            "level": 7,
                            "type": "uint32",
                            "default": "",
                            "comment": "Code of disconnect.",
                            "is_complex_type": false
                          },
                          {
                            "field": "channel.proxy.subscribe.http.status_to_code_transforms[].to_disconnect.reason",
                            "name": "reason",
                            "go_name": "Reason",
                            "level": 7,
                            "type": "string",
                            "default": "",
                            "comment": "Reason is a human-readable reason of disconnect.",
                            "is_complex_type": false
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "field": "channel.proxy.subscribe.grpc",
                "name": "grpc",
                "go_name": "GRPC",
                "level": 4,
                "type": "ProxyCommonGRPC",
                "default": "",
                "comment": "",
                "is_complex_type": true,
                "children": [
                  {
                    "field": "channel.proxy.subscribe.grpc.tls",
                    "name": "tls",
                    "go_name": "TLS",
                    "level": 5,
                    "type": "TLSConfig",
                    "default": "",
                    "comment": "TLS is a common configuration for GRPC client TLS.",
                    "is_complex_type": true,
                    "children": [
                      {
                        "field": "channel.proxy.subscribe.grpc.tls.enabled",
                        "name": "enabled",
                        "go_name": "Enabled",
                        "level": 6,
                        "type": "bool",
                        "default": "",
                        "comment": "Enabled turns on using TLS.",
                        "is_complex_type": false
                      },
                      {
                        "field": "channel.proxy.subscribe.grpc.tls.cert_pem",
                        "name": "cert_pem",
                        "go_name": "CertPem",
                        "level": 6,
                        "type": "PEMData",
                        "default": "",
                        "comment": "CertPem is a PEM certificate.",
                        "is_complex_type": false
                      },
                      {
                        "field": "channel.proxy.subscribe.grpc.tls.key_pem",
                        "name": "key_pem",
                        "go_name": "KeyPem",
                        "level": 6,
                        "type": "PEMData",
                        "default": "",
                        "comment": "KeyPem is a path to a file with key in PEM format.",
                        "is_complex_type": false
                      },
                      {
                        "field": "channel.proxy.subscribe.grpc.tls.server_ca_pem",
                        "name": "server_ca_pem",
                        "go_name": "ServerCAPem",
                        "level": 6,
                        "type": "PEMData",
                        "default": "",
                        "comment": "ServerCAPem is a server root CA certificate in PEM format.\nThe client uses this certificate to verify the server's certificate during the TLS handshake.",
                        "is_complex_type": false
                      },
                      {
                        "field": "channel.proxy.subscribe.grpc.tls.client_ca_pem",
                        "name": "client_ca_pem",
                        "go_name": "ClientCAPem",
                        "level": 6,
                        "type": "PEMData",
                        "default": "",
                        "comment": "ClientCAPem is a client CA certificate in PEM format.\nThe server uses this certificate to verify the client's certificate during the TLS handshake.",
                        "is_complex_type": false
                      },
                      {
                        "field": "channel.proxy.subscribe.grpc.tls.insecure_skip_verify",
                        "name": "insecure_skip_verify",
                        "go_name": "InsecureSkipVerify",
                        "level": 6,
                        "type": "bool",
                        "default": "",
                        "comment": "InsecureSkipVerify turns off server certificate verification.",
                        "is_complex_type": false
                      },
                      {
                        "field": "channel.proxy.subscribe.grpc.tls.server_name",
                        "name": "server_name",
                        "go_name": "ServerName",
                        "level": 6,
                        "type": "string",
                        "default": "",
                        "comment": "ServerName is used to verify the hostname on the returned certificates.",
                        "is_complex_type": false
                      }
                    ]
                  },
                  {
                    "field": "channel.proxy.subscribe.grpc.credentials_key",
                    "name": "credentials_key",
                    "go_name": "CredentialsKey",
                    "level": 5,
                    "type": "string",
                    "default": "",
                    "comment": "CredentialsKey is a custom key to add into per-RPC credentials.",
                    "is_complex_type": false
                  },
                  {
                    "field": "channel.proxy.subscribe.grpc.credentials_value",
                    "name": "credentials_value",
                    "go_name": "CredentialsValue",
                    "level": 5,
                    "type": "string",
                    "default": "",
                    "comment": "CredentialsValue is a custom value for GrpcCredentialsKey.",
                    "is_complex_type": false
                  },
                  {
                    "field": "channel.proxy.subscribe.grpc.compression",
                    "name": "compression",
                    "go_name": "Compression",
                    "level": 5,
                    "type": "bool",
                    "default": "",
                    "comment": "Compression enables compression for outgoing calls (gzip).",
                    "is_complex_type": false
                  }
                ]
              }
            ]
          },
          {
            "field": "channel.proxy.publish",
            "name": "publish",
            "go_name": "Publish",
            "level": 3,
            "type": "Proxy",
            "default": "",
            "comment": "Publish proxy configuration.",
            "is_complex_type": true,
            "children": [
              {
                "field": "channel.proxy.publish.endpoint",
                "name": "endpoint",
                "go_name": "Endpoint",
                "level": 4,
                "type": "string",
                "default": "",
                "comment": "Endpoint - HTTP address or GRPC service endpoint.",
                "is_complex_type": false
              },
              {
                "field": "channel.proxy.publish.timeout",
                "name": "timeout",
                "go_name": "Timeout",
                "level": 4,
                "type": "Duration",
                "default": "1s",
                "comment": "Timeout for proxy request.",
                "is_complex_type": false
              },
              {
                "field": "channel.proxy.publish.http_headers",
                "name": "http_headers",
                "go_name": "HttpHeaders",
                "level": 4,
                "type": "[]string",
                "default": "",
                "comment": "HttpHeaders is a list of HTTP headers to proxy. No headers used by proxy by default.\nIf GRPC proxy is used then request HTTP headers set to outgoing request metadata.",
                "is_complex_type": false
              },
              {
                "field": "channel.proxy.publish.grpc_metadata",
                "name": "grpc_metadata",
                "go_name": "GrpcMetadata",
                "level": 4,
                "type": "[]string",
                "default": "",
                "comment": "GrpcMetadata is a list of GRPC metadata keys to proxy. No meta keys used by proxy by\ndefault. If HTTP proxy is used then these keys become outgoing request HTTP headers.",
                "is_complex_type": false
              },
              {
                "field": "channel.proxy.publish.binary_encoding",
                "name": "binary_encoding",
                "go_name": "BinaryEncoding",
                "level": 4,
                "type": "bool",
                "default": "",
                "comment": "BinaryEncoding makes proxy send data as base64 string (assuming it contains custom\nnon-JSON payload).",
                "is_complex_type": false
              },
              {
                "field": "channel.proxy.publish.include_connection_meta",
                "name": "include_connection_meta",
                "go_name": "IncludeConnectionMeta",
                "level": 4,
                "type": "bool",
                "default": "",
                "comment": "IncludeConnectionMeta to each proxy request (except connect proxy where it's obtained).",
                "is_complex_type": false
              },
              {
                "field": "channel.proxy.publish.http",
                "name": "http",
                "go_name": "HTTP",
                "level": 4,
                "type": "ProxyCommonHTTP",
                "default": "",
                "comment": "",
                "is_complex_type": true,
                "children": [
                  {
                    "field": "channel.proxy.publish.http.tls",
                    "name": "tls",
                    "go_name": "TLS",
                    "level": 5,
                    "type": "TLSConfig",
                    "default": "",
                    "comment": "TLS for HTTP client.",
                    "is_complex_type": true,
                    "children": [
                      {
                        "field": "channel.proxy.publish.http.tls.enabled",
                        "name": "enabled",
                        "go_name": "Enabled",
                        "level": 6,
                        "type": "bool",
                        "default": "",
                        "comment": "Enabled turns on using TLS.",
                        "is_complex_type": false
                      },
                      {
                        "field": "channel.proxy.publish.http.tls.cert_pem",
                        "name": "cert_pem",
                        "go_name": "CertPem",
                        "level": 6,
                        "type": "PEMData",
                        "default": "",
                        "comment": "CertPem is a PEM certificate.",
                        "is_complex_type": false
                      },
                      {
                        "field": "channel.proxy.publish.http.tls.key_pem",
                        "name": "key_pem",
                        "go_name": "KeyPem",
                        "level": 6,
                        "type": "PEMData",
                        "default": "",
                        "comment": "KeyPem is a path to a file with key in PEM format.",
                        "is_complex_type": false
                      },
                      {
                        "field": "channel.proxy.publish.http.tls.server_ca_pem",
                        "name": "server_ca_pem",
                        "go_name": "ServerCAPem",
                        "level": 6,
                        "type": "PEMData",
                        "default": "",
                        "comment": "ServerCAPem is a server root CA certificate in PEM format.\nThe client uses this certificate to verify the server's certificate during the TLS handshake.",
                        "is_complex_type": false
                      },
                      {
                        "field": "channel.proxy.publish.http.tls.client_ca_pem",
                        "name": "client_ca_pem",
                        "go_name": "ClientCAPem",
                        "level": 6,
                        "type": "PEMData",
                        "default": "",
                        "comment": "ClientCAPem is a client CA certificate in PEM format.\nThe server uses this certificate to verify the client's certificate during the TLS handshake.",
                        "is_complex_type": false
                      },
                      {
                        "field": "channel.proxy.publish.http.tls.insecure_skip_verify",
                        "name": "insecure_skip_verify",
                        "go_name": "InsecureSkipVerify",
                        "level": 6,
                        "type": "bool",
                        "default": "",
                        "comment": "InsecureSkipVerify turns off server certificate verification.",
                        "is_complex_type": false
                      },
                      {
                        "field": "channel.proxy.publish.http.tls.server_name",
                        "name": "server_name",
                        "go_name": "ServerName",
                        "level": 6,
                        "type": "string",
                        "default": "",
                        "comment": "ServerName is used to verify the hostname on the returned certificates.",
                        "is_complex_type": false
                      }
                    ]
                  },
                  {
                    "field": "channel.proxy.publish.http.static_headers",
                    "name": "static_headers",
                    "go_name": "StaticHeaders",
                    "level": 5,
                    "type": "MapStringString",
                    "default": "{}",
                    "comment": "StaticHeaders is a static set of key/value pairs to attach to HTTP proxy request as\nheaders. Headers received from HTTP client request or metadata from GRPC client request\nboth have priority over values set in StaticHttpHeaders map.",
                    "is_complex_type": false
                  },
                  {
                    "field": "channel.proxy.publish.http.status_to_code_transforms",
                    "name": "status_to_code_transforms",
                    "go_name": "StatusToCodeTransforms",
                    "level": 5,
                    "type": "[]HttpStatusToCodeTransform",
                    "default": "[]",
                    "comment": "StatusToCodeTransforms allow to map HTTP status codes from proxy to Disconnect or Error messages.",
                    "is_complex_type": true,
                    "children": [
                      {
                        "field": "channel.proxy.publish.http.status_to_code_transforms[].status_code",
                        "name": "status_code",
                        "go_name": "StatusCode",
                        "level": 6,
                        "type": "int",
                        "default": "",
                        "comment": "StatusCode is an HTTP status code to transform.",
                        "is_complex_type": false
                      },
                      {
                        "field": "channel.proxy.publish.http.status_to_code_transforms[].to_error",
                        "name": "to_error",
                        "go_name": "ToError",
                        "level": 6,
                        "type": "TransformError",
                        "default": "",
                        "comment": "ToError is a transform to protocol error.",
                        "is_complex_type": true,
                        "children": [
                          {
                            "field": "channel.proxy.publish.http.status_to_code_transforms[].to_error.code",
                            "name": "code",
                            "go_name": "Code",
                            "level": 7,
                            "type": "uint32",
                            "default": "",
                            "comment": "Code of error.",
                            "is_complex_type": false
                          },
                          {
                            "field": "channel.proxy.publish.http.status_to_code_transforms[].to_error.message",
                            "name": "message",
                            "go_name": "Message",
                            "level": 7,
                            "type": "string",
                            "default": "",
                            "comment": "Message is a human-readable message of error.",
                            "is_complex_type": false
                          },
                          {
                            "field": "channel.proxy.publish.http.status_to_code_transforms[].to_error.temporary",
                            "name": "temporary",
                            "go_name": "Temporary",
                            "level": 7,
                            "type": "bool",
                            "default": "",
                            "comment": "Temporary is a flag to mark error as temporary.",
                            "is_complex_type": false
                          }
                        ]
                      },
                      {
                        "field": "channel.proxy.publish.http.status_to_code_transforms[].to_disconnect",
                        "name": "to_disconnect",
                        "go_name": "ToDisconnect",
                        "level": 6,
                        "type": "TransformDisconnect",
                        "default": "",
                        "comment": "ToDisconnect is a transform to protocol disconnect.",
                        "is_complex_type": true,
                        "children": [
                          {
                            "field": "channel.proxy.publish.http.status_to_code_transforms[].to_disconnect.code",
                            "name": "code",
                            "go_name": "Code",
                            "level": 7,
                            "type": "uint32",
                            "default": "",
                            "comment": "Code of disconnect.",
                            "is_complex_type": false
                          },
                          {
                            "field": "channel.proxy.publish.http.status_to_code_transforms[].to_disconnect.reason",
                            "name": "reason",
                            "go_name": "Reason",
                            "level": 7,
                            "type": "string",
                            "default": "",
                            "comment": "Reason is a human-readable reason of disconnect.",
                            "is_complex_type": false
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "field": "channel.proxy.publish.grpc",
                "name": "grpc",
                "go_name": "GRPC",
                "level": 4,
                "type": "ProxyCommonGRPC",
                "default": "",
                "comment": "",
                "is_complex_type": true,
                "children": [
                  {
                    "field": "channel.proxy.publish.grpc.tls",
                    "name": "tls",
                    "go_name": "TLS",
                    "level": 5,
                    "type": "TLSConfig",
                    "default": "",
                    "comment": "TLS is a common configuration for GRPC client TLS.",
                    "is_complex_type": true,
                    "children": [
                      {
                        "field": "channel.proxy.publish.grpc.tls.enabled",
                        "name": "enabled",
                        "go_name": "Enabled",
                        "level": 6,
                        "type": "bool",
                        "default": "",
                        "comment": "Enabled turns on using TLS.",
                        "is_complex_type": false
                      },
                      {
                        "field": "channel.proxy.publish.grpc.tls.cert_pem",
                        "name": "cert_pem",
                        "go_name": "CertPem",
                        "level": 6,
                        "type": "PEMData",
                        "default": "",
                        "comment": "CertPem is a PEM certificate.",
                        "is_complex_type": false
                      },
                      {
                        "field": "channel.proxy.publish.grpc.tls.key_pem",
                        "name": "key_pem",
                        "go_name": "KeyPem",
                        "level": 6,
                        "type": "PEMData",
                        "default": "",
                        "comment": "KeyPem is a path to a file with key in PEM format.",
                        "is_complex_type": false
                      },
                      {
                        "field": "channel.proxy.publish.grpc.tls.server_ca_pem",
                        "name": "server_ca_pem",
                        "go_name": "ServerCAPem",
                        "level": 6,
                        "type": "PEMData",
                        "default": "",
                        "comment": "ServerCAPem is a server root CA certificate in PEM format.\nThe client uses this certificate to verify the server's certificate during the TLS handshake.",
                        "is_complex_type": false
                      },
                      {
                        "field": "channel.proxy.publish.grpc.tls.client_ca_pem",
                        "name": "client_ca_pem",
                        "go_name": "ClientCAPem",
                        "level": 6,
                        "type": "PEMData",
                        "default": "",
                        "comment": "ClientCAPem is a client CA certificate in PEM format.\nThe server uses this certificate to verify the client's certificate during the TLS handshake.",
                        "is_complex_type": false
                      },
                      {
                        "field": "channel.proxy.publish.grpc.tls.insecure_skip_verify",
                        "name": "insecure_skip_verify",
                        "go_name": "InsecureSkipVerify",
                        "level": 6,
                        "type": "bool",
                        "default": "",
                        "comment": "InsecureSkipVerify turns off server certificate verification.",
                        "is_complex_type": false
                      },
                      {
                        "field": "channel.proxy.publish.grpc.tls.server_name",
                        "name": "server_name",
                        "go_name": "ServerName",
                        "level": 6,
                        "type": "string",
                        "default": "",
                        "comment": "ServerName is used to verify the hostname on the returned certificates.",
                        "is_complex_type": false
                      }
                    ]
                  },
                  {
                    "field": "channel.proxy.publish.grpc.credentials_key",
                    "name": "credentials_key",
                    "go_name": "CredentialsKey",
                    "level": 5,
                    "type": "string",
                    "default": "",
                    "comment": "CredentialsKey is a custom key to add into per-RPC credentials.",
                    "is_complex_type": false
                  },
                  {
                    "field": "channel.proxy.publish.grpc.credentials_value",
                    "name": "credentials_value",
                    "go_name": "CredentialsValue",
                    "level": 5,
                    "type": "string",
                    "default": "",
                    "comment": "CredentialsValue is a custom value for GrpcCredentialsKey.",
                    "is_complex_type": false
                  },
                  {
                    "field": "channel.proxy.publish.grpc.compression",
                    "name": "compression",
                    "go_name": "Compression",
                    "level": 5,
                    "type": "bool",
                    "default": "",
                    "comment": "Compression enables compression for outgoing calls (gzip).",
                    "is_complex_type": false
                  }
                ]
              }
            ]
          },
          {
            "field": "channel.proxy.sub_refresh",
            "name": "sub_refresh",
            "go_name": "SubRefresh",
            "level": 3,
            "type": "Proxy",
            "default": "",
            "comment": "SubRefresh proxy configuration.",
            "is_complex_type": true,
            "children": [
              {
                "field": "channel.proxy.sub_refresh.endpoint",
                "name": "endpoint",
                "go_name": "Endpoint",
                "level": 4,
                "type": "string",
                "default": "",
                "comment": "Endpoint - HTTP address or GRPC service endpoint.",
                "is_complex_type": false
              },
              {
                "field": "channel.proxy.sub_refresh.timeout",
                "name": "timeout",
                "go_name": "Timeout",
                "level": 4,
                "type": "Duration",
                "default": "1s",
                "comment": "Timeout for proxy request.",
                "is_complex_type": false
              },
              {
                "field": "channel.proxy.sub_refresh.http_headers",
                "name": "http_headers",
                "go_name": "HttpHeaders",
                "level": 4,
                "type": "[]string",
                "default": "",
                "comment": "HttpHeaders is a list of HTTP headers to proxy. No headers used by proxy by default.\nIf GRPC proxy is used then request HTTP headers set to outgoing request metadata.",
                "is_complex_type": false
              },
              {
                "field": "channel.proxy.sub_refresh.grpc_metadata",
                "name": "grpc_metadata",
                "go_name": "GrpcMetadata",
                "level": 4,
                "type": "[]string",
                "default": "",
                "comment": "GrpcMetadata is a list of GRPC metadata keys to proxy. No meta keys used by proxy by\ndefault. If HTTP proxy is used then these keys become outgoing request HTTP headers.",
                "is_complex_type": false
              },
              {
                "field": "channel.proxy.sub_refresh.binary_encoding",
                "name": "binary_encoding",
                "go_name": "BinaryEncoding",
                "level": 4,
                "type": "bool",
                "default": "",
                "comment": "BinaryEncoding makes proxy send data as base64 string (assuming it contains custom\nnon-JSON payload).",
                "is_complex_type": false
              },
              {
                "field": "channel.proxy.sub_refresh.include_connection_meta",
                "name": "include_connection_meta",
                "go_name": "IncludeConnectionMeta",
                "level": 4,
                "type": "bool",
                "default": "",
                "comment": "IncludeConnectionMeta to each proxy request (except connect proxy where it's obtained).",
                "is_complex_type": false
              },
              {
                "field": "channel.proxy.sub_refresh.http",
                "name": "http",
                "go_name": "HTTP",
                "level": 4,
                "type": "ProxyCommonHTTP",
                "default": "",
                "comment": "",
                "is_complex_type": true,
                "children": [
                  {
                    "field": "channel.proxy.sub_refresh.http.tls",
                    "name": "tls",
                    "go_name": "TLS",
                    "level": 5,
                    "type": "TLSConfig",
                    "default": "",
                    "comment": "TLS for HTTP client.",
                    "is_complex_type": true,
                    "children": [
                      {
                        "field": "channel.proxy.sub_refresh.http.tls.enabled",
                        "name": "enabled",
                        "go_name": "Enabled",
                        "level": 6,
                        "type": "bool",
                        "default": "",
                        "comment": "Enabled turns on using TLS.",
                        "is_complex_type": false
                      },
                      {
                        "field": "channel.proxy.sub_refresh.http.tls.cert_pem",
                        "name": "cert_pem",
                        "go_name": "CertPem",
                        "level": 6,
                        "type": "PEMData",
                        "default": "",
                        "comment": "CertPem is a PEM certificate.",
                        "is_complex_type": false
                      },
                      {
                        "field": "channel.proxy.sub_refresh.http.tls.key_pem",
                        "name": "key_pem",
                        "go_name": "KeyPem",
                        "level": 6,
                        "type": "PEMData",
                        "default": "",
                        "comment": "KeyPem is a path to a file with key in PEM format.",
                        "is_complex_type": false
                      },
                      {
                        "field": "channel.proxy.sub_refresh.http.tls.server_ca_pem",
                        "name": "server_ca_pem",
                        "go_name": "ServerCAPem",
                        "level": 6,
                        "type": "PEMData",
                        "default": "",
                        "comment": "ServerCAPem is a server root CA certificate in PEM format.\nThe client uses this certificate to verify the server's certificate during the TLS handshake.",
                        "is_complex_type": false
                      },
                      {
                        "field": "channel.proxy.sub_refresh.http.tls.client_ca_pem",
                        "name": "client_ca_pem",
                        "go_name": "ClientCAPem",
                        "level": 6,
                        "type": "PEMData",
                        "default": "",
                        "comment": "ClientCAPem is a client CA certificate in PEM format.\nThe server uses this certificate to verify the client's certificate during the TLS handshake.",
                        "is_complex_type": false
                      },
                      {
                        "field": "channel.proxy.sub_refresh.http.tls.insecure_skip_verify",
                        "name": "insecure_skip_verify",
                        "go_name": "InsecureSkipVerify",
                        "level": 6,
                        "type": "bool",
                        "default": "",
                        "comment": "InsecureSkipVerify turns off server certificate verification.",
                        "is_complex_type": false
                      },
                      {
                        "field": "channel.proxy.sub_refresh.http.tls.server_name",
                        "name": "server_name",
                        "go_name": "ServerName",
                        "level": 6,
                        "type": "string",
                        "default": "",
                        "comment": "ServerName is used to verify the hostname on the returned certificates.",
                        "is_complex_type": false
                      }
                    ]
                  },
                  {
                    "field": "channel.proxy.sub_refresh.http.static_headers",
                    "name": "static_headers",
                    "go_name": "StaticHeaders",
                    "level": 5,
                    "type": "MapStringString",
                    "default": "{}",
                    "comment": "StaticHeaders is a static set of key/value pairs to attach to HTTP proxy request as\nheaders. Headers received from HTTP client request or metadata from GRPC client request\nboth have priority over values set in StaticHttpHeaders map.",
                    "is_complex_type": false
                  },
                  {
                    "field": "channel.proxy.sub_refresh.http.status_to_code_transforms",
                    "name": "status_to_code_transforms",
                    "go_name": "StatusToCodeTransforms",
                    "level": 5,
                    "type": "[]HttpStatusToCodeTransform",
                    "default": "[]",
                    "comment": "StatusToCodeTransforms allow to map HTTP status codes from proxy to Disconnect or Error messages.",
                    "is_complex_type": true,
                    "children": [
                      {
                        "field": "channel.proxy.sub_refresh.http.status_to_code_transforms[].status_code",
                        "name": "status_code",
                        "go_name": "StatusCode",
                        "level": 6,
                        "type": "int",
                        "default": "",
                        "comment": "StatusCode is an HTTP status code to transform.",
                        "is_complex_type": false
                      },
                      {
                        "field": "channel.proxy.sub_refresh.http.status_to_code_transforms[].to_error",
                        "name": "to_error",
                        "go_name": "ToError",
                        "level": 6,
                        "type": "TransformError",
                        "default": "",
                        "comment": "ToError is a transform to protocol error.",
                        "is_complex_type": true,
                        "children": [
                          {
                            "field": "channel.proxy.sub_refresh.http.status_to_code_transforms[].to_error.code",
                            "name": "code",
                            "go_name": "Code",
                            "level": 7,
                            "type": "uint32",
                            "default": "",
                            "comment": "Code of error.",
                            "is_complex_type": false
                          },
                          {
                            "field": "channel.proxy.sub_refresh.http.status_to_code_transforms[].to_error.message",
                            "name": "message",
                            "go_name": "Message",
                            "level": 7,
                            "type": "string",
                            "default": "",
                            "comment": "Message is a human-readable message of error.",
                            "is_complex_type": false
                          },
                          {
                            "field": "channel.proxy.sub_refresh.http.status_to_code_transforms[].to_error.temporary",
                            "name": "temporary",
                            "go_name": "Temporary",
                            "level": 7,
                            "type": "bool",
                            "default": "",
                            "comment": "Temporary is a flag to mark error as temporary.",
                            "is_complex_type": false
                          }
                        ]
                      },
                      {
                        "field": "channel.proxy.sub_refresh.http.status_to_code_transforms[].to_disconnect",
                        "name": "to_disconnect",
                        "go_name": "ToDisconnect",
                        "level": 6,
                        "type": "TransformDisconnect",
                        "default": "",
                        "comment": "ToDisconnect is a transform to protocol disconnect.",
                        "is_complex_type": true,
                        "children": [
                          {
                            "field": "channel.proxy.sub_refresh.http.status_to_code_transforms[].to_disconnect.code",
                            "name": "code",
                            "go_name": "Code",
                            "level": 7,
                            "type": "uint32",
                            "default": "",
                            "comment": "Code of disconnect.",
                            "is_complex_type": false
                          },
                          {
                            "field": "channel.proxy.sub_refresh.http.status_to_code_transforms[].to_disconnect.reason",
                            "name": "reason",
                            "go_name": "Reason",
                            "level": 7,
                            "type": "string",
                            "default": "",
                            "comment": "Reason is a human-readable reason of disconnect.",
                            "is_complex_type": false
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "field": "channel.proxy.sub_refresh.grpc",
                "name": "grpc",
                "go_name": "GRPC",
                "level": 4,
                "type": "ProxyCommonGRPC",
                "default": "",
                "comment": "",
                "is_complex_type": true,
                "children": [
                  {
                    "field": "channel.proxy.sub_refresh.grpc.tls",
                    "name": "tls",
                    "go_name": "TLS",
                    "level": 5,
                    "type": "TLSConfig",
                    "default": "",
                    "comment": "TLS is a common configuration for GRPC client TLS.",
                    "is_complex_type": true,
                    "children": [
                      {
                        "field": "channel.proxy.sub_refresh.grpc.tls.enabled",
                        "name": "enabled",
                        "go_name": "Enabled",
                        "level": 6,
                        "type": "bool",
                        "default": "",
                        "comment": "Enabled turns on using TLS.",
                        "is_complex_type": false
                      },
                      {
                        "field": "channel.proxy.sub_refresh.grpc.tls.cert_pem",
                        "name": "cert_pem",
                        "go_name": "CertPem",
                        "level": 6,
                        "type": "PEMData",
                        "default": "",
                        "comment": "CertPem is a PEM certificate.",
                        "is_complex_type": false
                      },
                      {
                        "field": "channel.proxy.sub_refresh.grpc.tls.key_pem",
                        "name": "key_pem",
                        "go_name": "KeyPem",
                        "level": 6,
                        "type": "PEMData",
                        "default": "",
                        "comment": "KeyPem is a path to a file with key in PEM format.",
                        "is_complex_type": false
                      },
                      {
                        "field": "channel.proxy.sub_refresh.grpc.tls.server_ca_pem",
                        "name": "server_ca_pem",
                        "go_name": "ServerCAPem",
                        "level": 6,
                        "type": "PEMData",
                        "default": "",
                        "comment": "ServerCAPem is a server root CA certificate in PEM format.\nThe client uses this certificate to verify the server's certificate during the TLS handshake.",
                        "is_complex_type": false
                      },
                      {
                        "field": "channel.proxy.sub_refresh.grpc.tls.client_ca_pem",
                        "name": "client_ca_pem",
                        "go_name": "ClientCAPem",
                        "level": 6,
                        "type": "PEMData",
                        "default": "",
                        "comment": "ClientCAPem is a client CA certificate in PEM format.\nThe server uses this certificate to verify the client's certificate during the TLS handshake.",
                        "is_complex_type": false
                      },
                      {
                        "field": "channel.proxy.sub_refresh.grpc.tls.insecure_skip_verify",
                        "name": "insecure_skip_verify",
                        "go_name": "InsecureSkipVerify",
                        "level": 6,
                        "type": "bool",
                        "default": "",
                        "comment": "InsecureSkipVerify turns off server certificate verification.",
                        "is_complex_type": false
                      },
                      {
                        "field": "channel.proxy.sub_refresh.grpc.tls.server_name",
                        "name": "server_name",
                        "go_name": "ServerName",
                        "level": 6,
                        "type": "string",
                        "default": "",
                        "comment": "ServerName is used to verify the hostname on the returned certificates.",
                        "is_complex_type": false
                      }
                    ]
                  },
                  {
                    "field": "channel.proxy.sub_refresh.grpc.credentials_key",
                    "name": "credentials_key",
                    "go_name": "CredentialsKey",
                    "level": 5,
                    "type": "string",
                    "default": "",
                    "comment": "CredentialsKey is a custom key to add into per-RPC credentials.",
                    "is_complex_type": false
                  },
                  {
                    "field": "channel.proxy.sub_refresh.grpc.credentials_value",
                    "name": "credentials_value",
                    "go_name": "CredentialsValue",
                    "level": 5,
                    "type": "string",
                    "default": "",
                    "comment": "CredentialsValue is a custom value for GrpcCredentialsKey.",
                    "is_complex_type": false
                  },
                  {
                    "field": "channel.proxy.sub_refresh.grpc.compression",
                    "name": "compression",
                    "go_name": "Compression",
                    "level": 5,
                    "type": "bool",
                    "default": "",
                    "comment": "Compression enables compression for outgoing calls (gzip).",
                    "is_complex_type": false
                  }
                ]
              }
            ]
          },
          {
            "field": "channel.proxy.subscribe_stream",
            "name": "subscribe_stream",
            "go_name": "SubscribeStream",
            "level": 3,
            "type": "Proxy",
            "default": "",
            "comment": "SubscribeStream proxy configuration.",
            "is_complex_type": true,
            "children": [
              {
                "field": "channel.proxy.subscribe_stream.endpoint",
                "name": "endpoint",
                "go_name": "Endpoint",
                "level": 4,
                "type": "string",
                "default": "",
                "comment": "Endpoint - HTTP address or GRPC service endpoint.",
                "is_complex_type": false
              },
              {
                "field": "channel.proxy.subscribe_stream.timeout",
                "name": "timeout",
                "go_name": "Timeout",
                "level": 4,
                "type": "Duration",
                "default": "1s",
                "comment": "Timeout for proxy request.",
                "is_complex_type": false
              },
              {
                "field": "channel.proxy.subscribe_stream.http_headers",
                "name": "http_headers",
                "go_name": "HttpHeaders",
                "level": 4,
                "type": "[]string",
                "default": "",
                "comment": "HttpHeaders is a list of HTTP headers to proxy. No headers used by proxy by default.\nIf GRPC proxy is used then request HTTP headers set to outgoing request metadata.",
                "is_complex_type": false
              },
              {
                "field": "channel.proxy.subscribe_stream.grpc_metadata",
                "name": "grpc_metadata",
                "go_name": "GrpcMetadata",
                "level": 4,
                "type": "[]string",
                "default": "",
                "comment": "GrpcMetadata is a list of GRPC metadata keys to proxy. No meta keys used by proxy by\ndefault. If HTTP proxy is used then these keys become outgoing request HTTP headers.",
                "is_complex_type": false
              },
              {
                "field": "channel.proxy.subscribe_stream.binary_encoding",
                "name": "binary_encoding",
                "go_name": "BinaryEncoding",
                "level": 4,
                "type": "bool",
                "default": "",
                "comment": "BinaryEncoding makes proxy send data as base64 string (assuming it contains custom\nnon-JSON payload).",
                "is_complex_type": false
              },
              {
                "field": "channel.proxy.subscribe_stream.include_connection_meta",
                "name": "include_connection_meta",
                "go_name": "IncludeConnectionMeta",
                "level": 4,
                "type": "bool",
                "default": "",
                "comment": "IncludeConnectionMeta to each proxy request (except connect proxy where it's obtained).",
                "is_complex_type": false
              },
              {
                "field": "channel.proxy.subscribe_stream.http",
                "name": "http",
                "go_name": "HTTP",
                "level": 4,
                "type": "ProxyCommonHTTP",
                "default": "",
                "comment": "",
                "is_complex_type": true,
                "children": [
                  {
                    "field": "channel.proxy.subscribe_stream.http.tls",
                    "name": "tls",
                    "go_name": "TLS",
                    "level": 5,
                    "type": "TLSConfig",
                    "default": "",
                    "comment": "TLS for HTTP client.",
                    "is_complex_type": true,
                    "children": [
                      {
                        "field": "channel.proxy.subscribe_stream.http.tls.enabled",
                        "name": "enabled",
                        "go_name": "Enabled",
                        "level": 6,
                        "type": "bool",
                        "default": "",
                        "comment": "Enabled turns on using TLS.",
                        "is_complex_type": false
                      },
                      {
                        "field": "channel.proxy.subscribe_stream.http.tls.cert_pem",
                        "name": "cert_pem",
                        "go_name": "CertPem",
                        "level": 6,
                        "type": "PEMData",
                        "default": "",
                        "comment": "CertPem is a PEM certificate.",
                        "is_complex_type": false
                      },
                      {
                        "field": "channel.proxy.subscribe_stream.http.tls.key_pem",
                        "name": "key_pem",
                        "go_name": "KeyPem",
                        "level": 6,
                        "type": "PEMData",
                        "default": "",
                        "comment": "KeyPem is a path to a file with key in PEM format.",
                        "is_complex_type": false
                      },
                      {
                        "field": "channel.proxy.subscribe_stream.http.tls.server_ca_pem",
                        "name": "server_ca_pem",
                        "go_name": "ServerCAPem",
                        "level": 6,
                        "type": "PEMData",
                        "default": "",
                        "comment": "ServerCAPem is a server root CA certificate in PEM format.\nThe client uses this certificate to verify the server's certificate during the TLS handshake.",
                        "is_complex_type": false
                      },
                      {
                        "field": "channel.proxy.subscribe_stream.http.tls.client_ca_pem",
                        "name": "client_ca_pem",
                        "go_name": "ClientCAPem",
                        "level": 6,
                        "type": "PEMData",
                        "default": "",
                        "comment": "ClientCAPem is a client CA certificate in PEM format.\nThe server uses this certificate to verify the client's certificate during the TLS handshake.",
                        "is_complex_type": false
                      },
                      {
                        "field": "channel.proxy.subscribe_stream.http.tls.insecure_skip_verify",
                        "name": "insecure_skip_verify",
                        "go_name": "InsecureSkipVerify",
                        "level": 6,
                        "type": "bool",
                        "default": "",
                        "comment": "InsecureSkipVerify turns off server certificate verification.",
                        "is_complex_type": false
                      },
                      {
                        "field": "channel.proxy.subscribe_stream.http.tls.server_name",
                        "name": "server_name",
                        "go_name": "ServerName",
                        "level": 6,
                        "type": "string",
                        "default": "",
                        "comment": "ServerName is used to verify the hostname on the returned certificates.",
                        "is_complex_type": false
                      }
                    ]
                  },
                  {
                    "field": "channel.proxy.subscribe_stream.http.static_headers",
                    "name": "static_headers",
                    "go_name": "StaticHeaders",
                    "level": 5,
                    "type": "MapStringString",
                    "default": "{}",
                    "comment": "StaticHeaders is a static set of key/value pairs to attach to HTTP proxy request as\nheaders. Headers received from HTTP client request or metadata from GRPC client request\nboth have priority over values set in StaticHttpHeaders map.",
                    "is_complex_type": false
                  },
                  {
                    "field": "channel.proxy.subscribe_stream.http.status_to_code_transforms",
                    "name": "status_to_code_transforms",
                    "go_name": "StatusToCodeTransforms",
                    "level": 5,
                    "type": "[]HttpStatusToCodeTransform",
                    "default": "[]",
                    "comment": "StatusToCodeTransforms allow to map HTTP status codes from proxy to Disconnect or Error messages.",
                    "is_complex_type": true,
                    "children": [
                      {
                        "field": "channel.proxy.subscribe_stream.http.status_to_code_transforms[].status_code",
                        "name": "status_code",
                        "go_name": "StatusCode",
                        "level": 6,
                        "type": "int",
                        "default": "",
                        "comment": "StatusCode is an HTTP status code to transform.",
                        "is_complex_type": false
                      },
                      {
                        "field": "channel.proxy.subscribe_stream.http.status_to_code_transforms[].to_error",
                        "name": "to_error",
                        "go_name": "ToError",
                        "level": 6,
                        "type": "TransformError",
                        "default": "",
                        "comment": "ToError is a transform to protocol error.",
                        "is_complex_type": true,
                        "children": [
                          {
                            "field": "channel.proxy.subscribe_stream.http.status_to_code_transforms[].to_error.code",
                            "name": "code",
                            "go_name": "Code",
                            "level": 7,
                            "type": "uint32",
                            "default": "",
                            "comment": "Code of error.",
                            "is_complex_type": false
                          },
                          {
                            "field": "channel.proxy.subscribe_stream.http.status_to_code_transforms[].to_error.message",
                            "name": "message",
                            "go_name": "Message",
                            "level": 7,
                            "type": "string",
                            "default": "",
                            "comment": "Message is a human-readable message of error.",
                            "is_complex_type": false
                          },
                          {
                            "field": "channel.proxy.subscribe_stream.http.status_to_code_transforms[].to_error.temporary",
                            "name": "temporary",
                            "go_name": "Temporary",
                            "level": 7,
                            "type": "bool",
                            "default": "",
                            "comment": "Temporary is a flag to mark error as temporary.",
                            "is_complex_type": false
                          }
                        ]
                      },
                      {
                        "field": "channel.proxy.subscribe_stream.http.status_to_code_transforms[].to_disconnect",
                        "name": "to_disconnect",
                        "go_name": "ToDisconnect",
                        "level": 6,
                        "type": "TransformDisconnect",
                        "default": "",
                        "comment": "ToDisconnect is a transform to protocol disconnect.",
                        "is_complex_type": true,
                        "children": [
                          {
                            "field": "channel.proxy.subscribe_stream.http.status_to_code_transforms[].to_disconnect.code",
                            "name": "code",
                            "go_name": "Code",
                            "level": 7,
                            "type": "uint32",
                            "default": "",
                            "comment": "Code of disconnect.",
                            "is_complex_type": false
                          },
                          {
                            "field": "channel.proxy.subscribe_stream.http.status_to_code_transforms[].to_disconnect.reason",
                            "name": "reason",
                            "go_name": "Reason",
                            "level": 7,
                            "type": "string",
                            "default": "",
                            "comment": "Reason is a human-readable reason of disconnect.",
                            "is_complex_type": false
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "field": "channel.proxy.subscribe_stream.grpc",
                "name": "grpc",
                "go_name": "GRPC",
                "level": 4,
                "type": "ProxyCommonGRPC",
                "default": "",
                "comment": "",
                "is_complex_type": true,
                "children": [
                  {
                    "field": "channel.proxy.subscribe_stream.grpc.tls",
                    "name": "tls",
                    "go_name": "TLS",
                    "level": 5,
                    "type": "TLSConfig",
                    "default": "",
                    "comment": "TLS is a common configuration for GRPC client TLS.",
                    "is_complex_type": true,
                    "children": [
                      {
                        "field": "channel.proxy.subscribe_stream.grpc.tls.enabled",
                        "name": "enabled",
                        "go_name": "Enabled",
                        "level": 6,
                        "type": "bool",
                        "default": "",
                        "comment": "Enabled turns on using TLS.",
                        "is_complex_type": false
                      },
                      {
                        "field": "channel.proxy.subscribe_stream.grpc.tls.cert_pem",
                        "name": "cert_pem",
                        "go_name": "CertPem",
                        "level": 6,
                        "type": "PEMData",
                        "default": "",
                        "comment": "CertPem is a PEM certificate.",
                        "is_complex_type": false
                      },
                      {
                        "field": "channel.proxy.subscribe_stream.grpc.tls.key_pem",
                        "name": "key_pem",
                        "go_name": "KeyPem",
                        "level": 6,
                        "type": "PEMData",
                        "default": "",
                        "comment": "KeyPem is a path to a file with key in PEM format.",
                        "is_complex_type": false
                      },
                      {
                        "field": "channel.proxy.subscribe_stream.grpc.tls.server_ca_pem",
                        "name": "server_ca_pem",
                        "go_name": "ServerCAPem",
                        "level": 6,
                        "type": "PEMData",
                        "default": "",
                        "comment": "ServerCAPem is a server root CA certificate in PEM format.\nThe client uses this certificate to verify the server's certificate during the TLS handshake.",
                        "is_complex_type": false
                      },
                      {
                        "field": "channel.proxy.subscribe_stream.grpc.tls.client_ca_pem",
                        "name": "client_ca_pem",
                        "go_name": "ClientCAPem",
                        "level": 6,
                        "type": "PEMData",
                        "default": "",
                        "comment": "ClientCAPem is a client CA certificate in PEM format.\nThe server uses this certificate to verify the client's certificate during the TLS handshake.",
                        "is_complex_type": false
                      },
                      {
                        "field": "channel.proxy.subscribe_stream.grpc.tls.insecure_skip_verify",
                        "name": "insecure_skip_verify",
                        "go_name": "InsecureSkipVerify",
                        "level": 6,
                        "type": "bool",
                        "default": "",
                        "comment": "InsecureSkipVerify turns off server certificate verification.",
                        "is_complex_type": false
                      },
                      {
                        "field": "channel.proxy.subscribe_stream.grpc.tls.server_name",
                        "name": "server_name",
                        "go_name": "ServerName",
                        "level": 6,
                        "type": "string",
                        "default": "",
                        "comment": "ServerName is used to verify the hostname on the returned certificates.",
                        "is_complex_type": false
                      }
                    ]
                  },
                  {
                    "field": "channel.proxy.subscribe_stream.grpc.credentials_key",
                    "name": "credentials_key",
                    "go_name": "CredentialsKey",
                    "level": 5,
                    "type": "string",
                    "default": "",
                    "comment": "CredentialsKey is a custom key to add into per-RPC credentials.",
                    "is_complex_type": false
                  },
                  {
                    "field": "channel.proxy.subscribe_stream.grpc.credentials_value",
                    "name": "credentials_value",
                    "go_name": "CredentialsValue",
                    "level": 5,
                    "type": "string",
                    "default": "",
                    "comment": "CredentialsValue is a custom value for GrpcCredentialsKey.",
                    "is_complex_type": false
                  },
                  {
                    "field": "channel.proxy.subscribe_stream.grpc.compression",
                    "name": "compression",
                    "go_name": "Compression",
                    "level": 5,
                    "type": "bool",
                    "default": "",
                    "comment": "Compression enables compression for outgoing calls (gzip).",
                    "is_complex_type": false
                  }
                ]
              }
            ]
          }
        ]
      },
      {
        "field": "channel.without_namespace",
        "name": "without_namespace",
        "go_name": "WithoutNamespace",
        "level": 2,
        "type": "ChannelOptions",
        "default": "",
        "comment": "WithoutNamespace is a configuration of channels options for channels which do not have namespace.\nGenerally, we recommend always use channel namespaces but this option can be useful for simple setups.",
        "is_complex_type": true,
        "children": [
          {
            "field": "channel.without_namespace.presence",
            "name": "presence",
            "go_name": "Presence",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "Presence turns on presence information for channel. Presence has\ninformation about all clients currently subscribed to a channel.",
            "is_complex_type": false
          },
          {
            "field": "channel.without_namespace.join_leave",
            "name": "join_leave",
            "go_name": "JoinLeave",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "JoinLeave turns on join/leave messages for a channel.\nWhen client subscribes on a channel join message sent to all\nsubscribers in this channel (including current client). When client\nleaves channel (unsubscribes) leave message sent. This option does\nnot fit well for channels with many subscribers because every\nsubscribe/unsubscribe event results into join/leave event broadcast\nto all other active subscribers thus overloads server with tons of\nmessages. Use accurately for channels with small number of active\nsubscribers.",
            "is_complex_type": false
          },
          {
            "field": "channel.without_namespace.force_push_join_leave",
            "name": "force_push_join_leave",
            "go_name": "ForcePushJoinLeave",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "ForcePushJoinLeave forces sending join/leave messages towards subscribers.",
            "is_complex_type": false
          },
          {
            "field": "channel.without_namespace.history_size",
            "name": "history_size",
            "go_name": "HistorySize",
            "level": 3,
            "type": "int",
            "default": "",
            "comment": "HistorySize determines max amount of history messages for a channel,\nZero value means no history for channel. Centrifuge history has an\nauxiliary role with current Engines – it can not replace your backend\npersistent storage.",
            "is_complex_type": false
          },
          {
            "field": "channel.without_namespace.history_ttl",
            "name": "history_ttl",
            "go_name": "HistoryTTL",
            "level": 3,
            "type": "Duration",
            "default": "",
            "comment": "HistoryTTL is a time to live for history cache. Server maintains a window of\nmessages in memory (or in Redis with Redis engine), to prevent infinite memory\ngrows it's important to remove history for inactive channels.",
            "is_complex_type": false
          },
          {
            "field": "channel.without_namespace.history_meta_ttl",
            "name": "history_meta_ttl",
            "go_name": "HistoryMetaTTL",
            "level": 3,
            "type": "Duration",
            "default": "",
            "comment": "HistoryMetaTTL is a time to live for history stream meta information. Must be\nmuch larger than HistoryTTL in common scenario. If zero, then we use global value\nset over default_history_meta_ttl on configuration top level.",
            "is_complex_type": false
          },
          {
            "field": "channel.without_namespace.force_positioning",
            "name": "force_positioning",
            "go_name": "ForcePositioning",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "ForcePositioning enables client positioning. This means that StreamPosition\nwill be exposed to the client and server will look that no messages from\nPUB/SUB layer lost. In the loss found – client is disconnected (or unsubscribed)\nwith reconnect (resubscribe) code.",
            "is_complex_type": false
          },
          {
            "field": "channel.without_namespace.allow_positioning",
            "name": "allow_positioning",
            "go_name": "AllowPositioning",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "AllowPositioning allows positioning when client asks about it.",
            "is_complex_type": false
          },
          {
            "field": "channel.without_namespace.force_recovery",
            "name": "force_recovery",
            "go_name": "ForceRecovery",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "ForceRecovery enables recovery mechanism for channels. This means that\nserver will try to recover missed messages for resubscribing client.\nThis option uses publications from history and must be used with reasonable\nHistorySize and HistoryTTL configuration.",
            "is_complex_type": false
          },
          {
            "field": "channel.without_namespace.allow_recovery",
            "name": "allow_recovery",
            "go_name": "AllowRecovery",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "AllowRecovery allows recovery when client asks about it.",
            "is_complex_type": false
          },
          {
            "field": "channel.without_namespace.force_recovery_mode",
            "name": "force_recovery_mode",
            "go_name": "ForceRecoveryMode",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "ForceRecoveryMode can set the recovery mode for all channel subscribers in the namespace which use recovery.",
            "is_complex_type": false
          },
          {
            "field": "channel.without_namespace.allowed_delta_types",
            "name": "allowed_delta_types",
            "go_name": "AllowedDeltaTypes",
            "level": 3,
            "type": "[]centrifuge.DeltaType",
            "default": "",
            "comment": "AllowedDeltaTypes is non-empty contains slice of allowed delta types for subscribers to use.",
            "is_complex_type": false
          },
          {
            "field": "channel.without_namespace.delta_publish",
            "name": "delta_publish",
            "go_name": "DeltaPublish",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "DeltaPublish enables delta publish mechanism for all messages published in namespace channels\nwithout explicit flag usage in publish API request. Setting this option does not guarantee that\npublication will be compressed when going towards subscribers – it still depends on subscriber\nconnection options and whether Centrifugo Node is able to find previous publication in channel.",
            "is_complex_type": false
          },
          {
            "field": "channel.without_namespace.allow_subscribe_for_anonymous",
            "name": "allow_subscribe_for_anonymous",
            "go_name": "SubscribeForAnonymous",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "SubscribeForAnonymous allows anonymous clients to subscribe on channels in namespace.",
            "is_complex_type": false
          },
          {
            "field": "channel.without_namespace.allow_subscribe_for_client",
            "name": "allow_subscribe_for_client",
            "go_name": "SubscribeForClient",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "SubscribeForClient allows authenticated clients to subscribe on channels in namespace.",
            "is_complex_type": false
          },
          {
            "field": "channel.without_namespace.allow_publish_for_anonymous",
            "name": "allow_publish_for_anonymous",
            "go_name": "PublishForAnonymous",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "PublishForAnonymous allows anonymous clients to publish messages into channels in namespace.",
            "is_complex_type": false
          },
          {
            "field": "channel.without_namespace.allow_publish_for_subscriber",
            "name": "allow_publish_for_subscriber",
            "go_name": "PublishForSubscriber",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "PublishForSubscriber allows clients subscribed on channel to publish messages into it.",
            "is_complex_type": false
          },
          {
            "field": "channel.without_namespace.allow_publish_for_client",
            "name": "allow_publish_for_client",
            "go_name": "PublishForClient",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "PublishForClient allows authenticated clients to publish messages into channels in namespace.",
            "is_complex_type": false
          },
          {
            "field": "channel.without_namespace.allow_presence_for_anonymous",
            "name": "allow_presence_for_anonymous",
            "go_name": "PresenceForAnonymous",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "PresenceForAnonymous allows anonymous clients to get presence information for channels in namespace.",
            "is_complex_type": false
          },
          {
            "field": "channel.without_namespace.allow_presence_for_subscriber",
            "name": "allow_presence_for_subscriber",
            "go_name": "PresenceForSubscriber",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "PresenceForSubscriber allows clients subscribed on channel to get presence information for it.",
            "is_complex_type": false
          },
          {
            "field": "channel.without_namespace.allow_presence_for_client",
            "name": "allow_presence_for_client",
            "go_name": "PresenceForClient",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "PresenceForClient allows authenticated clients to get presence information for channels in namespace.",
            "is_complex_type": false
          },
          {
            "field": "channel.without_namespace.allow_history_for_anonymous",
            "name": "allow_history_for_anonymous",
            "go_name": "HistoryForAnonymous",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "HistoryForAnonymous allows anonymous clients to get history information for channels in namespace.",
            "is_complex_type": false
          },
          {
            "field": "channel.without_namespace.allow_history_for_subscriber",
            "name": "allow_history_for_subscriber",
            "go_name": "HistoryForSubscriber",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "HistoryForSubscriber allows clients subscribed on channel to get history information for it.",
            "is_complex_type": false
          },
          {
            "field": "channel.without_namespace.allow_history_for_client",
            "name": "allow_history_for_client",
            "go_name": "HistoryForClient",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "HistoryForClient allows authenticated clients to get history information for channels in namespace.",
            "is_complex_type": false
          },
          {
            "field": "channel.without_namespace.allow_user_limited_channels",
            "name": "allow_user_limited_channels",
            "go_name": "UserLimitedChannels",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "UserLimitedChannels allows to limit number of channels user can subscribe to in namespace.",
            "is_complex_type": false
          },
          {
            "field": "channel.without_namespace.channel_regex",
            "name": "channel_regex",
            "go_name": "ChannelRegex",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "ChannelRegex sets a regular expression to check channel name against.",
            "is_complex_type": false
          },
          {
            "field": "channel.without_namespace.subscribe_proxy_enabled",
            "name": "subscribe_proxy_enabled",
            "go_name": "SubscribeProxyEnabled",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "SubscribeProxyEnabled turns on using proxy for subscribe operations in namespace.",
            "is_complex_type": false
          },
          {
            "field": "channel.without_namespace.subscribe_proxy_name",
            "name": "subscribe_proxy_name",
            "go_name": "SubscribeProxyName",
            "level": 3,
            "type": "string",
            "default": "default",
            "comment": "SubscribeProxyName of proxy to use for subscribe operations in namespace.",
            "is_complex_type": false
          },
          {
            "field": "channel.without_namespace.publish_proxy_enabled",
            "name": "publish_proxy_enabled",
            "go_name": "PublishProxyEnabled",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "PublishProxyEnabled turns on using proxy for publish operations in namespace.",
            "is_complex_type": false
          },
          {
            "field": "channel.without_namespace.publish_proxy_name",
            "name": "publish_proxy_name",
            "go_name": "PublishProxyName",
            "level": 3,
            "type": "string",
            "default": "default",
            "comment": "PublishProxyName of proxy to use for publish operations in namespace.",
            "is_complex_type": false
          },
          {
            "field": "channel.without_namespace.sub_refresh_proxy_enabled",
            "name": "sub_refresh_proxy_enabled",
            "go_name": "SubRefreshProxyEnabled",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "SubRefreshProxyEnabled turns on using proxy for sub refresh operations in namespace.",
            "is_complex_type": false
          },
          {
            "field": "channel.without_namespace.sub_refresh_proxy_name",
            "name": "sub_refresh_proxy_name",
            "go_name": "SubRefreshProxyName",
            "level": 3,
            "type": "string",
            "default": "default",
            "comment": "SubRefreshProxyName of proxy to use for sub refresh operations in namespace.",
            "is_complex_type": false
          },
          {
            "field": "channel.without_namespace.subscribe_stream_proxy_enabled",
            "name": "subscribe_stream_proxy_enabled",
            "go_name": "SubscribeStreamProxyEnabled",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "SubscribeStreamProxyEnabled turns on using proxy for subscribe stream operations in namespace.",
            "is_complex_type": false
          },
          {
            "field": "channel.without_namespace.subscribe_stream_proxy_name",
            "name": "subscribe_stream_proxy_name",
            "go_name": "SubscribeStreamProxyName",
            "level": 3,
            "type": "string",
            "default": "default",
            "comment": "SubscribeStreamProxyName of proxy to use for subscribe stream operations in namespace.",
            "is_complex_type": false
          },
          {
            "field": "channel.without_namespace.subscribe_stream_proxy_bidirectional",
            "name": "subscribe_stream_proxy_bidirectional",
            "go_name": "SubscribeStreamBidirectional",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "SubscribeStreamBidirectional enables using bidirectional stream proxy for the namespace.",
            "is_complex_type": false
          }
        ]
      },
      {
        "field": "channel.namespaces",
        "name": "namespaces",
        "go_name": "Namespaces",
        "level": 2,
        "type": "[]ChannelNamespace",
        "default": "[]",
        "comment": "Namespaces is a list of channel namespaces. Each channel namespace can have its own set of rules.",
        "is_complex_type": true,
        "children": [
          {
            "field": "channel.namespaces[].name",
            "name": "name",
            "go_name": "Name",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "Name is a unique namespace name.",
            "is_complex_type": false
          },
          {
            "field": "channel.namespaces[].presence",
            "name": "presence",
            "go_name": "Presence",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "Presence turns on presence information for channel. Presence has\ninformation about all clients currently subscribed to a channel.",
            "is_complex_type": false
          },
          {
            "field": "channel.namespaces[].join_leave",
            "name": "join_leave",
            "go_name": "JoinLeave",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "JoinLeave turns on join/leave messages for a channel.\nWhen client subscribes on a channel join message sent to all\nsubscribers in this channel (including current client). When client\nleaves channel (unsubscribes) leave message sent. This option does\nnot fit well for channels with many subscribers because every\nsubscribe/unsubscribe event results into join/leave event broadcast\nto all other active subscribers thus overloads server with tons of\nmessages. Use accurately for channels with small number of active\nsubscribers.",
            "is_complex_type": false
          },
          {
            "field": "channel.namespaces[].force_push_join_leave",
            "name": "force_push_join_leave",
            "go_name": "ForcePushJoinLeave",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "ForcePushJoinLeave forces sending join/leave messages towards subscribers.",
            "is_complex_type": false
          },
          {
            "field": "channel.namespaces[].history_size",
            "name": "history_size",
            "go_name": "HistorySize",
            "level": 3,
            "type": "int",
            "default": "",
            "comment": "HistorySize determines max amount of history messages for a channel,\nZero value means no history for channel. Centrifuge history has an\nauxiliary role with current Engines – it can not replace your backend\npersistent storage.",
            "is_complex_type": false
          },
          {
            "field": "channel.namespaces[].history_ttl",
            "name": "history_ttl",
            "go_name": "HistoryTTL",
            "level": 3,
            "type": "Duration",
            "default": "",
            "comment": "HistoryTTL is a time to live for history cache. Server maintains a window of\nmessages in memory (or in Redis with Redis engine), to prevent infinite memory\ngrows it's important to remove history for inactive channels.",
            "is_complex_type": false
          },
          {
            "field": "channel.namespaces[].history_meta_ttl",
            "name": "history_meta_ttl",
            "go_name": "HistoryMetaTTL",
            "level": 3,
            "type": "Duration",
            "default": "",
            "comment": "HistoryMetaTTL is a time to live for history stream meta information. Must be\nmuch larger than HistoryTTL in common scenario. If zero, then we use global value\nset over default_history_meta_ttl on configuration top level.",
            "is_complex_type": false
          },
          {
            "field": "channel.namespaces[].force_positioning",
            "name": "force_positioning",
            "go_name": "ForcePositioning",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "ForcePositioning enables client positioning. This means that StreamPosition\nwill be exposed to the client and server will look that no messages from\nPUB/SUB layer lost. In the loss found – client is disconnected (or unsubscribed)\nwith reconnect (resubscribe) code.",
            "is_complex_type": false
          },
          {
            "field": "channel.namespaces[].allow_positioning",
            "name": "allow_positioning",
            "go_name": "AllowPositioning",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "AllowPositioning allows positioning when client asks about it.",
            "is_complex_type": false
          },
          {
            "field": "channel.namespaces[].force_recovery",
            "name": "force_recovery",
            "go_name": "ForceRecovery",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "ForceRecovery enables recovery mechanism for channels. This means that\nserver will try to recover missed messages for resubscribing client.\nThis option uses publications from history and must be used with reasonable\nHistorySize and HistoryTTL configuration.",
            "is_complex_type": false
          },
          {
            "field": "channel.namespaces[].allow_recovery",
            "name": "allow_recovery",
            "go_name": "AllowRecovery",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "AllowRecovery allows recovery when client asks about it.",
            "is_complex_type": false
          },
          {
            "field": "channel.namespaces[].force_recovery_mode",
            "name": "force_recovery_mode",
            "go_name": "ForceRecoveryMode",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "ForceRecoveryMode can set the recovery mode for all channel subscribers in the namespace which use recovery.",
            "is_complex_type": false
          },
          {
            "field": "channel.namespaces[].allowed_delta_types",
            "name": "allowed_delta_types",
            "go_name": "AllowedDeltaTypes",
            "level": 3,
            "type": "[]centrifuge.DeltaType",
            "default": "",
            "comment": "AllowedDeltaTypes is non-empty contains slice of allowed delta types for subscribers to use.",
            "is_complex_type": false
          },
          {
            "field": "channel.namespaces[].delta_publish",
            "name": "delta_publish",
            "go_name": "DeltaPublish",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "DeltaPublish enables delta publish mechanism for all messages published in namespace channels\nwithout explicit flag usage in publish API request. Setting this option does not guarantee that\npublication will be compressed when going towards subscribers – it still depends on subscriber\nconnection options and whether Centrifugo Node is able to find previous publication in channel.",
            "is_complex_type": false
          },
          {
            "field": "channel.namespaces[].allow_subscribe_for_anonymous",
            "name": "allow_subscribe_for_anonymous",
            "go_name": "SubscribeForAnonymous",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "SubscribeForAnonymous allows anonymous clients to subscribe on channels in namespace.",
            "is_complex_type": false
          },
          {
            "field": "channel.namespaces[].allow_subscribe_for_client",
            "name": "allow_subscribe_for_client",
            "go_name": "SubscribeForClient",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "SubscribeForClient allows authenticated clients to subscribe on channels in namespace.",
            "is_complex_type": false
          },
          {
            "field": "channel.namespaces[].allow_publish_for_anonymous",
            "name": "allow_publish_for_anonymous",
            "go_name": "PublishForAnonymous",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "PublishForAnonymous allows anonymous clients to publish messages into channels in namespace.",
            "is_complex_type": false
          },
          {
            "field": "channel.namespaces[].allow_publish_for_subscriber",
            "name": "allow_publish_for_subscriber",
            "go_name": "PublishForSubscriber",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "PublishForSubscriber allows clients subscribed on channel to publish messages into it.",
            "is_complex_type": false
          },
          {
            "field": "channel.namespaces[].allow_publish_for_client",
            "name": "allow_publish_for_client",
            "go_name": "PublishForClient",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "PublishForClient allows authenticated clients to publish messages into channels in namespace.",
            "is_complex_type": false
          },
          {
            "field": "channel.namespaces[].allow_presence_for_anonymous",
            "name": "allow_presence_for_anonymous",
            "go_name": "PresenceForAnonymous",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "PresenceForAnonymous allows anonymous clients to get presence information for channels in namespace.",
            "is_complex_type": false
          },
          {
            "field": "channel.namespaces[].allow_presence_for_subscriber",
            "name": "allow_presence_for_subscriber",
            "go_name": "PresenceForSubscriber",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "PresenceForSubscriber allows clients subscribed on channel to get presence information for it.",
            "is_complex_type": false
          },
          {
            "field": "channel.namespaces[].allow_presence_for_client",
            "name": "allow_presence_for_client",
            "go_name": "PresenceForClient",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "PresenceForClient allows authenticated clients to get presence information for channels in namespace.",
            "is_complex_type": false
          },
          {
            "field": "channel.namespaces[].allow_history_for_anonymous",
            "name": "allow_history_for_anonymous",
            "go_name": "HistoryForAnonymous",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "HistoryForAnonymous allows anonymous clients to get history information for channels in namespace.",
            "is_complex_type": false
          },
          {
            "field": "channel.namespaces[].allow_history_for_subscriber",
            "name": "allow_history_for_subscriber",
            "go_name": "HistoryForSubscriber",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "HistoryForSubscriber allows clients subscribed on channel to get history information for it.",
            "is_complex_type": false
          },
          {
            "field": "channel.namespaces[].allow_history_for_client",
            "name": "allow_history_for_client",
            "go_name": "HistoryForClient",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "HistoryForClient allows authenticated clients to get history information for channels in namespace.",
            "is_complex_type": false
          },
          {
            "field": "channel.namespaces[].allow_user_limited_channels",
            "name": "allow_user_limited_channels",
            "go_name": "UserLimitedChannels",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "UserLimitedChannels allows to limit number of channels user can subscribe to in namespace.",
            "is_complex_type": false
          },
          {
            "field": "channel.namespaces[].channel_regex",
            "name": "channel_regex",
            "go_name": "ChannelRegex",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "ChannelRegex sets a regular expression to check channel name against.",
            "is_complex_type": false
          },
          {
            "field": "channel.namespaces[].subscribe_proxy_enabled",
            "name": "subscribe_proxy_enabled",
            "go_name": "SubscribeProxyEnabled",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "SubscribeProxyEnabled turns on using proxy for subscribe operations in namespace.",
            "is_complex_type": false
          },
          {
            "field": "channel.namespaces[].subscribe_proxy_name",
            "name": "subscribe_proxy_name",
            "go_name": "SubscribeProxyName",
            "level": 3,
            "type": "string",
            "default": "default",
            "comment": "SubscribeProxyName of proxy to use for subscribe operations in namespace.",
            "is_complex_type": false
          },
          {
            "field": "channel.namespaces[].publish_proxy_enabled",
            "name": "publish_proxy_enabled",
            "go_name": "PublishProxyEnabled",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "PublishProxyEnabled turns on using proxy for publish operations in namespace.",
            "is_complex_type": false
          },
          {
            "field": "channel.namespaces[].publish_proxy_name",
            "name": "publish_proxy_name",
            "go_name": "PublishProxyName",
            "level": 3,
            "type": "string",
            "default": "default",
            "comment": "PublishProxyName of proxy to use for publish operations in namespace.",
            "is_complex_type": false
          },
          {
            "field": "channel.namespaces[].sub_refresh_proxy_enabled",
            "name": "sub_refresh_proxy_enabled",
            "go_name": "SubRefreshProxyEnabled",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "SubRefreshProxyEnabled turns on using proxy for sub refresh operations in namespace.",
            "is_complex_type": false
          },
          {
            "field": "channel.namespaces[].sub_refresh_proxy_name",
            "name": "sub_refresh_proxy_name",
            "go_name": "SubRefreshProxyName",
            "level": 3,
            "type": "string",
            "default": "default",
            "comment": "SubRefreshProxyName of proxy to use for sub refresh operations in namespace.",
            "is_complex_type": false
          },
          {
            "field": "channel.namespaces[].subscribe_stream_proxy_enabled",
            "name": "subscribe_stream_proxy_enabled",
            "go_name": "SubscribeStreamProxyEnabled",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "SubscribeStreamProxyEnabled turns on using proxy for subscribe stream operations in namespace.",
            "is_complex_type": false
          },
          {
            "field": "channel.namespaces[].subscribe_stream_proxy_name",
            "name": "subscribe_stream_proxy_name",
            "go_name": "SubscribeStreamProxyName",
            "level": 3,
            "type": "string",
            "default": "default",
            "comment": "SubscribeStreamProxyName of proxy to use for subscribe stream operations in namespace.",
            "is_complex_type": false
          },
          {
            "field": "channel.namespaces[].subscribe_stream_proxy_bidirectional",
            "name": "subscribe_stream_proxy_bidirectional",
            "go_name": "SubscribeStreamBidirectional",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "SubscribeStreamBidirectional enables using bidirectional stream proxy for the namespace.",
            "is_complex_type": false
          }
        ]
      },
      {
        "field": "channel.history_meta_ttl",
        "name": "history_meta_ttl",
        "go_name": "HistoryMetaTTL",
        "level": 2,
        "type": "Duration",
        "default": "720h",
        "comment": "HistoryMetaTTL is a time how long to keep history meta information. This is a global option for all channels,\nbut it can be overridden in channel namespace.",
        "is_complex_type": false
      },
      {
        "field": "channel.max_length",
        "name": "max_length",
        "go_name": "MaxLength",
        "level": 2,
        "type": "int",
        "default": "255",
        "comment": "MaxLength is a maximum length of a channel name. This is a global option for all channels.",
        "is_complex_type": false
      },
      {
        "field": "channel.private_prefix",
        "name": "private_prefix",
        "go_name": "PrivatePrefix",
        "level": 2,
        "type": "string",
        "default": "$",
        "comment": "PrivatePrefix is a prefix for private channels. Private channels can't be subscribed without\ntoken even if namespace options allows it. This is mostly kept for historic reasons.",
        "is_complex_type": false
      },
      {
        "field": "channel.namespace_boundary",
        "name": "namespace_boundary",
        "go_name": "NamespaceBoundary",
        "level": 2,
        "type": "string",
        "default": ":",
        "comment": "NamespaceBoundary defines a boundary for channel namespaces.",
        "is_complex_type": false
      },
      {
        "field": "channel.user_boundary",
        "name": "user_boundary",
        "go_name": "UserBoundary",
        "level": 2,
        "type": "string",
        "default": "#",
        "comment": "UserBoundary defines a boundary for user part in channel name.",
        "is_complex_type": false
      },
      {
        "field": "channel.user_separator",
        "name": "user_separator",
        "go_name": "UserSeparator",
        "level": 2,
        "type": "string",
        "default": ",",
        "comment": "UserSeparator is used for passing several users in user part of channel name.",
        "is_complex_type": false
      }
    ]
  },
  {
    "field": "rpc",
    "name": "rpc",
    "go_name": "RPC",
    "level": 1,
    "type": "RPC",
    "default": "",
    "comment": "RPC is a configuration for client RPC calls.",
    "is_complex_type": true,
    "children": [
      {
        "field": "rpc.proxy",
        "name": "proxy",
        "go_name": "Proxy",
        "level": 2,
        "type": "Proxy",
        "default": "",
        "comment": "Proxy configuration for rpc-related events. Can be referenced by the name \"default\".",
        "is_complex_type": true,
        "children": [
          {
            "field": "rpc.proxy.endpoint",
            "name": "endpoint",
            "go_name": "Endpoint",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "Endpoint - HTTP address or GRPC service endpoint.",
            "is_complex_type": false
          },
          {
            "field": "rpc.proxy.timeout",
            "name": "timeout",
            "go_name": "Timeout",
            "level": 3,
            "type": "Duration",
            "default": "1s",
            "comment": "Timeout for proxy request.",
            "is_complex_type": false
          },
          {
            "field": "rpc.proxy.http_headers",
            "name": "http_headers",
            "go_name": "HttpHeaders",
            "level": 3,
            "type": "[]string",
            "default": "",
            "comment": "HttpHeaders is a list of HTTP headers to proxy. No headers used by proxy by default.\nIf GRPC proxy is used then request HTTP headers set to outgoing request metadata.",
            "is_complex_type": false
          },
          {
            "field": "rpc.proxy.grpc_metadata",
            "name": "grpc_metadata",
            "go_name": "GrpcMetadata",
            "level": 3,
            "type": "[]string",
            "default": "",
            "comment": "GrpcMetadata is a list of GRPC metadata keys to proxy. No meta keys used by proxy by\ndefault. If HTTP proxy is used then these keys become outgoing request HTTP headers.",
            "is_complex_type": false
          },
          {
            "field": "rpc.proxy.binary_encoding",
            "name": "binary_encoding",
            "go_name": "BinaryEncoding",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "BinaryEncoding makes proxy send data as base64 string (assuming it contains custom\nnon-JSON payload).",
            "is_complex_type": false
          },
          {
            "field": "rpc.proxy.include_connection_meta",
            "name": "include_connection_meta",
            "go_name": "IncludeConnectionMeta",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "IncludeConnectionMeta to each proxy request (except connect proxy where it's obtained).",
            "is_complex_type": false
          },
          {
            "field": "rpc.proxy.http",
            "name": "http",
            "go_name": "HTTP",
            "level": 3,
            "type": "ProxyCommonHTTP",
            "default": "",
            "comment": "",
            "is_complex_type": true,
            "children": [
              {
                "field": "rpc.proxy.http.tls",
                "name": "tls",
                "go_name": "TLS",
                "level": 4,
                "type": "TLSConfig",
                "default": "",
                "comment": "TLS for HTTP client.",
                "is_complex_type": true,
                "children": [
                  {
                    "field": "rpc.proxy.http.tls.enabled",
                    "name": "enabled",
                    "go_name": "Enabled",
                    "level": 5,
                    "type": "bool",
                    "default": "",
                    "comment": "Enabled turns on using TLS.",
                    "is_complex_type": false
                  },
                  {
                    "field": "rpc.proxy.http.tls.cert_pem",
                    "name": "cert_pem",
                    "go_name": "CertPem",
                    "level": 5,
                    "type": "PEMData",
                    "default": "",
                    "comment": "CertPem is a PEM certificate.",
                    "is_complex_type": false
                  },
                  {
                    "field": "rpc.proxy.http.tls.key_pem",
                    "name": "key_pem",
                    "go_name": "KeyPem",
                    "level": 5,
                    "type": "PEMData",
                    "default": "",
                    "comment": "KeyPem is a path to a file with key in PEM format.",
                    "is_complex_type": false
                  },
                  {
                    "field": "rpc.proxy.http.tls.server_ca_pem",
                    "name": "server_ca_pem",
                    "go_name": "ServerCAPem",
                    "level": 5,
                    "type": "PEMData",
                    "default": "",
                    "comment": "ServerCAPem is a server root CA certificate in PEM format.\nThe client uses this certificate to verify the server's certificate during the TLS handshake.",
                    "is_complex_type": false
                  },
                  {
                    "field": "rpc.proxy.http.tls.client_ca_pem",
                    "name": "client_ca_pem",
                    "go_name": "ClientCAPem",
                    "level": 5,
                    "type": "PEMData",
                    "default": "",
                    "comment": "ClientCAPem is a client CA certificate in PEM format.\nThe server uses this certificate to verify the client's certificate during the TLS handshake.",
                    "is_complex_type": false
                  },
                  {
                    "field": "rpc.proxy.http.tls.insecure_skip_verify",
                    "name": "insecure_skip_verify",
                    "go_name": "InsecureSkipVerify",
                    "level": 5,
                    "type": "bool",
                    "default": "",
                    "comment": "InsecureSkipVerify turns off server certificate verification.",
                    "is_complex_type": false
                  },
                  {
                    "field": "rpc.proxy.http.tls.server_name",
                    "name": "server_name",
                    "go_name": "ServerName",
                    "level": 5,
                    "type": "string",
                    "default": "",
                    "comment": "ServerName is used to verify the hostname on the returned certificates.",
                    "is_complex_type": false
                  }
                ]
              },
              {
                "field": "rpc.proxy.http.static_headers",
                "name": "static_headers",
                "go_name": "StaticHeaders",
                "level": 4,
                "type": "MapStringString",
                "default": "{}",
                "comment": "StaticHeaders is a static set of key/value pairs to attach to HTTP proxy request as\nheaders. Headers received from HTTP client request or metadata from GRPC client request\nboth have priority over values set in StaticHttpHeaders map.",
                "is_complex_type": false
              },
              {
                "field": "rpc.proxy.http.status_to_code_transforms",
                "name": "status_to_code_transforms",
                "go_name": "StatusToCodeTransforms",
                "level": 4,
                "type": "[]HttpStatusToCodeTransform",
                "default": "[]",
                "comment": "StatusToCodeTransforms allow to map HTTP status codes from proxy to Disconnect or Error messages.",
                "is_complex_type": true,
                "children": [
                  {
                    "field": "rpc.proxy.http.status_to_code_transforms[].status_code",
                    "name": "status_code",
                    "go_name": "StatusCode",
                    "level": 5,
                    "type": "int",
                    "default": "",
                    "comment": "StatusCode is an HTTP status code to transform.",
                    "is_complex_type": false
                  },
                  {
                    "field": "rpc.proxy.http.status_to_code_transforms[].to_error",
                    "name": "to_error",
                    "go_name": "ToError",
                    "level": 5,
                    "type": "TransformError",
                    "default": "",
                    "comment": "ToError is a transform to protocol error.",
                    "is_complex_type": true,
                    "children": [
                      {
                        "field": "rpc.proxy.http.status_to_code_transforms[].to_error.code",
                        "name": "code",
                        "go_name": "Code",
                        "level": 6,
                        "type": "uint32",
                        "default": "",
                        "comment": "Code of error.",
                        "is_complex_type": false
                      },
                      {
                        "field": "rpc.proxy.http.status_to_code_transforms[].to_error.message",
                        "name": "message",
                        "go_name": "Message",
                        "level": 6,
                        "type": "string",
                        "default": "",
                        "comment": "Message is a human-readable message of error.",
                        "is_complex_type": false
                      },
                      {
                        "field": "rpc.proxy.http.status_to_code_transforms[].to_error.temporary",
                        "name": "temporary",
                        "go_name": "Temporary",
                        "level": 6,
                        "type": "bool",
                        "default": "",
                        "comment": "Temporary is a flag to mark error as temporary.",
                        "is_complex_type": false
                      }
                    ]
                  },
                  {
                    "field": "rpc.proxy.http.status_to_code_transforms[].to_disconnect",
                    "name": "to_disconnect",
                    "go_name": "ToDisconnect",
                    "level": 5,
                    "type": "TransformDisconnect",
                    "default": "",
                    "comment": "ToDisconnect is a transform to protocol disconnect.",
                    "is_complex_type": true,
                    "children": [
                      {
                        "field": "rpc.proxy.http.status_to_code_transforms[].to_disconnect.code",
                        "name": "code",
                        "go_name": "Code",
                        "level": 6,
                        "type": "uint32",
                        "default": "",
                        "comment": "Code of disconnect.",
                        "is_complex_type": false
                      },
                      {
                        "field": "rpc.proxy.http.status_to_code_transforms[].to_disconnect.reason",
                        "name": "reason",
                        "go_name": "Reason",
                        "level": 6,
                        "type": "string",
                        "default": "",
                        "comment": "Reason is a human-readable reason of disconnect.",
                        "is_complex_type": false
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "field": "rpc.proxy.grpc",
            "name": "grpc",
            "go_name": "GRPC",
            "level": 3,
            "type": "ProxyCommonGRPC",
            "default": "",
            "comment": "",
            "is_complex_type": true,
            "children": [
              {
                "field": "rpc.proxy.grpc.tls",
                "name": "tls",
                "go_name": "TLS",
                "level": 4,
                "type": "TLSConfig",
                "default": "",
                "comment": "TLS is a common configuration for GRPC client TLS.",
                "is_complex_type": true,
                "children": [
                  {
                    "field": "rpc.proxy.grpc.tls.enabled",
                    "name": "enabled",
                    "go_name": "Enabled",
                    "level": 5,
                    "type": "bool",
                    "default": "",
                    "comment": "Enabled turns on using TLS.",
                    "is_complex_type": false
                  },
                  {
                    "field": "rpc.proxy.grpc.tls.cert_pem",
                    "name": "cert_pem",
                    "go_name": "CertPem",
                    "level": 5,
                    "type": "PEMData",
                    "default": "",
                    "comment": "CertPem is a PEM certificate.",
                    "is_complex_type": false
                  },
                  {
                    "field": "rpc.proxy.grpc.tls.key_pem",
                    "name": "key_pem",
                    "go_name": "KeyPem",
                    "level": 5,
                    "type": "PEMData",
                    "default": "",
                    "comment": "KeyPem is a path to a file with key in PEM format.",
                    "is_complex_type": false
                  },
                  {
                    "field": "rpc.proxy.grpc.tls.server_ca_pem",
                    "name": "server_ca_pem",
                    "go_name": "ServerCAPem",
                    "level": 5,
                    "type": "PEMData",
                    "default": "",
                    "comment": "ServerCAPem is a server root CA certificate in PEM format.\nThe client uses this certificate to verify the server's certificate during the TLS handshake.",
                    "is_complex_type": false
                  },
                  {
                    "field": "rpc.proxy.grpc.tls.client_ca_pem",
                    "name": "client_ca_pem",
                    "go_name": "ClientCAPem",
                    "level": 5,
                    "type": "PEMData",
                    "default": "",
                    "comment": "ClientCAPem is a client CA certificate in PEM format.\nThe server uses this certificate to verify the client's certificate during the TLS handshake.",
                    "is_complex_type": false
                  },
                  {
                    "field": "rpc.proxy.grpc.tls.insecure_skip_verify",
                    "name": "insecure_skip_verify",
                    "go_name": "InsecureSkipVerify",
                    "level": 5,
                    "type": "bool",
                    "default": "",
                    "comment": "InsecureSkipVerify turns off server certificate verification.",
                    "is_complex_type": false
                  },
                  {
                    "field": "rpc.proxy.grpc.tls.server_name",
                    "name": "server_name",
                    "go_name": "ServerName",
                    "level": 5,
                    "type": "string",
                    "default": "",
                    "comment": "ServerName is used to verify the hostname on the returned certificates.",
                    "is_complex_type": false
                  }
                ]
              },
              {
                "field": "rpc.proxy.grpc.credentials_key",
                "name": "credentials_key",
                "go_name": "CredentialsKey",
                "level": 4,
                "type": "string",
                "default": "",
                "comment": "CredentialsKey is a custom key to add into per-RPC credentials.",
                "is_complex_type": false
              },
              {
                "field": "rpc.proxy.grpc.credentials_value",
                "name": "credentials_value",
                "go_name": "CredentialsValue",
                "level": 4,
                "type": "string",
                "default": "",
                "comment": "CredentialsValue is a custom value for GrpcCredentialsKey.",
                "is_complex_type": false
              },
              {
                "field": "rpc.proxy.grpc.compression",
                "name": "compression",
                "go_name": "Compression",
                "level": 4,
                "type": "bool",
                "default": "",
                "comment": "Compression enables compression for outgoing calls (gzip).",
                "is_complex_type": false
              }
            ]
          }
        ]
      },
      {
        "field": "rpc.without_namespace",
        "name": "without_namespace",
        "go_name": "WithoutNamespace",
        "level": 2,
        "type": "RpcOptions",
        "default": "",
        "comment": "WithoutNamespace is a configuration of RpcOptions for rpc methods without rpc namespace. Generally,\nwe recommend always use rpc namespaces but this option can be useful for simple setups.",
        "is_complex_type": true,
        "children": [
          {
            "field": "rpc.without_namespace.proxy_enabled",
            "name": "proxy_enabled",
            "go_name": "ProxyEnabled",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "ProxyEnabled allows to enable using RPC proxy for this namespace.",
            "is_complex_type": false
          },
          {
            "field": "rpc.without_namespace.proxy_name",
            "name": "proxy_name",
            "go_name": "ProxyName",
            "level": 3,
            "type": "string",
            "default": "default",
            "comment": "ProxyName which should be used for RPC namespace.",
            "is_complex_type": false
          }
        ]
      },
      {
        "field": "rpc.namespaces",
        "name": "namespaces",
        "go_name": "Namespaces",
        "level": 2,
        "type": "[]RpcNamespace",
        "default": "[]",
        "comment": "RPCNamespaces is a list of rpc namespaces. Each rpc namespace can have its own set of rules.",
        "is_complex_type": true,
        "children": [
          {
            "field": "rpc.namespaces[].name",
            "name": "name",
            "go_name": "Name",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "Name is a unique rpc namespace name.",
            "is_complex_type": false
          },
          {
            "field": "rpc.namespaces[].proxy_enabled",
            "name": "proxy_enabled",
            "go_name": "ProxyEnabled",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "ProxyEnabled allows to enable using RPC proxy for this namespace.",
            "is_complex_type": false
          },
          {
            "field": "rpc.namespaces[].proxy_name",
            "name": "proxy_name",
            "go_name": "ProxyName",
            "level": 3,
            "type": "string",
            "default": "default",
            "comment": "ProxyName which should be used for RPC namespace.",
            "is_complex_type": false
          }
        ]
      },
      {
        "field": "rpc.ping",
        "name": "ping",
        "go_name": "Ping",
        "level": 2,
        "type": "RPCPing",
        "default": "",
        "comment": "Ping is a configuration for RPC ping method.",
        "is_complex_type": true,
        "children": [
          {
            "field": "rpc.ping.enabled",
            "name": "enabled",
            "go_name": "Enabled",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "Enabled allows to enable ping method.",
            "is_complex_type": false
          },
          {
            "field": "rpc.ping.method",
            "name": "method",
            "go_name": "Method",
            "level": 3,
            "type": "string",
            "default": "ping",
            "comment": "Method can be used to override the name of ping method to use.",
            "is_complex_type": false
          }
        ]
      },
      {
        "field": "rpc.namespace_boundary",
        "name": "namespace_boundary",
        "go_name": "NamespaceBoundary",
        "level": 2,
        "type": "string",
        "default": ":",
        "comment": "NamespaceBoundary allows to set a custom boundary for rpc namespaces.",
        "is_complex_type": false
      }
    ]
  },
  {
    "field": "proxies",
    "name": "proxies",
    "go_name": "Proxies",
    "level": 1,
    "type": "[]NamedProxy",
    "default": "[]",
    "comment": "Proxies is an array of proxies with custom names for the more granular control of channel-related events\nin different channel namespaces.",
    "is_complex_type": true,
    "children": [
      {
        "field": "proxies[].name",
        "name": "name",
        "go_name": "Name",
        "level": 2,
        "type": "string",
        "default": "",
        "comment": "Name of proxy.",
        "is_complex_type": false
      },
      {
        "field": "proxies[].endpoint",
        "name": "endpoint",
        "go_name": "Endpoint",
        "level": 2,
        "type": "string",
        "default": "",
        "comment": "Endpoint - HTTP address or GRPC service endpoint.",
        "is_complex_type": false
      },
      {
        "field": "proxies[].timeout",
        "name": "timeout",
        "go_name": "Timeout",
        "level": 2,
        "type": "Duration",
        "default": "1s",
        "comment": "Timeout for proxy request.",
        "is_complex_type": false
      },
      {
        "field": "proxies[].http_headers",
        "name": "http_headers",
        "go_name": "HttpHeaders",
        "level": 2,
        "type": "[]string",
        "default": "",
        "comment": "HttpHeaders is a list of HTTP headers to proxy. No headers used by proxy by default.\nIf GRPC proxy is used then request HTTP headers set to outgoing request metadata.",
        "is_complex_type": false
      },
      {
        "field": "proxies[].grpc_metadata",
        "name": "grpc_metadata",
        "go_name": "GrpcMetadata",
        "level": 2,
        "type": "[]string",
        "default": "",
        "comment": "GrpcMetadata is a list of GRPC metadata keys to proxy. No meta keys used by proxy by\ndefault. If HTTP proxy is used then these keys become outgoing request HTTP headers.",
        "is_complex_type": false
      },
      {
        "field": "proxies[].binary_encoding",
        "name": "binary_encoding",
        "go_name": "BinaryEncoding",
        "level": 2,
        "type": "bool",
        "default": "",
        "comment": "BinaryEncoding makes proxy send data as base64 string (assuming it contains custom\nnon-JSON payload).",
        "is_complex_type": false
      },
      {
        "field": "proxies[].include_connection_meta",
        "name": "include_connection_meta",
        "go_name": "IncludeConnectionMeta",
        "level": 2,
        "type": "bool",
        "default": "",
        "comment": "IncludeConnectionMeta to each proxy request (except connect proxy where it's obtained).",
        "is_complex_type": false
      },
      {
        "field": "proxies[].http",
        "name": "http",
        "go_name": "HTTP",
        "level": 2,
        "type": "ProxyCommonHTTP",
        "default": "",
        "comment": "",
        "is_complex_type": true,
        "children": [
          {
            "field": "proxies[].http.tls",
            "name": "tls",
            "go_name": "TLS",
            "level": 3,
            "type": "TLSConfig",
            "default": "",
            "comment": "TLS for HTTP client.",
            "is_complex_type": true,
            "children": [
              {
                "field": "proxies[].http.tls.enabled",
                "name": "enabled",
                "go_name": "Enabled",
                "level": 4,
                "type": "bool",
                "default": "",
                "comment": "Enabled turns on using TLS.",
                "is_complex_type": false
              },
              {
                "field": "proxies[].http.tls.cert_pem",
                "name": "cert_pem",
                "go_name": "CertPem",
                "level": 4,
                "type": "PEMData",
                "default": "",
                "comment": "CertPem is a PEM certificate.",
                "is_complex_type": false
              },
              {
                "field": "proxies[].http.tls.key_pem",
                "name": "key_pem",
                "go_name": "KeyPem",
                "level": 4,
                "type": "PEMData",
                "default": "",
                "comment": "KeyPem is a path to a file with key in PEM format.",
                "is_complex_type": false
              },
              {
                "field": "proxies[].http.tls.server_ca_pem",
                "name": "server_ca_pem",
                "go_name": "ServerCAPem",
                "level": 4,
                "type": "PEMData",
                "default": "",
                "comment": "ServerCAPem is a server root CA certificate in PEM format.\nThe client uses this certificate to verify the server's certificate during the TLS handshake.",
                "is_complex_type": false
              },
              {
                "field": "proxies[].http.tls.client_ca_pem",
                "name": "client_ca_pem",
                "go_name": "ClientCAPem",
                "level": 4,
                "type": "PEMData",
                "default": "",
                "comment": "ClientCAPem is a client CA certificate in PEM format.\nThe server uses this certificate to verify the client's certificate during the TLS handshake.",
                "is_complex_type": false
              },
              {
                "field": "proxies[].http.tls.insecure_skip_verify",
                "name": "insecure_skip_verify",
                "go_name": "InsecureSkipVerify",
                "level": 4,
                "type": "bool",
                "default": "",
                "comment": "InsecureSkipVerify turns off server certificate verification.",
                "is_complex_type": false
              },
              {
                "field": "proxies[].http.tls.server_name",
                "name": "server_name",
                "go_name": "ServerName",
                "level": 4,
                "type": "string",
                "default": "",
                "comment": "ServerName is used to verify the hostname on the returned certificates.",
                "is_complex_type": false
              }
            ]
          },
          {
            "field": "proxies[].http.static_headers",
            "name": "static_headers",
            "go_name": "StaticHeaders",
            "level": 3,
            "type": "MapStringString",
            "default": "{}",
            "comment": "StaticHeaders is a static set of key/value pairs to attach to HTTP proxy request as\nheaders. Headers received from HTTP client request or metadata from GRPC client request\nboth have priority over values set in StaticHttpHeaders map.",
            "is_complex_type": false
          },
          {
            "field": "proxies[].http.status_to_code_transforms",
            "name": "status_to_code_transforms",
            "go_name": "StatusToCodeTransforms",
            "level": 3,
            "type": "[]HttpStatusToCodeTransform",
            "default": "[]",
            "comment": "StatusToCodeTransforms allow to map HTTP status codes from proxy to Disconnect or Error messages.",
            "is_complex_type": true,
            "children": [
              {
                "field": "proxies[].http.status_to_code_transforms[].status_code",
                "name": "status_code",
                "go_name": "StatusCode",
                "level": 4,
                "type": "int",
                "default": "",
                "comment": "StatusCode is an HTTP status code to transform.",
                "is_complex_type": false
              },
              {
                "field": "proxies[].http.status_to_code_transforms[].to_error",
                "name": "to_error",
                "go_name": "ToError",
                "level": 4,
                "type": "TransformError",
                "default": "",
                "comment": "ToError is a transform to protocol error.",
                "is_complex_type": true,
                "children": [
                  {
                    "field": "proxies[].http.status_to_code_transforms[].to_error.code",
                    "name": "code",
                    "go_name": "Code",
                    "level": 5,
                    "type": "uint32",
                    "default": "",
                    "comment": "Code of error.",
                    "is_complex_type": false
                  },
                  {
                    "field": "proxies[].http.status_to_code_transforms[].to_error.message",
                    "name": "message",
                    "go_name": "Message",
                    "level": 5,
                    "type": "string",
                    "default": "",
                    "comment": "Message is a human-readable message of error.",
                    "is_complex_type": false
                  },
                  {
                    "field": "proxies[].http.status_to_code_transforms[].to_error.temporary",
                    "name": "temporary",
                    "go_name": "Temporary",
                    "level": 5,
                    "type": "bool",
                    "default": "",
                    "comment": "Temporary is a flag to mark error as temporary.",
                    "is_complex_type": false
                  }
                ]
              },
              {
                "field": "proxies[].http.status_to_code_transforms[].to_disconnect",
                "name": "to_disconnect",
                "go_name": "ToDisconnect",
                "level": 4,
                "type": "TransformDisconnect",
                "default": "",
                "comment": "ToDisconnect is a transform to protocol disconnect.",
                "is_complex_type": true,
                "children": [
                  {
                    "field": "proxies[].http.status_to_code_transforms[].to_disconnect.code",
                    "name": "code",
                    "go_name": "Code",
                    "level": 5,
                    "type": "uint32",
                    "default": "",
                    "comment": "Code of disconnect.",
                    "is_complex_type": false
                  },
                  {
                    "field": "proxies[].http.status_to_code_transforms[].to_disconnect.reason",
                    "name": "reason",
                    "go_name": "Reason",
                    "level": 5,
                    "type": "string",
                    "default": "",
                    "comment": "Reason is a human-readable reason of disconnect.",
                    "is_complex_type": false
                  }
                ]
              }
            ]
          }
        ]
      },
      {
        "field": "proxies[].grpc",
        "name": "grpc",
        "go_name": "GRPC",
        "level": 2,
        "type": "ProxyCommonGRPC",
        "default": "",
        "comment": "",
        "is_complex_type": true,
        "children": [
          {
            "field": "proxies[].grpc.tls",
            "name": "tls",
            "go_name": "TLS",
            "level": 3,
            "type": "TLSConfig",
            "default": "",
            "comment": "TLS is a common configuration for GRPC client TLS.",
            "is_complex_type": true,
            "children": [
              {
                "field": "proxies[].grpc.tls.enabled",
                "name": "enabled",
                "go_name": "Enabled",
                "level": 4,
                "type": "bool",
                "default": "",
                "comment": "Enabled turns on using TLS.",
                "is_complex_type": false
              },
              {
                "field": "proxies[].grpc.tls.cert_pem",
                "name": "cert_pem",
                "go_name": "CertPem",
                "level": 4,
                "type": "PEMData",
                "default": "",
                "comment": "CertPem is a PEM certificate.",
                "is_complex_type": false
              },
              {
                "field": "proxies[].grpc.tls.key_pem",
                "name": "key_pem",
                "go_name": "KeyPem",
                "level": 4,
                "type": "PEMData",
                "default": "",
                "comment": "KeyPem is a path to a file with key in PEM format.",
                "is_complex_type": false
              },
              {
                "field": "proxies[].grpc.tls.server_ca_pem",
                "name": "server_ca_pem",
                "go_name": "ServerCAPem",
                "level": 4,
                "type": "PEMData",
                "default": "",
                "comment": "ServerCAPem is a server root CA certificate in PEM format.\nThe client uses this certificate to verify the server's certificate during the TLS handshake.",
                "is_complex_type": false
              },
              {
                "field": "proxies[].grpc.tls.client_ca_pem",
                "name": "client_ca_pem",
                "go_name": "ClientCAPem",
                "level": 4,
                "type": "PEMData",
                "default": "",
                "comment": "ClientCAPem is a client CA certificate in PEM format.\nThe server uses this certificate to verify the client's certificate during the TLS handshake.",
                "is_complex_type": false
              },
              {
                "field": "proxies[].grpc.tls.insecure_skip_verify",
                "name": "insecure_skip_verify",
                "go_name": "InsecureSkipVerify",
                "level": 4,
                "type": "bool",
                "default": "",
                "comment": "InsecureSkipVerify turns off server certificate verification.",
                "is_complex_type": false
              },
              {
                "field": "proxies[].grpc.tls.server_name",
                "name": "server_name",
                "go_name": "ServerName",
                "level": 4,
                "type": "string",
                "default": "",
                "comment": "ServerName is used to verify the hostname on the returned certificates.",
                "is_complex_type": false
              }
            ]
          },
          {
            "field": "proxies[].grpc.credentials_key",
            "name": "credentials_key",
            "go_name": "CredentialsKey",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "CredentialsKey is a custom key to add into per-RPC credentials.",
            "is_complex_type": false
          },
          {
            "field": "proxies[].grpc.credentials_value",
            "name": "credentials_value",
            "go_name": "CredentialsValue",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "CredentialsValue is a custom value for GrpcCredentialsKey.",
            "is_complex_type": false
          },
          {
            "field": "proxies[].grpc.compression",
            "name": "compression",
            "go_name": "Compression",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "Compression enables compression for outgoing calls (gzip).",
            "is_complex_type": false
          }
        ]
      }
    ]
  },
  {
    "field": "http_api",
    "name": "http_api",
    "go_name": "HttpAPI",
    "level": 1,
    "type": "HttpAPI",
    "default": "",
    "comment": "HttpAPI is a configuration for HTTP server API. It's enabled by default.",
    "is_complex_type": true,
    "children": [
      {
        "field": "http_api.disabled",
        "name": "disabled",
        "go_name": "Disabled",
        "level": 2,
        "type": "bool",
        "default": "",
        "comment": "",
        "is_complex_type": false
      },
      {
        "field": "http_api.handler_prefix",
        "name": "handler_prefix",
        "go_name": "HandlerPrefix",
        "level": 2,
        "type": "string",
        "default": "/api",
        "comment": "",
        "is_complex_type": false
      },
      {
        "field": "http_api.key",
        "name": "key",
        "go_name": "Key",
        "level": 2,
        "type": "string",
        "default": "",
        "comment": "",
        "is_complex_type": false
      },
      {
        "field": "http_api.error_mode",
        "name": "error_mode",
        "go_name": "ErrorMode",
        "level": 2,
        "type": "string",
        "default": "",
        "comment": "",
        "is_complex_type": false
      },
      {
        "field": "http_api.external",
        "name": "external",
        "go_name": "External",
        "level": 2,
        "type": "bool",
        "default": "",
        "comment": "",
        "is_complex_type": false
      },
      {
        "field": "http_api.insecure",
        "name": "insecure",
        "go_name": "Insecure",
        "level": 2,
        "type": "bool",
        "default": "",
        "comment": "",
        "is_complex_type": false
      }
    ]
  },
  {
    "field": "grpc_api",
    "name": "grpc_api",
    "go_name": "GrpcAPI",
    "level": 1,
    "type": "GrpcAPI",
    "default": "",
    "comment": "GrpcAPI is a configuration for gRPC server API. It's disabled by default.",
    "is_complex_type": true,
    "children": [
      {
        "field": "grpc_api.enabled",
        "name": "enabled",
        "go_name": "Enabled",
        "level": 2,
        "type": "bool",
        "default": "",
        "comment": "",
        "is_complex_type": false
      },
      {
        "field": "grpc_api.error_mode",
        "name": "error_mode",
        "go_name": "ErrorMode",
        "level": 2,
        "type": "string",
        "default": "",
        "comment": "",
        "is_complex_type": false
      },
      {
        "field": "grpc_api.address",
        "name": "address",
        "go_name": "Address",
        "level": 2,
        "type": "string",
        "default": "",
        "comment": "",
        "is_complex_type": false
      },
      {
        "field": "grpc_api.port",
        "name": "port",
        "go_name": "Port",
        "level": 2,
        "type": "int",
        "default": "10000",
        "comment": "",
        "is_complex_type": false
      },
      {
        "field": "grpc_api.key",
        "name": "key",
        "go_name": "Key",
        "level": 2,
        "type": "string",
        "default": "",
        "comment": "",
        "is_complex_type": false
      },
      {
        "field": "grpc_api.tls",
        "name": "tls",
        "go_name": "TLS",
        "level": 2,
        "type": "TLSConfig",
        "default": "",
        "comment": "",
        "is_complex_type": true,
        "children": [
          {
            "field": "grpc_api.tls.enabled",
            "name": "enabled",
            "go_name": "Enabled",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "Enabled turns on using TLS.",
            "is_complex_type": false
          },
          {
            "field": "grpc_api.tls.cert_pem",
            "name": "cert_pem",
            "go_name": "CertPem",
            "level": 3,
            "type": "PEMData",
            "default": "",
            "comment": "CertPem is a PEM certificate.",
            "is_complex_type": false
          },
          {
            "field": "grpc_api.tls.key_pem",
            "name": "key_pem",
            "go_name": "KeyPem",
            "level": 3,
            "type": "PEMData",
            "default": "",
            "comment": "KeyPem is a path to a file with key in PEM format.",
            "is_complex_type": false
          },
          {
            "field": "grpc_api.tls.server_ca_pem",
            "name": "server_ca_pem",
            "go_name": "ServerCAPem",
            "level": 3,
            "type": "PEMData",
            "default": "",
            "comment": "ServerCAPem is a server root CA certificate in PEM format.\nThe client uses this certificate to verify the server's certificate during the TLS handshake.",
            "is_complex_type": false
          },
          {
            "field": "grpc_api.tls.client_ca_pem",
            "name": "client_ca_pem",
            "go_name": "ClientCAPem",
            "level": 3,
            "type": "PEMData",
            "default": "",
            "comment": "ClientCAPem is a client CA certificate in PEM format.\nThe server uses this certificate to verify the client's certificate during the TLS handshake.",
            "is_complex_type": false
          },
          {
            "field": "grpc_api.tls.insecure_skip_verify",
            "name": "insecure_skip_verify",
            "go_name": "InsecureSkipVerify",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "InsecureSkipVerify turns off server certificate verification.",
            "is_complex_type": false
          },
          {
            "field": "grpc_api.tls.server_name",
            "name": "server_name",
            "go_name": "ServerName",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "ServerName is used to verify the hostname on the returned certificates.",
            "is_complex_type": false
          }
        ]
      },
      {
        "field": "grpc_api.reflection",
        "name": "reflection",
        "go_name": "Reflection",
        "level": 2,
        "type": "bool",
        "default": "",
        "comment": "",
        "is_complex_type": false
      },
      {
        "field": "grpc_api.max_receive_message_size",
        "name": "max_receive_message_size",
        "go_name": "MaxReceiveMessageSize",
        "level": 2,
        "type": "int",
        "default": "",
        "comment": "",
        "is_complex_type": false
      }
    ]
  },
  {
    "field": "consumers",
    "name": "consumers",
    "go_name": "Consumers",
    "level": 1,
    "type": "[]Consumer",
    "default": "[]",
    "comment": "Consumers is a configuration for message queue consumers. For example, Centrifugo can consume\nmessages from PostgreSQL transactional outbox table, or from Kafka topics.",
    "is_complex_type": true,
    "children": [
      {
        "field": "consumers[].name",
        "name": "name",
        "go_name": "Name",
        "level": 2,
        "type": "string",
        "default": "",
        "comment": "Name is a unique name required for each consumer.",
        "is_complex_type": false
      },
      {
        "field": "consumers[].enabled",
        "name": "enabled",
        "go_name": "Enabled",
        "level": 2,
        "type": "bool",
        "default": "",
        "comment": "Enabled must be true to tell Centrifugo to run configured consumer.",
        "is_complex_type": false
      },
      {
        "field": "consumers[].type",
        "name": "type",
        "go_name": "Type",
        "level": 2,
        "type": "string",
        "default": "",
        "comment": "Type describes the type of consumer. Supported types are: `postgresql`, `kafka`, `nats_jetstream`,\n`redis_stream`, `google_pub_sub`, `aws_sqs`, `azure_service_bus`.",
        "is_complex_type": false
      },
      {
        "field": "consumers[].postgresql",
        "name": "postgresql",
        "go_name": "Postgres",
        "level": 2,
        "type": "PostgresConsumerConfig",
        "default": "",
        "comment": "Postgres allows defining options for consumer of postgresql type.",
        "is_complex_type": true,
        "children": [
          {
            "field": "consumers[].postgresql.dsn",
            "name": "dsn",
            "go_name": "DSN",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "",
            "is_complex_type": false
          },
          {
            "field": "consumers[].postgresql.outbox_table_name",
            "name": "outbox_table_name",
            "go_name": "OutboxTableName",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "",
            "is_complex_type": false
          },
          {
            "field": "consumers[].postgresql.num_partitions",
            "name": "num_partitions",
            "go_name": "NumPartitions",
            "level": 3,
            "type": "int",
            "default": "1",
            "comment": "",
            "is_complex_type": false
          },
          {
            "field": "consumers[].postgresql.partition_select_limit",
            "name": "partition_select_limit",
            "go_name": "PartitionSelectLimit",
            "level": 3,
            "type": "int",
            "default": "100",
            "comment": "",
            "is_complex_type": false
          },
          {
            "field": "consumers[].postgresql.partition_poll_interval",
            "name": "partition_poll_interval",
            "go_name": "PartitionPollInterval",
            "level": 3,
            "type": "Duration",
            "default": "300ms",
            "comment": "",
            "is_complex_type": false
          },
          {
            "field": "consumers[].postgresql.partition_notification_channel",
            "name": "partition_notification_channel",
            "go_name": "PartitionNotificationChannel",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "",
            "is_complex_type": false
          },
          {
            "field": "consumers[].postgresql.tls",
            "name": "tls",
            "go_name": "TLS",
            "level": 3,
            "type": "TLSConfig",
            "default": "",
            "comment": "",
            "is_complex_type": true,
            "children": [
              {
                "field": "consumers[].postgresql.tls.enabled",
                "name": "enabled",
                "go_name": "Enabled",
                "level": 4,
                "type": "bool",
                "default": "",
                "comment": "Enabled turns on using TLS.",
                "is_complex_type": false
              },
              {
                "field": "consumers[].postgresql.tls.cert_pem",
                "name": "cert_pem",
                "go_name": "CertPem",
                "level": 4,
                "type": "PEMData",
                "default": "",
                "comment": "CertPem is a PEM certificate.",
                "is_complex_type": false
              },
              {
                "field": "consumers[].postgresql.tls.key_pem",
                "name": "key_pem",
                "go_name": "KeyPem",
                "level": 4,
                "type": "PEMData",
                "default": "",
                "comment": "KeyPem is a path to a file with key in PEM format.",
                "is_complex_type": false
              },
              {
                "field": "consumers[].postgresql.tls.server_ca_pem",
                "name": "server_ca_pem",
                "go_name": "ServerCAPem",
                "level": 4,
                "type": "PEMData",
                "default": "",
                "comment": "ServerCAPem is a server root CA certificate in PEM format.\nThe client uses this certificate to verify the server's certificate during the TLS handshake.",
                "is_complex_type": false
              },
              {
                "field": "consumers[].postgresql.tls.client_ca_pem",
                "name": "client_ca_pem",
                "go_name": "ClientCAPem",
                "level": 4,
                "type": "PEMData",
                "default": "",
                "comment": "ClientCAPem is a client CA certificate in PEM format.\nThe server uses this certificate to verify the client's certificate during the TLS handshake.",
                "is_complex_type": false
              },
              {
                "field": "consumers[].postgresql.tls.insecure_skip_verify",
                "name": "insecure_skip_verify",
                "go_name": "InsecureSkipVerify",
                "level": 4,
                "type": "bool",
                "default": "",
                "comment": "InsecureSkipVerify turns off server certificate verification.",
                "is_complex_type": false
              },
              {
                "field": "consumers[].postgresql.tls.server_name",
                "name": "server_name",
                "go_name": "ServerName",
                "level": 4,
                "type": "string",
                "default": "",
                "comment": "ServerName is used to verify the hostname on the returned certificates.",
                "is_complex_type": false
              }
            ]
          },
          {
            "field": "consumers[].postgresql.use_try_lock",
            "name": "use_try_lock",
            "go_name": "UseTryLock",
            "level": 3,
            "type": "bool",
            "default": "false",
            "comment": "UseTryLock when enabled tells Centrifugo to use pg_try_advisory_xact_lock instead of pg_advisory_xact_lock.",
            "is_complex_type": false
          }
        ]
      },
      {
        "field": "consumers[].kafka",
        "name": "kafka",
        "go_name": "Kafka",
        "level": 2,
        "type": "KafkaConsumerConfig",
        "default": "",
        "comment": "Kafka allows defining options for consumer of kafka type.",
        "is_complex_type": true,
        "children": [
          {
            "field": "consumers[].kafka.brokers",
            "name": "brokers",
            "go_name": "Brokers",
            "level": 3,
            "type": "[]string",
            "default": "",
            "comment": "",
            "is_complex_type": false
          },
          {
            "field": "consumers[].kafka.topics",
            "name": "topics",
            "go_name": "Topics",
            "level": 3,
            "type": "[]string",
            "default": "",
            "comment": "",
            "is_complex_type": false
          },
          {
            "field": "consumers[].kafka.consumer_group",
            "name": "consumer_group",
            "go_name": "ConsumerGroup",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "",
            "is_complex_type": false
          },
          {
            "field": "consumers[].kafka.max_poll_records",
            "name": "max_poll_records",
            "go_name": "MaxPollRecords",
            "level": 3,
            "type": "int",
            "default": "100",
            "comment": "",
            "is_complex_type": false
          },
          {
            "field": "consumers[].kafka.fetch_max_bytes",
            "name": "fetch_max_bytes",
            "go_name": "FetchMaxBytes",
            "level": 3,
            "type": "int32",
            "default": "",
            "comment": "FetchMaxBytes is the maximum number of bytes to fetch from Kafka in a single request.\nIf not set the default 50MB is used.",
            "is_complex_type": false
          },
          {
            "field": "consumers[].kafka.fetch_max_wait",
            "name": "fetch_max_wait",
            "go_name": "FetchMaxWait",
            "level": 3,
            "type": "Duration",
            "default": "500ms",
            "comment": "FetchMaxWait is the maximum time to wait for records when polling.\nIf not set, defaults to 500ms.",
            "is_complex_type": false
          },
          {
            "field": "consumers[].kafka.fetch_read_uncommitted",
            "name": "fetch_read_uncommitted",
            "go_name": "FetchReadUncommitted",
            "level": 3,
            "type": "bool",
            "default": "false",
            "comment": "FetchReadUncommitted is a flag to enable reading uncommitted messages from Kafka. By default, this is false and Centrifugo uses ReadCommitted mode.",
            "is_complex_type": false
          },
          {
            "field": "consumers[].kafka.partition_queue_max_size",
            "name": "partition_queue_max_size",
            "go_name": "PartitionQueueMaxSize",
            "level": 3,
            "type": "int",
            "default": "1000",
            "comment": "PartitionQueueMaxSize is the maximum number of items in partition queue before pausing consuming from a partition.\nThe actual queue size may exceed this value on `max_poll_records`, so this acts more like a threshold.\nIf -1, pausing is done on every poll. If set, pausing only happens when queue size exceeds this threshold.",
            "is_complex_type": false
          },
          {
            "field": "consumers[].kafka.tls",
            "name": "tls",
            "go_name": "TLS",
            "level": 3,
            "type": "TLSConfig",
            "default": "",
            "comment": "TLS for the connection to Kafka.",
            "is_complex_type": true,
            "children": [
              {
                "field": "consumers[].kafka.tls.enabled",
                "name": "enabled",
                "go_name": "Enabled",
                "level": 4,
                "type": "bool",
                "default": "",
                "comment": "Enabled turns on using TLS.",
                "is_complex_type": false
              },
              {
                "field": "consumers[].kafka.tls.cert_pem",
                "name": "cert_pem",
                "go_name": "CertPem",
                "level": 4,
                "type": "PEMData",
                "default": "",
                "comment": "CertPem is a PEM certificate.",
                "is_complex_type": false
              },
              {
                "field": "consumers[].kafka.tls.key_pem",
                "name": "key_pem",
                "go_name": "KeyPem",
                "level": 4,
                "type": "PEMData",
                "default": "",
                "comment": "KeyPem is a path to a file with key in PEM format.",
                "is_complex_type": false
              },
              {
                "field": "consumers[].kafka.tls.server_ca_pem",
                "name": "server_ca_pem",
                "go_name": "ServerCAPem",
                "level": 4,
                "type": "PEMData",
                "default": "",
                "comment": "ServerCAPem is a server root CA certificate in PEM format.\nThe client uses this certificate to verify the server's certificate during the TLS handshake.",
                "is_complex_type": false
              },
              {
                "field": "consumers[].kafka.tls.client_ca_pem",
                "name": "client_ca_pem",
                "go_name": "ClientCAPem",
                "level": 4,
                "type": "PEMData",
                "default": "",
                "comment": "ClientCAPem is a client CA certificate in PEM format.\nThe server uses this certificate to verify the client's certificate during the TLS handshake.",
                "is_complex_type": false
              },
              {
                "field": "consumers[].kafka.tls.insecure_skip_verify",
                "name": "insecure_skip_verify",
                "go_name": "InsecureSkipVerify",
                "level": 4,
                "type": "bool",
                "default": "",
                "comment": "InsecureSkipVerify turns off server certificate verification.",
                "is_complex_type": false
              },
              {
                "field": "consumers[].kafka.tls.server_name",
                "name": "server_name",
                "go_name": "ServerName",
                "level": 4,
                "type": "string",
                "default": "",
                "comment": "ServerName is used to verify the hostname on the returned certificates.",
                "is_complex_type": false
              }
            ]
          },
          {
            "field": "consumers[].kafka.sasl_mechanism",
            "name": "sasl_mechanism",
            "go_name": "SASLMechanism",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "SASLMechanism when not empty enables SASL auth.",
            "is_complex_type": false
          },
          {
            "field": "consumers[].kafka.sasl_user",
            "name": "sasl_user",
            "go_name": "SASLUser",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "",
            "is_complex_type": false
          },
          {
            "field": "consumers[].kafka.sasl_password",
            "name": "sasl_password",
            "go_name": "SASLPassword",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "",
            "is_complex_type": false
          },
          {
            "field": "consumers[].kafka.method_header",
            "name": "method_header",
            "go_name": "MethodHeader",
            "level": 3,
            "type": "string",
            "default": "centrifugo-method",
            "comment": "MethodHeader is a header name to extract method name from Kafka message.\nIf provided in message, then payload must be just a serialized API request object.",
            "is_complex_type": false
          },
          {
            "field": "consumers[].kafka.publication_data_mode",
            "name": "publication_data_mode",
            "go_name": "PublicationDataMode",
            "level": 3,
            "type": "KafkaPublicationDataModeConfig",
            "default": "",
            "comment": "PublicationDataMode is a configuration for the mode where message payload already\ncontains data ready to publish into channels, instead of API command.",
            "is_complex_type": true,
            "children": [
              {
                "field": "consumers[].kafka.publication_data_mode.enabled",
                "name": "enabled",
                "go_name": "Enabled",
                "level": 4,
                "type": "bool",
                "default": "",
                "comment": "Enabled enables Kafka publication data mode for the Kafka consumer.",
                "is_complex_type": false
              },
              {
                "field": "consumers[].kafka.publication_data_mode.channels_header",
                "name": "channels_header",
                "go_name": "ChannelsHeader",
                "level": 4,
                "type": "string",
                "default": "centrifugo-channels",
                "comment": "ChannelsHeader is a header name to extract channels to publish data into\n(channels must be comma-separated). Ex. of value: \"channel1,channel2\".",
                "is_complex_type": false
              },
              {
                "field": "consumers[].kafka.publication_data_mode.idempotency_key_header",
                "name": "idempotency_key_header",
                "go_name": "IdempotencyKeyHeader",
                "level": 4,
                "type": "string",
                "default": "centrifugo-idempotency-key",
                "comment": "IdempotencyKeyHeader is a header name to extract Publication idempotency key from\nKafka message. See https://centrifugal.dev/docs/server/server_api#publishrequest.",
                "is_complex_type": false
              },
              {
                "field": "consumers[].kafka.publication_data_mode.delta_header",
                "name": "delta_header",
                "go_name": "DeltaHeader",
                "level": 4,
                "type": "string",
                "default": "centrifugo-delta",
                "comment": "DeltaHeader is a header name to extract Publication delta flag from Kafka message\nwhich tells Centrifugo whether to use delta compression for message or not.\nSee https://centrifugal.dev/docs/server/delta_compression and\nhttps://centrifugal.dev/docs/server/server_api#publishrequest.",
                "is_complex_type": false
              },
              {
                "field": "consumers[].kafka.publication_data_mode.version_header",
                "name": "version_header",
                "go_name": "VersionHeader",
                "level": 4,
                "type": "string",
                "default": "centrifugo-version",
                "comment": "VersionHeader is a header name to extract Publication version from Kafka message.",
                "is_complex_type": false
              },
              {
                "field": "consumers[].kafka.publication_data_mode.version_epoch_header",
                "name": "version_epoch_header",
                "go_name": "VersionEpochHeader",
                "level": 4,
                "type": "string",
                "default": "centrifugo-version-epoch",
                "comment": "VersionEpochHeader is a header name to extract Publication version epoch from Kafka message.",
                "is_complex_type": false
              },
              {
                "field": "consumers[].kafka.publication_data_mode.tags_header_prefix",
                "name": "tags_header_prefix",
                "go_name": "TagsHeaderPrefix",
                "level": 4,
                "type": "string",
                "default": "centrifugo-tag-",
                "comment": "TagsHeaderPrefix is a prefix for headers that contain tags to attach to Publication.",
                "is_complex_type": false
              }
            ]
          }
        ]
      },
      {
        "field": "consumers[].nats_jetstream",
        "name": "nats_jetstream",
        "go_name": "NatsJetStream",
        "level": 2,
        "type": "NatsJetStreamConsumerConfig",
        "default": "",
        "comment": "NatsJetStream allows defining options for consumer of nats_jetstream type.",
        "is_complex_type": true,
        "children": [
          {
            "field": "consumers[].nats_jetstream.url",
            "name": "url",
            "go_name": "URL",
            "level": 3,
            "type": "string",
            "default": "nats://127.0.0.1:4222",
            "comment": "URL is the address of the NATS server.",
            "is_complex_type": false
          },
          {
            "field": "consumers[].nats_jetstream.credentials_file",
            "name": "credentials_file",
            "go_name": "CredentialsFile",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "CredentialsFile is the path to a NATS credentials file used for authentication (nats.UserCredentials).\nIf provided, it overrides username/password and token.",
            "is_complex_type": false
          },
          {
            "field": "consumers[].nats_jetstream.username",
            "name": "username",
            "go_name": "Username",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "Username is used for basic authentication (along with Password) if CredentialsFile is not provided.",
            "is_complex_type": false
          },
          {
            "field": "consumers[].nats_jetstream.password",
            "name": "password",
            "go_name": "Password",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "Password is used with Username for basic authentication.",
            "is_complex_type": false
          },
          {
            "field": "consumers[].nats_jetstream.token",
            "name": "token",
            "go_name": "Token",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "Token is an alternative authentication mechanism if CredentialsFile and Username are not provided.",
            "is_complex_type": false
          },
          {
            "field": "consumers[].nats_jetstream.stream_name",
            "name": "stream_name",
            "go_name": "StreamName",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "StreamName is the name of the NATS JetStream stream to use.",
            "is_complex_type": false
          },
          {
            "field": "consumers[].nats_jetstream.subjects",
            "name": "subjects",
            "go_name": "Subjects",
            "level": 3,
            "type": "[]string",
            "default": "",
            "comment": "Subjects is the list of NATS subjects (topics) to filter.",
            "is_complex_type": false
          },
          {
            "field": "consumers[].nats_jetstream.durable_consumer_name",
            "name": "durable_consumer_name",
            "go_name": "DurableConsumerName",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "DurableConsumerName sets the name of the durable JetStream consumer to use.",
            "is_complex_type": false
          },
          {
            "field": "consumers[].nats_jetstream.deliver_policy",
            "name": "deliver_policy",
            "go_name": "DeliverPolicy",
            "level": 3,
            "type": "string",
            "default": "new",
            "comment": "DeliverPolicy is the NATS JetStream delivery policy for the consumer. By default, it is set to \"new\". Possible values: `new`, `all`.",
            "is_complex_type": false
          },
          {
            "field": "consumers[].nats_jetstream.max_ack_pending",
            "name": "max_ack_pending",
            "go_name": "MaxAckPending",
            "level": 3,
            "type": "int",
            "default": "100",
            "comment": "MaxAckPending is the maximum number of unacknowledged messages that can be pending for the consumer.",
            "is_complex_type": false
          },
          {
            "field": "consumers[].nats_jetstream.method_header",
            "name": "method_header",
            "go_name": "MethodHeader",
            "level": 3,
            "type": "string",
            "default": "centrifugo-method",
            "comment": "MethodHeader is the NATS message header used to extract the method name for dispatching commands.\nIf provided in message, then payload must be just a serialized API request object.",
            "is_complex_type": false
          },
          {
            "field": "consumers[].nats_jetstream.publication_data_mode",
            "name": "publication_data_mode",
            "go_name": "PublicationDataMode",
            "level": 3,
            "type": "NatsJetStreamPublicationDataModeConfig",
            "default": "",
            "comment": "PublicationDataMode configures extraction of pre-formatted publication data from message headers.",
            "is_complex_type": true,
            "children": [
              {
                "field": "consumers[].nats_jetstream.publication_data_mode.enabled",
                "name": "enabled",
                "go_name": "Enabled",
                "level": 4,
                "type": "bool",
                "default": "",
                "comment": "Enabled toggles publication data mode.",
                "is_complex_type": false
              },
              {
                "field": "consumers[].nats_jetstream.publication_data_mode.channels_header",
                "name": "channels_header",
                "go_name": "ChannelsHeader",
                "level": 4,
                "type": "string",
                "default": "centrifugo-channels",
                "comment": "ChannelsHeader is the name of the header that contains comma-separated channel names.",
                "is_complex_type": false
              },
              {
                "field": "consumers[].nats_jetstream.publication_data_mode.idempotency_key_header",
                "name": "idempotency_key_header",
                "go_name": "IdempotencyKeyHeader",
                "level": 4,
                "type": "string",
                "default": "centrifugo-idempotency-key",
                "comment": "IdempotencyKeyHeader is the name of the header that contains an idempotency key for deduplication.",
                "is_complex_type": false
              },
              {
                "field": "consumers[].nats_jetstream.publication_data_mode.delta_header",
                "name": "delta_header",
                "go_name": "DeltaHeader",
                "level": 4,
                "type": "string",
                "default": "centrifugo-delta",
                "comment": "DeltaHeader is the name of the header indicating whether the message represents a delta (partial update).",
                "is_complex_type": false
              },
              {
                "field": "consumers[].nats_jetstream.publication_data_mode.version_header",
                "name": "version_header",
                "go_name": "VersionHeader",
                "level": 4,
                "type": "string",
                "default": "centrifugo-version",
                "comment": "VersionHeader is the name of the header that contains the version of the message.",
                "is_complex_type": false
              },
              {
                "field": "consumers[].nats_jetstream.publication_data_mode.version_epoch_header",
                "name": "version_epoch_header",
                "go_name": "VersionEpochHeader",
                "level": 4,
                "type": "string",
                "default": "centrifugo-version-epoch",
                "comment": "VersionEpochHeader is the name of the header that contains the version epoch of the message.",
                "is_complex_type": false
              },
              {
                "field": "consumers[].nats_jetstream.publication_data_mode.tags_header_prefix",
                "name": "tags_header_prefix",
                "go_name": "TagsHeaderPrefix",
                "level": 4,
                "type": "string",
                "default": "centrifugo-tag-",
                "comment": "TagsHeaderPrefix is the prefix used to extract dynamic tags from message headers.",
                "is_complex_type": false
              }
            ]
          },
          {
            "field": "consumers[].nats_jetstream.tls",
            "name": "tls",
            "go_name": "TLS",
            "level": 3,
            "type": "TLSConfig",
            "default": "",
            "comment": "TLS is the configuration for TLS.",
            "is_complex_type": true,
            "children": [
              {
                "field": "consumers[].nats_jetstream.tls.enabled",
                "name": "enabled",
                "go_name": "Enabled",
                "level": 4,
                "type": "bool",
                "default": "",
                "comment": "Enabled turns on using TLS.",
                "is_complex_type": false
              },
              {
                "field": "consumers[].nats_jetstream.tls.cert_pem",
                "name": "cert_pem",
                "go_name": "CertPem",
                "level": 4,
                "type": "PEMData",
                "default": "",
                "comment": "CertPem is a PEM certificate.",
                "is_complex_type": false
              },
              {
                "field": "consumers[].nats_jetstream.tls.key_pem",
                "name": "key_pem",
                "go_name": "KeyPem",
                "level": 4,
                "type": "PEMData",
                "default": "",
                "comment": "KeyPem is a path to a file with key in PEM format.",
                "is_complex_type": false
              },
              {
                "field": "consumers[].nats_jetstream.tls.server_ca_pem",
                "name": "server_ca_pem",
                "go_name": "ServerCAPem",
                "level": 4,
                "type": "PEMData",
                "default": "",
                "comment": "ServerCAPem is a server root CA certificate in PEM format.\nThe client uses this certificate to verify the server's certificate during the TLS handshake.",
                "is_complex_type": false
              },
              {
                "field": "consumers[].nats_jetstream.tls.client_ca_pem",
                "name": "client_ca_pem",
                "go_name": "ClientCAPem",
                "level": 4,
                "type": "PEMData",
                "default": "",
                "comment": "ClientCAPem is a client CA certificate in PEM format.\nThe server uses this certificate to verify the client's certificate during the TLS handshake.",
                "is_complex_type": false
              },
              {
                "field": "consumers[].nats_jetstream.tls.insecure_skip_verify",
                "name": "insecure_skip_verify",
                "go_name": "InsecureSkipVerify",
                "level": 4,
                "type": "bool",
                "default": "",
                "comment": "InsecureSkipVerify turns off server certificate verification.",
                "is_complex_type": false
              },
              {
                "field": "consumers[].nats_jetstream.tls.server_name",
                "name": "server_name",
                "go_name": "ServerName",
                "level": 4,
                "type": "string",
                "default": "",
                "comment": "ServerName is used to verify the hostname on the returned certificates.",
                "is_complex_type": false
              }
            ]
          }
        ]
      },
      {
        "field": "consumers[].redis_stream",
        "name": "redis_stream",
        "go_name": "RedisStream",
        "level": 2,
        "type": "RedisStreamConsumerConfig",
        "default": "",
        "comment": "RedisStream allows defining options for consumer of redis_stream type.",
        "is_complex_type": true,
        "children": [
          {
            "field": "consumers[].redis_stream.address",
            "name": "address",
            "go_name": "Address",
            "level": 3,
            "type": "[]string",
            "default": "redis://127.0.0.1:6379",
            "comment": "Address is a list of Redis shard addresses. In most cases a single shard is used. But when many\naddresses provided Centrifugo will distribute keys between shards using consistent hashing.",
            "is_complex_type": false
          },
          {
            "field": "consumers[].redis_stream.connect_timeout",
            "name": "connect_timeout",
            "go_name": "ConnectTimeout",
            "level": 3,
            "type": "Duration",
            "default": "1s",
            "comment": "ConnectTimeout is a timeout for establishing connection to Redis.",
            "is_complex_type": false
          },
          {
            "field": "consumers[].redis_stream.io_timeout",
            "name": "io_timeout",
            "go_name": "IOTimeout",
            "level": 3,
            "type": "Duration",
            "default": "4s",
            "comment": "IOTimeout is a timeout for all read/write operations against Redis (can be considered as a request timeout).",
            "is_complex_type": false
          },
          {
            "field": "consumers[].redis_stream.db",
            "name": "db",
            "go_name": "DB",
            "level": 3,
            "type": "int",
            "default": "0",
            "comment": "DB is a Redis database to use. Generally it's not recommended to use non-zero DB. Note, that Redis\nPUB/SUB is global for all databases in a single Redis instance. So when using non-zero DB make sure\nthat different Centrifugo setups use different prefixes.",
            "is_complex_type": false
          },
          {
            "field": "consumers[].redis_stream.user",
            "name": "user",
            "go_name": "User",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "User is a Redis user.",
            "is_complex_type": false
          },
          {
            "field": "consumers[].redis_stream.password",
            "name": "password",
            "go_name": "Password",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "Password is a Redis password.",
            "is_complex_type": false
          },
          {
            "field": "consumers[].redis_stream.client_name",
            "name": "client_name",
            "go_name": "ClientName",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "ClientName allows changing a Redis client name used when connecting.",
            "is_complex_type": false
          },
          {
            "field": "consumers[].redis_stream.force_resp2",
            "name": "force_resp2",
            "go_name": "ForceResp2",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "ForceResp2 forces use of Redis Resp2 protocol for communication.",
            "is_complex_type": false
          },
          {
            "field": "consumers[].redis_stream.cluster_address",
            "name": "cluster_address",
            "go_name": "ClusterAddress",
            "level": 3,
            "type": "[]string",
            "default": "",
            "comment": "ClusterAddress is a list of Redis cluster addresses. When several provided - data will be sharded\nbetween them using consistent hashing. Several Cluster addresses within one shard may be passed\ncomma-separated.",
            "is_complex_type": false
          },
          {
            "field": "consumers[].redis_stream.tls",
            "name": "tls",
            "go_name": "TLS",
            "level": 3,
            "type": "TLSConfig",
            "default": "",
            "comment": "TLS is a configuration for Redis TLS support.",
            "is_complex_type": true,
            "children": [
              {
                "field": "consumers[].redis_stream.tls.enabled",
                "name": "enabled",
                "go_name": "Enabled",
                "level": 4,
                "type": "bool",
                "default": "",
                "comment": "Enabled turns on using TLS.",
                "is_complex_type": false
              },
              {
                "field": "consumers[].redis_stream.tls.cert_pem",
                "name": "cert_pem",
                "go_name": "CertPem",
                "level": 4,
                "type": "PEMData",
                "default": "",
                "comment": "CertPem is a PEM certificate.",
                "is_complex_type": false
              },
              {
                "field": "consumers[].redis_stream.tls.key_pem",
                "name": "key_pem",
                "go_name": "KeyPem",
                "level": 4,
                "type": "PEMData",
                "default": "",
                "comment": "KeyPem is a path to a file with key in PEM format.",
                "is_complex_type": false
              },
              {
                "field": "consumers[].redis_stream.tls.server_ca_pem",
                "name": "server_ca_pem",
                "go_name": "ServerCAPem",
                "level": 4,
                "type": "PEMData",
                "default": "",
                "comment": "ServerCAPem is a server root CA certificate in PEM format.\nThe client uses this certificate to verify the server's certificate during the TLS handshake.",
                "is_complex_type": false
              },
              {
                "field": "consumers[].redis_stream.tls.client_ca_pem",
                "name": "client_ca_pem",
                "go_name": "ClientCAPem",
                "level": 4,
                "type": "PEMData",
                "default": "",
                "comment": "ClientCAPem is a client CA certificate in PEM format.\nThe server uses this certificate to verify the client's certificate during the TLS handshake.",
                "is_complex_type": false
              },
              {
                "field": "consumers[].redis_stream.tls.insecure_skip_verify",
                "name": "insecure_skip_verify",
                "go_name": "InsecureSkipVerify",
                "level": 4,
                "type": "bool",
                "default": "",
                "comment": "InsecureSkipVerify turns off server certificate verification.",
                "is_complex_type": false
              },
              {
                "field": "consumers[].redis_stream.tls.server_name",
                "name": "server_name",
                "go_name": "ServerName",
                "level": 4,
                "type": "string",
                "default": "",
                "comment": "ServerName is used to verify the hostname on the returned certificates.",
                "is_complex_type": false
              }
            ]
          },
          {
            "field": "consumers[].redis_stream.sentinel_address",
            "name": "sentinel_address",
            "go_name": "SentinelAddress",
            "level": 3,
            "type": "[]string",
            "default": "",
            "comment": "SentinelAddress allows setting Redis Sentinel addresses. When provided - Sentinel will be used.\nWhen multiple addresses provided - data will be sharded between them using consistent hashing.\nSeveral Sentinel addresses within one shard may be passed comma-separated.",
            "is_complex_type": false
          },
          {
            "field": "consumers[].redis_stream.sentinel_user",
            "name": "sentinel_user",
            "go_name": "SentinelUser",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "SentinelUser is a Redis Sentinel user.",
            "is_complex_type": false
          },
          {
            "field": "consumers[].redis_stream.sentinel_password",
            "name": "sentinel_password",
            "go_name": "SentinelPassword",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "SentinelPassword is a Redis Sentinel password.",
            "is_complex_type": false
          },
          {
            "field": "consumers[].redis_stream.sentinel_master_name",
            "name": "sentinel_master_name",
            "go_name": "SentinelMasterName",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "SentinelMasterName is a Redis master name in Sentinel setup.",
            "is_complex_type": false
          },
          {
            "field": "consumers[].redis_stream.sentinel_client_name",
            "name": "sentinel_client_name",
            "go_name": "SentinelClientName",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "SentinelClientName is a Redis Sentinel client name used when connecting.",
            "is_complex_type": false
          },
          {
            "field": "consumers[].redis_stream.sentinel_tls",
            "name": "sentinel_tls",
            "go_name": "SentinelTLS",
            "level": 3,
            "type": "TLSConfig",
            "default": "",
            "comment": "SentinelTLS is a configuration for Redis Sentinel TLS support.",
            "is_complex_type": true,
            "children": [
              {
                "field": "consumers[].redis_stream.sentinel_tls.enabled",
                "name": "enabled",
                "go_name": "Enabled",
                "level": 4,
                "type": "bool",
                "default": "",
                "comment": "Enabled turns on using TLS.",
                "is_complex_type": false
              },
              {
                "field": "consumers[].redis_stream.sentinel_tls.cert_pem",
                "name": "cert_pem",
                "go_name": "CertPem",
                "level": 4,
                "type": "PEMData",
                "default": "",
                "comment": "CertPem is a PEM certificate.",
                "is_complex_type": false
              },
              {
                "field": "consumers[].redis_stream.sentinel_tls.key_pem",
                "name": "key_pem",
                "go_name": "KeyPem",
                "level": 4,
                "type": "PEMData",
                "default": "",
                "comment": "KeyPem is a path to a file with key in PEM format.",
                "is_complex_type": false
              },
              {
                "field": "consumers[].redis_stream.sentinel_tls.server_ca_pem",
                "name": "server_ca_pem",
                "go_name": "ServerCAPem",
                "level": 4,
                "type": "PEMData",
                "default": "",
                "comment": "ServerCAPem is a server root CA certificate in PEM format.\nThe client uses this certificate to verify the server's certificate during the TLS handshake.",
                "is_complex_type": false
              },
              {
                "field": "consumers[].redis_stream.sentinel_tls.client_ca_pem",
                "name": "client_ca_pem",
                "go_name": "ClientCAPem",
                "level": 4,
                "type": "PEMData",
                "default": "",
                "comment": "ClientCAPem is a client CA certificate in PEM format.\nThe server uses this certificate to verify the client's certificate during the TLS handshake.",
                "is_complex_type": false
              },
              {
                "field": "consumers[].redis_stream.sentinel_tls.insecure_skip_verify",
                "name": "insecure_skip_verify",
                "go_name": "InsecureSkipVerify",
                "level": 4,
                "type": "bool",
                "default": "",
                "comment": "InsecureSkipVerify turns off server certificate verification.",
                "is_complex_type": false
              },
              {
                "field": "consumers[].redis_stream.sentinel_tls.server_name",
                "name": "server_name",
                "go_name": "ServerName",
                "level": 4,
                "type": "string",
                "default": "",
                "comment": "ServerName is used to verify the hostname on the returned certificates.",
                "is_complex_type": false
              }
            ]
          },
          {
            "field": "consumers[].redis_stream.replica_client",
            "name": "replica_client",
            "go_name": "ReplicaClient",
            "level": 3,
            "type": "RedisReplicaClient",
            "default": "",
            "comment": "ReplicaClient is a configuration for Redis replica client.",
            "is_complex_type": true,
            "children": [
              {
                "field": "consumers[].redis_stream.replica_client.enabled",
                "name": "enabled",
                "go_name": "Enabled",
                "level": 4,
                "type": "bool",
                "default": "",
                "comment": "Enabled enables replica client.",
                "is_complex_type": false
              }
            ]
          },
          {
            "field": "consumers[].redis_stream.streams",
            "name": "streams",
            "go_name": "Streams",
            "level": 3,
            "type": "[]string",
            "default": "",
            "comment": "Streams to consume.",
            "is_complex_type": false
          },
          {
            "field": "consumers[].redis_stream.consumer_group",
            "name": "consumer_group",
            "go_name": "ConsumerGroup",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "ConsumerGroup name to use.",
            "is_complex_type": false
          },
          {
            "field": "consumers[].redis_stream.visibility_timeout",
            "name": "visibility_timeout",
            "go_name": "VisibilityTimeout",
            "level": 3,
            "type": "Duration",
            "default": "30s",
            "comment": "VisibilityTimeout is the time to wait for a message to be processed before it is re-queued.",
            "is_complex_type": false
          },
          {
            "field": "consumers[].redis_stream.num_workers",
            "name": "num_workers",
            "go_name": "NumWorkers",
            "level": 3,
            "type": "int",
            "default": "1",
            "comment": "NumWorkers is the number of message workers to use for processing for each stream.",
            "is_complex_type": false
          },
          {
            "field": "consumers[].redis_stream.payload_value",
            "name": "payload_value",
            "go_name": "PayloadValue",
            "level": 3,
            "type": "string",
            "default": "payload",
            "comment": "PayloadValue is used to extract data from Redis Stream message.",
            "is_complex_type": false
          },
          {
            "field": "consumers[].redis_stream.method_value",
            "name": "method_value",
            "go_name": "MethodValue",
            "level": 3,
            "type": "string",
            "default": "method",
            "comment": "MethodValue is used to extract a method for command messages.\nIf provided in message, then payload must be just a serialized API request object.",
            "is_complex_type": false
          },
          {
            "field": "consumers[].redis_stream.publication_data_mode",
            "name": "publication_data_mode",
            "go_name": "PublicationDataMode",
            "level": 3,
            "type": "RedisStreamPublicationDataModeConfig",
            "default": "",
            "comment": "PublicationDataMode configures publication data mode.",
            "is_complex_type": true,
            "children": [
              {
                "field": "consumers[].redis_stream.publication_data_mode.enabled",
                "name": "enabled",
                "go_name": "Enabled",
                "level": 4,
                "type": "bool",
                "default": "",
                "comment": "Enabled toggles publication data mode.",
                "is_complex_type": false
              },
              {
                "field": "consumers[].redis_stream.publication_data_mode.channels_value",
                "name": "channels_value",
                "go_name": "ChannelsValue",
                "level": 4,
                "type": "string",
                "default": "centrifugo-channels",
                "comment": "ChannelsValue is used to extract channels to publish data into (channels must be comma-separated).",
                "is_complex_type": false
              },
              {
                "field": "consumers[].redis_stream.publication_data_mode.idempotency_key_value",
                "name": "idempotency_key_value",
                "go_name": "IdempotencyKeyValue",
                "level": 4,
                "type": "string",
                "default": "centrifugo-idempotency-key",
                "comment": "IdempotencyKeyValue is used to extract Publication idempotency key from Redis Stream message.",
                "is_complex_type": false
              },
              {
                "field": "consumers[].redis_stream.publication_data_mode.delta_value",
                "name": "delta_value",
                "go_name": "DeltaValue",
                "level": 4,
                "type": "string",
                "default": "centrifugo-delta",
                "comment": "DeltaValue is used to extract Publication delta flag from Redis Stream message.",
                "is_complex_type": false
              },
              {
                "field": "consumers[].redis_stream.publication_data_mode.version_value",
                "name": "version_value",
                "go_name": "VersionValue",
                "level": 4,
                "type": "string",
                "default": "centrifugo-version",
                "comment": "VersionValue is used to extract Publication version from Redis Stream message.",
                "is_complex_type": false
              },
              {
                "field": "consumers[].redis_stream.publication_data_mode.version_epoch_value",
                "name": "version_epoch_value",
                "go_name": "VersionEpochValue",
                "level": 4,
                "type": "string",
                "default": "centrifugo-version-epoch",
                "comment": "VersionEpochValue is used to extract Publication version epoch from Redis Stream message.",
                "is_complex_type": false
              },
              {
                "field": "consumers[].redis_stream.publication_data_mode.tags_value_prefix",
                "name": "tags_value_prefix",
                "go_name": "TagsValuePrefix",
                "level": 4,
                "type": "string",
                "default": "centrifugo-tag-",
                "comment": "TagsValuePrefix is used to extract Publication tags from Redis Stream message.",
                "is_complex_type": false
              }
            ]
          }
        ]
      },
      {
        "field": "consumers[].google_pub_sub",
        "name": "google_pub_sub",
        "go_name": "GooglePubSub",
        "level": 2,
        "type": "GooglePubSubConsumerConfig",
        "default": "",
        "comment": "GooglePubSub allows defining options for consumer of google_pub_sub type.",
        "is_complex_type": true,
        "children": [
          {
            "field": "consumers[].google_pub_sub.project_id",
            "name": "project_id",
            "go_name": "ProjectID",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "Google Cloud project ID.",
            "is_complex_type": false
          },
          {
            "field": "consumers[].google_pub_sub.subscriptions",
            "name": "subscriptions",
            "go_name": "Subscriptions",
            "level": 3,
            "type": "[]string",
            "default": "",
            "comment": "Subscriptions is the list of Pub/Sub subscription ids to consume from.",
            "is_complex_type": false
          },
          {
            "field": "consumers[].google_pub_sub.max_outstanding_messages",
            "name": "max_outstanding_messages",
            "go_name": "MaxOutstandingMessages",
            "level": 3,
            "type": "int",
            "default": "100",
            "comment": "MaxOutstandingMessages controls the maximum number of unprocessed messages.",
            "is_complex_type": false
          },
          {
            "field": "consumers[].google_pub_sub.max_outstanding_bytes",
            "name": "max_outstanding_bytes",
            "go_name": "MaxOutstandingBytes",
            "level": 3,
            "type": "int",
            "default": "1000000",
            "comment": "MaxOutstandingBytes controls the maximum number of unprocessed bytes.",
            "is_complex_type": false
          },
          {
            "field": "consumers[].google_pub_sub.auth_mechanism",
            "name": "auth_mechanism",
            "go_name": "AuthMechanism",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "AuthMechanism specifies which authentication mechanism to use:\n\"default\", \"service_account\".",
            "is_complex_type": false
          },
          {
            "field": "consumers[].google_pub_sub.credentials_file",
            "name": "credentials_file",
            "go_name": "CredentialsFile",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "CredentialsFile is the path to the service account JSON file if required.",
            "is_complex_type": false
          },
          {
            "field": "consumers[].google_pub_sub.method_attribute",
            "name": "method_attribute",
            "go_name": "MethodAttribute",
            "level": 3,
            "type": "string",
            "default": "centrifugo-method",
            "comment": "MethodAttribute is an attribute name to extract a method name from the message.\nIf provided in message, then payload must be just a serialized API request object.",
            "is_complex_type": false
          },
          {
            "field": "consumers[].google_pub_sub.publication_data_mode",
            "name": "publication_data_mode",
            "go_name": "PublicationDataMode",
            "level": 3,
            "type": "GooglePubSubPublicationDataModeConfig",
            "default": "",
            "comment": "PublicationDataMode holds settings for the mode where message payload already contains data\nready to publish into channels.",
            "is_complex_type": true,
            "children": [
              {
                "field": "consumers[].google_pub_sub.publication_data_mode.enabled",
                "name": "enabled",
                "go_name": "Enabled",
                "level": 4,
                "type": "bool",
                "default": "",
                "comment": "Enabled enables publication data mode.",
                "is_complex_type": false
              },
              {
                "field": "consumers[].google_pub_sub.publication_data_mode.channels_attribute",
                "name": "channels_attribute",
                "go_name": "ChannelsAttribute",
                "level": 4,
                "type": "string",
                "default": "centrifugo-channels",
                "comment": "ChannelsAttribute is the attribute name containing comma-separated channel names.",
                "is_complex_type": false
              },
              {
                "field": "consumers[].google_pub_sub.publication_data_mode.idempotency_key_attribute",
                "name": "idempotency_key_attribute",
                "go_name": "IdempotencyKeyAttribute",
                "level": 4,
                "type": "string",
                "default": "centrifugo-idempotency-key",
                "comment": "IdempotencyKeyAttribute is the attribute name for an idempotency key.",
                "is_complex_type": false
              },
              {
                "field": "consumers[].google_pub_sub.publication_data_mode.delta_attribute",
                "name": "delta_attribute",
                "go_name": "DeltaAttribute",
                "level": 4,
                "type": "string",
                "default": "centrifugo-delta",
                "comment": "DeltaAttribute is the attribute name for a delta flag.",
                "is_complex_type": false
              },
              {
                "field": "consumers[].google_pub_sub.publication_data_mode.version_attribute",
                "name": "version_attribute",
                "go_name": "VersionAttribute",
                "level": 4,
                "type": "string",
                "default": "centrifugo-version",
                "comment": "VersionAttribute is the attribute name for a version.",
                "is_complex_type": false
              },
              {
                "field": "consumers[].google_pub_sub.publication_data_mode.version_epoch_attribute",
                "name": "version_epoch_attribute",
                "go_name": "VersionEpochAttribute",
                "level": 4,
                "type": "string",
                "default": "centrifugo-version-epoch",
                "comment": "VersionEpochAttribute is the attribute name for a version epoch.",
                "is_complex_type": false
              },
              {
                "field": "consumers[].google_pub_sub.publication_data_mode.tags_attribute_prefix",
                "name": "tags_attribute_prefix",
                "go_name": "TagsAttributePrefix",
                "level": 4,
                "type": "string",
                "default": "centrifugo-tag-",
                "comment": "TagsAttributePrefix is the prefix for attributes containing tags.",
                "is_complex_type": false
              }
            ]
          }
        ]
      },
      {
        "field": "consumers[].aws_sqs",
        "name": "aws_sqs",
        "go_name": "AwsSqs",
        "level": 2,
        "type": "AwsSqsConsumerConfig",
        "default": "",
        "comment": "AwsSqs allows defining options for consumer of aws_sqs type.",
        "is_complex_type": true,
        "children": [
          {
            "field": "consumers[].aws_sqs.queues",
            "name": "queues",
            "go_name": "Queues",
            "level": 3,
            "type": "[]string",
            "default": "",
            "comment": "Queues is a list of SQS queue URLs to consume.",
            "is_complex_type": false
          },
          {
            "field": "consumers[].aws_sqs.sns_envelope",
            "name": "sns_envelope",
            "go_name": "SNSEnvelope",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "SNSEnvelope, when true, expects messages to be wrapped in an SNS envelope – this is required when\nconsuming from SNS topics with SQS subscriptions.",
            "is_complex_type": false
          },
          {
            "field": "consumers[].aws_sqs.region",
            "name": "region",
            "go_name": "Region",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "Region is the AWS region.",
            "is_complex_type": false
          },
          {
            "field": "consumers[].aws_sqs.max_number_of_messages",
            "name": "max_number_of_messages",
            "go_name": "MaxNumberOfMessages",
            "level": 3,
            "type": "int32",
            "default": "10",
            "comment": "MaxNumberOfMessages is the maximum number of messages to receive per poll.",
            "is_complex_type": false
          },
          {
            "field": "consumers[].aws_sqs.wait_time_time",
            "name": "wait_time_time",
            "go_name": "PollWaitTime",
            "level": 3,
            "type": "Duration",
            "default": "20s",
            "comment": "PollWaitTime is the long-poll wait time. Rounded to seconds internally.",
            "is_complex_type": false
          },
          {
            "field": "consumers[].aws_sqs.visibility_timeout",
            "name": "visibility_timeout",
            "go_name": "VisibilityTimeout",
            "level": 3,
            "type": "Duration",
            "default": "30s",
            "comment": "VisibilityTimeout is the time a message is hidden from other consumers. Rounded to seconds internally.",
            "is_complex_type": false
          },
          {
            "field": "consumers[].aws_sqs.max_concurrency",
            "name": "max_concurrency",
            "go_name": "MaxConcurrency",
            "level": 3,
            "type": "int",
            "default": "1",
            "comment": "MaxConcurrency defines max concurrency during message batch processing.",
            "is_complex_type": false
          },
          {
            "field": "consumers[].aws_sqs.credentials_profile",
            "name": "credentials_profile",
            "go_name": "CredentialsProfile",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "CredentialsProfile is a shared credentials profile to use.",
            "is_complex_type": false
          },
          {
            "field": "consumers[].aws_sqs.assume_role_arn",
            "name": "assume_role_arn",
            "go_name": "AssumeRoleARN",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "AssumeRoleARN, if provided, will cause the consumer to assume the given IAM role.",
            "is_complex_type": false
          },
          {
            "field": "consumers[].aws_sqs.method_attribute",
            "name": "method_attribute",
            "go_name": "MethodAttribute",
            "level": 3,
            "type": "string",
            "default": "centrifugo-method",
            "comment": "MethodAttribute is the attribute name to extract a method for command messages.\nIf provided in message, then payload must be just a serialized API request object.",
            "is_complex_type": false
          },
          {
            "field": "consumers[].aws_sqs.localstack_endpoint",
            "name": "localstack_endpoint",
            "go_name": "LocalStackEndpoint",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "LocalStackEndpoint if set enables using localstack with provided URL.",
            "is_complex_type": false
          },
          {
            "field": "consumers[].aws_sqs.publication_data_mode",
            "name": "publication_data_mode",
            "go_name": "PublicationDataMode",
            "level": 3,
            "type": "AWSPublicationDataModeConfig",
            "default": "",
            "comment": "PublicationDataMode holds settings for the mode where message payload already contains data\nready to publish into channels.",
            "is_complex_type": true,
            "children": [
              {
                "field": "consumers[].aws_sqs.publication_data_mode.enabled",
                "name": "enabled",
                "go_name": "Enabled",
                "level": 4,
                "type": "bool",
                "default": "",
                "comment": "Enabled enables publication data mode.",
                "is_complex_type": false
              },
              {
                "field": "consumers[].aws_sqs.publication_data_mode.channels_attribute",
                "name": "channels_attribute",
                "go_name": "ChannelsAttribute",
                "level": 4,
                "type": "string",
                "default": "centrifugo-channels",
                "comment": "ChannelsAttribute is the attribute name containing comma-separated channel names.",
                "is_complex_type": false
              },
              {
                "field": "consumers[].aws_sqs.publication_data_mode.idempotency_key_attribute",
                "name": "idempotency_key_attribute",
                "go_name": "IdempotencyKeyAttribute",
                "level": 4,
                "type": "string",
                "default": "centrifugo-idempotency-key",
                "comment": "IdempotencyKeyAttribute is the attribute name for an idempotency key.",
                "is_complex_type": false
              },
              {
                "field": "consumers[].aws_sqs.publication_data_mode.delta_attribute",
                "name": "delta_attribute",
                "go_name": "DeltaAttribute",
                "level": 4,
                "type": "string",
                "default": "centrifugo-delta",
                "comment": "DeltaAttribute is the attribute name for a delta flag.",
                "is_complex_type": false
              },
              {
                "field": "consumers[].aws_sqs.publication_data_mode.version_attribute",
                "name": "version_attribute",
                "go_name": "VersionAttribute",
                "level": 4,
                "type": "string",
                "default": "centrifugo-version",
                "comment": "VersionAttribute is the attribute name for a version of publication.",
                "is_complex_type": false
              },
              {
                "field": "consumers[].aws_sqs.publication_data_mode.version_epoch_attribute",
                "name": "version_epoch_attribute",
                "go_name": "VersionEpochAttribute",
                "level": 4,
                "type": "string",
                "default": "centrifugo-version-epoch",
                "comment": "VersionEpochAttribute is the attribute name for a version epoch of publication.",
                "is_complex_type": false
              },
              {
                "field": "consumers[].aws_sqs.publication_data_mode.tags_attribute_prefix",
                "name": "tags_attribute_prefix",
                "go_name": "TagsAttributePrefix",
                "level": 4,
                "type": "string",
                "default": "centrifugo-tag-",
                "comment": "TagsAttributePrefix is the prefix for attributes containing tags.",
                "is_complex_type": false
              }
            ]
          }
        ]
      },
      {
        "field": "consumers[].azure_service_bus",
        "name": "azure_service_bus",
        "go_name": "AzureServiceBus",
        "level": 2,
        "type": "AzureServiceBusConsumerConfig",
        "default": "",
        "comment": "AzureServiceBus allows defining options for consumer of azure_service_bus type.",
        "is_complex_type": true,
        "children": [
          {
            "field": "consumers[].azure_service_bus.connection_string",
            "name": "connection_string",
            "go_name": "ConnectionString",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "ConnectionString is the full connection string used for connection-string–based authentication.",
            "is_complex_type": false
          },
          {
            "field": "consumers[].azure_service_bus.use_azure_identity",
            "name": "use_azure_identity",
            "go_name": "UseAzureIdentity",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "UseAzureIdentity toggles Azure Identity (AAD) authentication instead of connection strings.",
            "is_complex_type": false
          },
          {
            "field": "consumers[].azure_service_bus.fully_qualified_namespace",
            "name": "fully_qualified_namespace",
            "go_name": "FullyQualifiedNamespace",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "FullyQualifiedNamespace is the Service Bus namespace, e.g. \"your-namespace.servicebus.windows.net\".",
            "is_complex_type": false
          },
          {
            "field": "consumers[].azure_service_bus.tenant_id",
            "name": "tenant_id",
            "go_name": "TenantID",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "TenantID is the Azure Active Directory tenant ID used with Azure Identity.",
            "is_complex_type": false
          },
          {
            "field": "consumers[].azure_service_bus.client_id",
            "name": "client_id",
            "go_name": "ClientID",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "ClientID is the Azure AD application (client) ID used for authentication.",
            "is_complex_type": false
          },
          {
            "field": "consumers[].azure_service_bus.client_secret",
            "name": "client_secret",
            "go_name": "ClientSecret",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "ClientSecret is the secret associated with the Azure AD application.",
            "is_complex_type": false
          },
          {
            "field": "consumers[].azure_service_bus.queues",
            "name": "queues",
            "go_name": "Queues",
            "level": 3,
            "type": "[]string",
            "default": "",
            "comment": "Queues is the list of the Azure Service Bus queues to consume from.",
            "is_complex_type": false
          },
          {
            "field": "consumers[].azure_service_bus.use_sessions",
            "name": "use_sessions",
            "go_name": "UseSessions",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "UseSessions enables session-aware message handling.\nAll messages must include a SessionID; messages within the same session will be processed in order.",
            "is_complex_type": false
          },
          {
            "field": "consumers[].azure_service_bus.max_concurrent_calls",
            "name": "max_concurrent_calls",
            "go_name": "MaxConcurrentCalls",
            "level": 3,
            "type": "int",
            "default": "1",
            "comment": "MaxConcurrentCalls controls the maximum number of messages processed concurrently.",
            "is_complex_type": false
          },
          {
            "field": "consumers[].azure_service_bus.max_receive_messages",
            "name": "max_receive_messages",
            "go_name": "MaxReceiveMessages",
            "level": 3,
            "type": "int",
            "default": "1",
            "comment": "MaxReceiveMessages sets the batch size when receiving messages from the queue.",
            "is_complex_type": false
          },
          {
            "field": "consumers[].azure_service_bus.method_property",
            "name": "method_property",
            "go_name": "MethodProperty",
            "level": 3,
            "type": "string",
            "default": "centrifugo-method",
            "comment": "MethodProperty is the name of the message property used to extract the method (for API command).\nIf provided in message, then payload must be just a serialized API request object.",
            "is_complex_type": false
          },
          {
            "field": "consumers[].azure_service_bus.publication_data_mode",
            "name": "publication_data_mode",
            "go_name": "PublicationDataMode",
            "level": 3,
            "type": "AzureServiceBusPublicationDataModeConfig",
            "default": "",
            "comment": "PublicationDataMode configures how structured publication-ready data is extracted from the message.",
            "is_complex_type": true,
            "children": [
              {
                "field": "consumers[].azure_service_bus.publication_data_mode.enabled",
                "name": "enabled",
                "go_name": "Enabled",
                "level": 4,
                "type": "bool",
                "default": "",
                "comment": "Enabled toggles the publication data mode.",
                "is_complex_type": false
              },
              {
                "field": "consumers[].azure_service_bus.publication_data_mode.channels_property",
                "name": "channels_property",
                "go_name": "ChannelsProperty",
                "level": 4,
                "type": "string",
                "default": "centrifugo-channels",
                "comment": "ChannelsProperty is the name of the message property that contains the list of target channels.",
                "is_complex_type": false
              },
              {
                "field": "consumers[].azure_service_bus.publication_data_mode.idempotency_key_property",
                "name": "idempotency_key_property",
                "go_name": "IdempotencyKeyProperty",
                "level": 4,
                "type": "string",
                "default": "centrifugo-idempotency-key",
                "comment": "IdempotencyKeyProperty is the property that holds an idempotency key for deduplication.",
                "is_complex_type": false
              },
              {
                "field": "consumers[].azure_service_bus.publication_data_mode.delta_property",
                "name": "delta_property",
                "go_name": "DeltaProperty",
                "level": 4,
                "type": "string",
                "default": "centrifugo-delta",
                "comment": "DeltaProperty is the property that represents changes or deltas in the payload.",
                "is_complex_type": false
              },
              {
                "field": "consumers[].azure_service_bus.publication_data_mode.version_property",
                "name": "version_property",
                "go_name": "VersionProperty",
                "level": 4,
                "type": "string",
                "default": "centrifugo-version",
                "comment": "VersionProperty is the property that holds the version of the message.",
                "is_complex_type": false
              },
              {
                "field": "consumers[].azure_service_bus.publication_data_mode.version_epoch_property",
                "name": "version_epoch_property",
                "go_name": "VersionEpochProperty",
                "level": 4,
                "type": "string",
                "default": "centrifugo-version-epoch",
                "comment": "VersionEpochProperty is the property that holds the version epoch of the message.",
                "is_complex_type": false
              },
              {
                "field": "consumers[].azure_service_bus.publication_data_mode.tags_property_prefix",
                "name": "tags_property_prefix",
                "go_name": "TagsPropertyPrefix",
                "level": 4,
                "type": "string",
                "default": "centrifugo-tag-",
                "comment": "TagsPropertyPrefix defines the prefix used to extract dynamic tags from message properties.",
                "is_complex_type": false
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "field": "websocket",
    "name": "websocket",
    "go_name": "WebSocket",
    "level": 1,
    "type": "WebSocket",
    "default": "",
    "comment": "WebSocket configuration. This transport is enabled by default.",
    "is_complex_type": true,
    "children": [
      {
        "field": "websocket.disabled",
        "name": "disabled",
        "go_name": "Disabled",
        "level": 2,
        "type": "bool",
        "default": "",
        "comment": "",
        "is_complex_type": false
      },
      {
        "field": "websocket.handler_prefix",
        "name": "handler_prefix",
        "go_name": "HandlerPrefix",
        "level": 2,
        "type": "string",
        "default": "/connection/websocket",
        "comment": "",
        "is_complex_type": false
      },
      {
        "field": "websocket.compression",
        "name": "compression",
        "go_name": "Compression",
        "level": 2,
        "type": "bool",
        "default": "",
        "comment": "",
        "is_complex_type": false
      },
      {
        "field": "websocket.compression_min_size",
        "name": "compression_min_size",
        "go_name": "CompressionMinSize",
        "level": 2,
        "type": "int",
        "default": "",
        "comment": "",
        "is_complex_type": false
      },
      {
        "field": "websocket.compression_level",
        "name": "compression_level",
        "go_name": "CompressionLevel",
        "level": 2,
        "type": "int",
        "default": "1",
        "comment": "",
        "is_complex_type": false
      },
      {
        "field": "websocket.read_buffer_size",
        "name": "read_buffer_size",
        "go_name": "ReadBufferSize",
        "level": 2,
        "type": "int",
        "default": "",
        "comment": "",
        "is_complex_type": false
      },
      {
        "field": "websocket.use_write_buffer_pool",
        "name": "use_write_buffer_pool",
        "go_name": "UseWriteBufferPool",
        "level": 2,
        "type": "bool",
        "default": "",
        "comment": "",
        "is_complex_type": false
      },
      {
        "field": "websocket.write_buffer_size",
        "name": "write_buffer_size",
        "go_name": "WriteBufferSize",
        "level": 2,
        "type": "int",
        "default": "",
        "comment": "",
        "is_complex_type": false
      },
      {
        "field": "websocket.write_timeout",
        "name": "write_timeout",
        "go_name": "WriteTimeout",
        "level": 2,
        "type": "Duration",
        "default": "1000ms",
        "comment": "",
        "is_complex_type": false
      },
      {
        "field": "websocket.message_size_limit",
        "name": "message_size_limit",
        "go_name": "MessageSizeLimit",
        "level": 2,
        "type": "int",
        "default": "65536",
        "comment": "",
        "is_complex_type": false
      }
    ]
  },
  {
    "field": "sse",
    "name": "sse",
    "go_name": "SSE",
    "level": 1,
    "type": "SSE",
    "default": "",
    "comment": "SSE is a configuration for Server-Sent Events based bidirectional emulation transport.",
    "is_complex_type": true,
    "children": [
      {
        "field": "sse.enabled",
        "name": "enabled",
        "go_name": "Enabled",
        "level": 2,
        "type": "bool",
        "default": "",
        "comment": "",
        "is_complex_type": false
      },
      {
        "field": "sse.handler_prefix",
        "name": "handler_prefix",
        "go_name": "HandlerPrefix",
        "level": 2,
        "type": "string",
        "default": "/connection/sse",
        "comment": "",
        "is_complex_type": false
      },
      {
        "field": "sse.max_request_body_size",
        "name": "max_request_body_size",
        "go_name": "MaxRequestBodySize",
        "level": 2,
        "type": "int",
        "default": "65536",
        "comment": "",
        "is_complex_type": false
      }
    ]
  },
  {
    "field": "http_stream",
    "name": "http_stream",
    "go_name": "HTTPStream",
    "level": 1,
    "type": "HTTPStream",
    "default": "",
    "comment": "HTTPStream is a configuration for HTTP streaming based bidirectional emulation transport.",
    "is_complex_type": true,
    "children": [
      {
        "field": "http_stream.enabled",
        "name": "enabled",
        "go_name": "Enabled",
        "level": 2,
        "type": "bool",
        "default": "",
        "comment": "",
        "is_complex_type": false
      },
      {
        "field": "http_stream.handler_prefix",
        "name": "handler_prefix",
        "go_name": "HandlerPrefix",
        "level": 2,
        "type": "string",
        "default": "/connection/http_stream",
        "comment": "",
        "is_complex_type": false
      },
      {
        "field": "http_stream.max_request_body_size",
        "name": "max_request_body_size",
        "go_name": "MaxRequestBodySize",
        "level": 2,
        "type": "int",
        "default": "65536",
        "comment": "",
        "is_complex_type": false
      }
    ]
  },
  {
    "field": "webtransport",
    "name": "webtransport",
    "go_name": "WebTransport",
    "level": 1,
    "type": "WebTransport",
    "default": "",
    "comment": "WebTransport is a configuration for WebTransport transport. EXPERIMENTAL.",
    "is_complex_type": true,
    "children": [
      {
        "field": "webtransport.enabled",
        "name": "enabled",
        "go_name": "Enabled",
        "level": 2,
        "type": "bool",
        "default": "",
        "comment": "",
        "is_complex_type": false
      },
      {
        "field": "webtransport.handler_prefix",
        "name": "handler_prefix",
        "go_name": "HandlerPrefix",
        "level": 2,
        "type": "string",
        "default": "/connection/webtransport",
        "comment": "",
        "is_complex_type": false
      },
      {
        "field": "webtransport.message_size_limit",
        "name": "message_size_limit",
        "go_name": "MessageSizeLimit",
        "level": 2,
        "type": "int",
        "default": "65536",
        "comment": "",
        "is_complex_type": false
      }
    ]
  },
  {
    "field": "uni_sse",
    "name": "uni_sse",
    "go_name": "UniSSE",
    "level": 1,
    "type": "UniSSE",
    "default": "",
    "comment": "UniSSE is a configuration for unidirectional Server-Sent Events transport.",
    "is_complex_type": true,
    "children": [
      {
        "field": "uni_sse.enabled",
        "name": "enabled",
        "go_name": "Enabled",
        "level": 2,
        "type": "bool",
        "default": "",
        "comment": "",
        "is_complex_type": false
      },
      {
        "field": "uni_sse.handler_prefix",
        "name": "handler_prefix",
        "go_name": "HandlerPrefix",
        "level": 2,
        "type": "string",
        "default": "/connection/uni_sse",
        "comment": "",
        "is_complex_type": false
      },
      {
        "field": "uni_sse.max_request_body_size",
        "name": "max_request_body_size",
        "go_name": "MaxRequestBodySize",
        "level": 2,
        "type": "int",
        "default": "65536",
        "comment": "",
        "is_complex_type": false
      },
      {
        "field": "uni_sse.connect_code_to_http_response",
        "name": "connect_code_to_http_response",
        "go_name": "ConnectCodeToHTTPResponse",
        "level": 2,
        "type": "ConnectCodeToHTTPResponse",
        "default": "",
        "comment": "",
        "is_complex_type": true,
        "children": [
          {
            "field": "uni_sse.connect_code_to_http_response.enabled",
            "name": "enabled",
            "go_name": "Enabled",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "",
            "is_complex_type": false
          },
          {
            "field": "uni_sse.connect_code_to_http_response.transforms",
            "name": "transforms",
            "go_name": "Transforms",
            "level": 3,
            "type": "[]ConnectCodeToHTTPResponseTransform",
            "default": "[]",
            "comment": "",
            "is_complex_type": true,
            "children": [
              {
                "field": "uni_sse.connect_code_to_http_response.transforms[].code",
                "name": "code",
                "go_name": "Code",
                "level": 4,
                "type": "uint32",
                "default": "",
                "comment": "",
                "is_complex_type": false
              },
              {
                "field": "uni_sse.connect_code_to_http_response.transforms[].to",
                "name": "to",
                "go_name": "To",
                "level": 4,
                "type": "TransformedConnectErrorHttpResponse",
                "default": "",
                "comment": "",
                "is_complex_type": true,
                "children": [
                  {
                    "field": "uni_sse.connect_code_to_http_response.transforms[].to.status_code",
                    "name": "status_code",
                    "go_name": "StatusCode",
                    "level": 5,
                    "type": "int",
                    "default": "",
                    "comment": "",
                    "is_complex_type": false
                  },
                  {
                    "field": "uni_sse.connect_code_to_http_response.transforms[].to.body",
                    "name": "body",
                    "go_name": "Body",
                    "level": 5,
                    "type": "string",
                    "default": "",
                    "comment": "",
                    "is_complex_type": false
                  }
                ]
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "field": "uni_http_stream",
    "name": "uni_http_stream",
    "go_name": "UniHTTPStream",
    "level": 1,
    "type": "UniHTTPStream",
    "default": "",
    "comment": "UniHTTPStream is a configuration for unidirectional HTTP streaming transport.",
    "is_complex_type": true,
    "children": [
      {
        "field": "uni_http_stream.enabled",
        "name": "enabled",
        "go_name": "Enabled",
        "level": 2,
        "type": "bool",
        "default": "",
        "comment": "",
        "is_complex_type": false
      },
      {
        "field": "uni_http_stream.handler_prefix",
        "name": "handler_prefix",
        "go_name": "HandlerPrefix",
        "level": 2,
        "type": "string",
        "default": "/connection/uni_http_stream",
        "comment": "",
        "is_complex_type": false
      },
      {
        "field": "uni_http_stream.max_request_body_size",
        "name": "max_request_body_size",
        "go_name": "MaxRequestBodySize",
        "level": 2,
        "type": "int",
        "default": "65536",
        "comment": "",
        "is_complex_type": false
      },
      {
        "field": "uni_http_stream.connect_code_to_http_response",
        "name": "connect_code_to_http_response",
        "go_name": "ConnectCodeToHTTPResponse",
        "level": 2,
        "type": "ConnectCodeToHTTPResponse",
        "default": "",
        "comment": "",
        "is_complex_type": true,
        "children": [
          {
            "field": "uni_http_stream.connect_code_to_http_response.enabled",
            "name": "enabled",
            "go_name": "Enabled",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "",
            "is_complex_type": false
          },
          {
            "field": "uni_http_stream.connect_code_to_http_response.transforms",
            "name": "transforms",
            "go_name": "Transforms",
            "level": 3,
            "type": "[]ConnectCodeToHTTPResponseTransform",
            "default": "[]",
            "comment": "",
            "is_complex_type": true,
            "children": [
              {
                "field": "uni_http_stream.connect_code_to_http_response.transforms[].code",
                "name": "code",
                "go_name": "Code",
                "level": 4,
                "type": "uint32",
                "default": "",
                "comment": "",
                "is_complex_type": false
              },
              {
                "field": "uni_http_stream.connect_code_to_http_response.transforms[].to",
                "name": "to",
                "go_name": "To",
                "level": 4,
                "type": "TransformedConnectErrorHttpResponse",
                "default": "",
                "comment": "",
                "is_complex_type": true,
                "children": [
                  {
                    "field": "uni_http_stream.connect_code_to_http_response.transforms[].to.status_code",
                    "name": "status_code",
                    "go_name": "StatusCode",
                    "level": 5,
                    "type": "int",
                    "default": "",
                    "comment": "",
                    "is_complex_type": false
                  },
                  {
                    "field": "uni_http_stream.connect_code_to_http_response.transforms[].to.body",
                    "name": "body",
                    "go_name": "Body",
                    "level": 5,
                    "type": "string",
                    "default": "",
                    "comment": "",
                    "is_complex_type": false
                  }
                ]
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "field": "uni_websocket",
    "name": "uni_websocket",
    "go_name": "UniWS",
    "level": 1,
    "type": "UniWebSocket",
    "default": "",
    "comment": "UniWS is a configuration for unidirectional WebSocket transport.",
    "is_complex_type": true,
    "children": [
      {
        "field": "uni_websocket.enabled",
        "name": "enabled",
        "go_name": "Enabled",
        "level": 2,
        "type": "bool",
        "default": "",
        "comment": "",
        "is_complex_type": false
      },
      {
        "field": "uni_websocket.handler_prefix",
        "name": "handler_prefix",
        "go_name": "HandlerPrefix",
        "level": 2,
        "type": "string",
        "default": "/connection/uni_websocket",
        "comment": "",
        "is_complex_type": false
      },
      {
        "field": "uni_websocket.compression",
        "name": "compression",
        "go_name": "Compression",
        "level": 2,
        "type": "bool",
        "default": "",
        "comment": "",
        "is_complex_type": false
      },
      {
        "field": "uni_websocket.compression_min_size",
        "name": "compression_min_size",
        "go_name": "CompressionMinSize",
        "level": 2,
        "type": "int",
        "default": "",
        "comment": "",
        "is_complex_type": false
      },
      {
        "field": "uni_websocket.compression_level",
        "name": "compression_level",
        "go_name": "CompressionLevel",
        "level": 2,
        "type": "int",
        "default": "1",
        "comment": "",
        "is_complex_type": false
      },
      {
        "field": "uni_websocket.read_buffer_size",
        "name": "read_buffer_size",
        "go_name": "ReadBufferSize",
        "level": 2,
        "type": "int",
        "default": "",
        "comment": "",
        "is_complex_type": false
      },
      {
        "field": "uni_websocket.use_write_buffer_pool",
        "name": "use_write_buffer_pool",
        "go_name": "UseWriteBufferPool",
        "level": 2,
        "type": "bool",
        "default": "",
        "comment": "",
        "is_complex_type": false
      },
      {
        "field": "uni_websocket.write_buffer_size",
        "name": "write_buffer_size",
        "go_name": "WriteBufferSize",
        "level": 2,
        "type": "int",
        "default": "",
        "comment": "",
        "is_complex_type": false
      },
      {
        "field": "uni_websocket.write_timeout",
        "name": "write_timeout",
        "go_name": "WriteTimeout",
        "level": 2,
        "type": "Duration",
        "default": "1000ms",
        "comment": "",
        "is_complex_type": false
      },
      {
        "field": "uni_websocket.message_size_limit",
        "name": "message_size_limit",
        "go_name": "MessageSizeLimit",
        "level": 2,
        "type": "int",
        "default": "65536",
        "comment": "",
        "is_complex_type": false
      },
      {
        "field": "uni_websocket.join_push_messages",
        "name": "join_push_messages",
        "go_name": "JoinPushMessages",
        "level": 2,
        "type": "bool",
        "default": "",
        "comment": "JoinPushMessages when enabled allow uni_websocket transport to join messages together into\none frame using Centrifugal client protocol delimiters: new line for JSON protocol and\nlength-prefixed format for Protobuf protocol. This can be useful to reduce system call\noverhead when sending many small messages. The client side must be ready to handle such\njoined messages coming in one WebSocket frame.",
        "is_complex_type": false
      }
    ]
  },
  {
    "field": "uni_grpc",
    "name": "uni_grpc",
    "go_name": "UniGRPC",
    "level": 1,
    "type": "UniGRPC",
    "default": "",
    "comment": "UniGRPC is a configuration for unidirectional gRPC transport.",
    "is_complex_type": true,
    "children": [
      {
        "field": "uni_grpc.enabled",
        "name": "enabled",
        "go_name": "Enabled",
        "level": 2,
        "type": "bool",
        "default": "",
        "comment": "",
        "is_complex_type": false
      },
      {
        "field": "uni_grpc.address",
        "name": "address",
        "go_name": "Address",
        "level": 2,
        "type": "string",
        "default": "",
        "comment": "",
        "is_complex_type": false
      },
      {
        "field": "uni_grpc.port",
        "name": "port",
        "go_name": "Port",
        "level": 2,
        "type": "int",
        "default": "11000",
        "comment": "",
        "is_complex_type": false
      },
      {
        "field": "uni_grpc.max_receive_message_size",
        "name": "max_receive_message_size",
        "go_name": "MaxReceiveMessageSize",
        "level": 2,
        "type": "int",
        "default": "",
        "comment": "",
        "is_complex_type": false
      },
      {
        "field": "uni_grpc.tls",
        "name": "tls",
        "go_name": "TLS",
        "level": 2,
        "type": "TLSConfig",
        "default": "",
        "comment": "",
        "is_complex_type": true,
        "children": [
          {
            "field": "uni_grpc.tls.enabled",
            "name": "enabled",
            "go_name": "Enabled",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "Enabled turns on using TLS.",
            "is_complex_type": false
          },
          {
            "field": "uni_grpc.tls.cert_pem",
            "name": "cert_pem",
            "go_name": "CertPem",
            "level": 3,
            "type": "PEMData",
            "default": "",
            "comment": "CertPem is a PEM certificate.",
            "is_complex_type": false
          },
          {
            "field": "uni_grpc.tls.key_pem",
            "name": "key_pem",
            "go_name": "KeyPem",
            "level": 3,
            "type": "PEMData",
            "default": "",
            "comment": "KeyPem is a path to a file with key in PEM format.",
            "is_complex_type": false
          },
          {
            "field": "uni_grpc.tls.server_ca_pem",
            "name": "server_ca_pem",
            "go_name": "ServerCAPem",
            "level": 3,
            "type": "PEMData",
            "default": "",
            "comment": "ServerCAPem is a server root CA certificate in PEM format.\nThe client uses this certificate to verify the server's certificate during the TLS handshake.",
            "is_complex_type": false
          },
          {
            "field": "uni_grpc.tls.client_ca_pem",
            "name": "client_ca_pem",
            "go_name": "ClientCAPem",
            "level": 3,
            "type": "PEMData",
            "default": "",
            "comment": "ClientCAPem is a client CA certificate in PEM format.\nThe server uses this certificate to verify the client's certificate during the TLS handshake.",
            "is_complex_type": false
          },
          {
            "field": "uni_grpc.tls.insecure_skip_verify",
            "name": "insecure_skip_verify",
            "go_name": "InsecureSkipVerify",
            "level": 3,
            "type": "bool",
            "default": "",
            "comment": "InsecureSkipVerify turns off server certificate verification.",
            "is_complex_type": false
          },
          {
            "field": "uni_grpc.tls.server_name",
            "name": "server_name",
            "go_name": "ServerName",
            "level": 3,
            "type": "string",
            "default": "",
            "comment": "ServerName is used to verify the hostname on the returned certificates.",
            "is_complex_type": false
          }
        ]
      }
    ]
  },
  {
    "field": "emulation",
    "name": "emulation",
    "go_name": "Emulation",
    "level": 1,
    "type": "Emulation",
    "default": "",
    "comment": "Emulation endpoint is enabled automatically when at least one bidirectional emulation transport\nis configured (SSE or HTTP Stream).",
    "is_complex_type": true,
    "children": [
      {
        "field": "emulation.handler_prefix",
        "name": "handler_prefix",
        "go_name": "HandlerPrefix",
        "level": 2,
        "type": "string",
        "default": "/emulation",
        "comment": "",
        "is_complex_type": false
      },
      {
        "field": "emulation.max_request_body_size",
        "name": "max_request_body_size",
        "go_name": "MaxRequestBodySize",
        "level": 2,
        "type": "int",
        "default": "65536",
        "comment": "",
        "is_complex_type": false
      }
    ]
  },
  {
    "field": "admin",
    "name": "admin",
    "go_name": "Admin",
    "level": 1,
    "type": "Admin",
    "default": "",
    "comment": "Admin web UI configuration.",
    "is_complex_type": true,
    "children": [
      {
        "field": "admin.enabled",
        "name": "enabled",
        "go_name": "Enabled",
        "level": 2,
        "type": "bool",
        "default": "",
        "comment": "",
        "is_complex_type": false
      },
      {
        "field": "admin.handler_prefix",
        "name": "handler_prefix",
        "go_name": "HandlerPrefix",
        "level": 2,
        "type": "string",
        "default": "",
        "comment": "",
        "is_complex_type": false
      },
      {
        "field": "admin.password",
        "name": "password",
        "go_name": "Password",
        "level": 2,
        "type": "string",
        "default": "",
        "comment": "Password is an admin password.",
        "is_complex_type": false
      },
      {
        "field": "admin.secret",
        "name": "secret",
        "go_name": "Secret",
        "level": 2,
        "type": "string",
        "default": "",
        "comment": "Secret is a secret to generate auth token for admin requests.",
        "is_complex_type": false
      },
      {
        "field": "admin.insecure",
        "name": "insecure",
        "go_name": "Insecure",
        "level": 2,
        "type": "bool",
        "default": "",
        "comment": "Insecure turns on insecure mode for admin endpoints - no auth\nrequired to connect to web interface and for requests to admin API.\nAdmin resources must be protected by firewall rules in production when\nthis option enabled otherwise everyone from internet can make admin\nactions.",
        "is_complex_type": false
      },
      {
        "field": "admin.web_path",
        "name": "web_path",
        "go_name": "WebPath",
        "level": 2,
        "type": "string",
        "default": "",
        "comment": "WebPath is path to admin web application to serve.",
        "is_complex_type": false
      },
      {
        "field": "admin.web_proxy_address",
        "name": "web_proxy_address",
        "go_name": "WebProxyAddress",
        "level": 2,
        "type": "string",
        "default": "",
        "comment": "WebProxyAddress is an address for proxying to the running admin web application app.\nSo it's possible to run web app in dev mode and point Centrifugo to its address for\ndevelopment purposes.",
        "is_complex_type": false
      },
      {
        "field": "admin.external",
        "name": "external",
        "go_name": "External",
        "level": 2,
        "type": "bool",
        "default": "",
        "comment": "External is a flag to run admin interface on external port.",
        "is_complex_type": false
      }
    ]
  },
  {
    "field": "prometheus",
    "name": "prometheus",
    "go_name": "Prometheus",
    "level": 1,
    "type": "Prometheus",
    "default": "",
    "comment": "Prometheus metrics configuration.",
    "is_complex_type": true,
    "children": [
      {
        "field": "prometheus.enabled",
        "name": "enabled",
        "go_name": "Enabled",
        "level": 2,
        "type": "bool",
        "default": "",
        "comment": "",
        "is_complex_type": false
      },
      {
        "field": "prometheus.handler_prefix",
        "name": "handler_prefix",
        "go_name": "HandlerPrefix",
        "level": 2,
        "type": "string",
        "default": "/metrics",
        "comment": "",
        "is_complex_type": false
      },
      {
        "field": "prometheus.instrument_http_handlers",
        "name": "instrument_http_handlers",
        "go_name": "InstrumentHTTPHandlers",
        "level": 2,
        "type": "bool",
        "default": "",
        "comment": "InstrumentHTTPHandlers enables additional instrumentation of HTTP handlers\n(extra middleware to track status codes). Optional since adds some overhead.",
        "is_complex_type": false
      },
      {
        "field": "prometheus.recovered_publications_histogram",
        "name": "recovered_publications_histogram",
        "go_name": "RecoveredPublicationsHistogram",
        "level": 2,
        "type": "bool",
        "default": "",
        "comment": "RecoveredPublicationsHistogram enables a histogram to track the distribution of recovered publications number.",
        "is_complex_type": false
      }
    ]
  },
  {
    "field": "health",
    "name": "health",
    "go_name": "Health",
    "level": 1,
    "type": "Health",
    "default": "",
    "comment": "Health check endpoint configuration.",
    "is_complex_type": true,
    "children": [
      {
        "field": "health.enabled",
        "name": "enabled",
        "go_name": "Enabled",
        "level": 2,
        "type": "bool",
        "default": "",
        "comment": "",
        "is_complex_type": false
      },
      {
        "field": "health.handler_prefix",
        "name": "handler_prefix",
        "go_name": "HandlerPrefix",
        "level": 2,
        "type": "string",
        "default": "/health",
        "comment": "",
        "is_complex_type": false
      }
    ]
  },
  {
    "field": "swagger",
    "name": "swagger",
    "go_name": "Swagger",
    "level": 1,
    "type": "Swagger",
    "default": "",
    "comment": "Swagger documentation (for server HTTP API) configuration.",
    "is_complex_type": true,
    "children": [
      {
        "field": "swagger.enabled",
        "name": "enabled",
        "go_name": "Enabled",
        "level": 2,
        "type": "bool",
        "default": "",
        "comment": "",
        "is_complex_type": false
      },
      {
        "field": "swagger.handler_prefix",
        "name": "handler_prefix",
        "go_name": "HandlerPrefix",
        "level": 2,
        "type": "string",
        "default": "/swagger",
        "comment": "",
        "is_complex_type": false
      }
    ]
  },
  {
    "field": "debug",
    "name": "debug",
    "go_name": "Debug",
    "level": 1,
    "type": "Debug",
    "default": "",
    "comment": "Debug helps to enable Go profiling endpoints.",
    "is_complex_type": true,
    "children": [
      {
        "field": "debug.enabled",
        "name": "enabled",
        "go_name": "Enabled",
        "level": 2,
        "type": "bool",
        "default": "",
        "comment": "",
        "is_complex_type": false
      },
      {
        "field": "debug.handler_prefix",
        "name": "handler_prefix",
        "go_name": "HandlerPrefix",
        "level": 2,
        "type": "string",
        "default": "/debug/pprof",
        "comment": "",
        "is_complex_type": false
      }
    ]
  },
  {
    "field": "opentelemetry",
    "name": "opentelemetry",
    "go_name": "OpenTelemetry",
    "level": 1,
    "type": "OpenTelemetry",
    "default": "",
    "comment": "OpenTelemetry is a configuration for OpenTelemetry tracing.",
    "is_complex_type": true,
    "children": [
      {
        "field": "opentelemetry.enabled",
        "name": "enabled",
        "go_name": "Enabled",
        "level": 2,
        "type": "bool",
        "default": "",
        "comment": "",
        "is_complex_type": false
      },
      {
        "field": "opentelemetry.api",
        "name": "api",
        "go_name": "API",
        "level": 2,
        "type": "bool",
        "default": "",
        "comment": "",
        "is_complex_type": false
      },
      {
        "field": "opentelemetry.consuming",
        "name": "consuming",
        "go_name": "Consuming",
        "level": 2,
        "type": "bool",
        "default": "",
        "comment": "",
        "is_complex_type": false
      }
    ]
  },
  {
    "field": "graphite",
    "name": "graphite",
    "go_name": "Graphite",
    "level": 1,
    "type": "Graphite",
    "default": "",
    "comment": "Graphite is a configuration for export metrics to Graphite.",
    "is_complex_type": true,
    "children": [
      {
        "field": "graphite.enabled",
        "name": "enabled",
        "go_name": "Enabled",
        "level": 2,
        "type": "bool",
        "default": "",
        "comment": "",
        "is_complex_type": false
      },
      {
        "field": "graphite.host",
        "name": "host",
        "go_name": "Host",
        "level": 2,
        "type": "string",
        "default": "localhost",
        "comment": "",
        "is_complex_type": false
      },
      {
        "field": "graphite.port",
        "name": "port",
        "go_name": "Port",
        "level": 2,
        "type": "int",
        "default": "2003",
        "comment": "",
        "is_complex_type": false
      },
      {
        "field": "graphite.prefix",
        "name": "prefix",
        "go_name": "Prefix",
        "level": 2,
        "type": "string",
        "default": "centrifugo",
        "comment": "",
        "is_complex_type": false
      },
      {
        "field": "graphite.interval",
        "name": "interval",
        "go_name": "Interval",
        "level": 2,
        "type": "Duration",
        "default": "10s",
        "comment": "",
        "is_complex_type": false
      },
      {
        "field": "graphite.tags",
        "name": "tags",
        "go_name": "Tags",
        "level": 2,
        "type": "bool",
        "default": "",
        "comment": "",
        "is_complex_type": false
      }
    ]
  },
  {
    "field": "usage_stats",
    "name": "usage_stats",
    "go_name": "UsageStats",
    "level": 1,
    "type": "UsageStats",
    "default": "",
    "comment": "UsageStats is a configuration for usage stats sending.",
    "is_complex_type": true,
    "children": [
      {
        "field": "usage_stats.disabled",
        "name": "disabled",
        "go_name": "Disabled",
        "level": 2,
        "type": "bool",
        "default": "",
        "comment": "",
        "is_complex_type": false
      }
    ]
  },
  {
    "field": "node",
    "name": "node",
    "go_name": "Node",
    "level": 1,
    "type": "Node",
    "default": "",
    "comment": "Node is a configuration for Centrifugo Node as part of cluster.",
    "is_complex_type": true,
    "children": [
      {
        "field": "node.name",
        "name": "name",
        "go_name": "Name",
        "level": 2,
        "type": "string",
        "default": "",
        "comment": "Name is a human-readable name of Centrifugo node in cluster. This must be unique for each running node\nin a cluster. By default, Centrifugo constructs name from the hostname and port. Name is shown in admin web\ninterface. For communication between nodes in a cluster, Centrifugo uses another identifier – unique ID\ngenerated on node start, so node name plays just a human-readable identifier role.",
        "is_complex_type": false
      },
      {
        "field": "node.info_metrics_aggregate_interval",
        "name": "info_metrics_aggregate_interval",
        "go_name": "InfoMetricsAggregateInterval",
        "level": 2,
        "type": "Duration",
        "default": "60s",
        "comment": "InfoMetricsAggregateInterval is a time interval to aggregate node info metrics.",
        "is_complex_type": false
      }
    ]
  },
  {
    "field": "shutdown",
    "name": "shutdown",
    "go_name": "Shutdown",
    "level": 1,
    "type": "Shutdown",
    "default": "",
    "comment": "Shutdown is a configuration for graceful shutdown.",
    "is_complex_type": true,
    "children": [
      {
        "field": "shutdown.timeout",
        "name": "timeout",
        "go_name": "Timeout",
        "level": 2,
        "type": "Duration",
        "default": "30s",
        "comment": "",
        "is_complex_type": false
      }
    ]
  },
  {
    "field": "pid_file",
    "name": "pid_file",
    "go_name": "PidFile",
    "level": 1,
    "type": "string",
    "default": "",
    "comment": "PidFile is a path to write a file with Centrifugo process PID.",
    "is_complex_type": false
  },
  {
    "field": "enable_unreleased_features",
    "name": "enable_unreleased_features",
    "go_name": "EnableUnreleasedFeatures",
    "level": 1,
    "type": "bool",
    "default": "",
    "comment": "EnableUnreleasedFeatures enables unreleased features. These features are not stable and may be removed even\nin minor release update. Evaluate and share feedback if you find some feature useful and want it to be stabilized.",
    "is_complex_type": false
  }
]
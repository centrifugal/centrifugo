// Code generated by internal/gen/api/main.go. DO NOT EDIT.

package api

import (
	"io"
	"net/http"

	. "github.com/centrifugal/centrifugo/v6/internal/apiproto"

	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/trace"
)

func (s *Handler) handleBatch(w http.ResponseWriter, r *http.Request) {
	data, err := io.ReadAll(r.Body)
	if err != nil {
		incErrorStringCode(s.api.config.Protocol, "batch", "read_body")
		s.handleReadDataError(r, w, err)
		return
	}

	req, err := paramsDecoder.DecodeBatch(data)
	if err != nil {
		incErrorStringCode(s.api.config.Protocol, "batch", "unmarshal")
		s.handleUnmarshalError(r, w, err)
		return
	}

	resp := s.api.Batch(r.Context(), req)

	data, err = responseEncoder.EncodeBatch(resp)
	if err != nil {
		incErrorStringCode(s.api.config.Protocol, "batch", "marshal")
		s.handleMarshalError(r, w, err)
		return
	}

	s.writeJson(w, data)
}

func (s *Handler) handlePublish(w http.ResponseWriter, r *http.Request) {
	data, err := io.ReadAll(r.Body)
	if err != nil {
		incErrorStringCode(s.api.config.Protocol, "publish", "read_body")
		s.handleReadDataError(r, w, err)
		return
	}

	req, err := paramsDecoder.DecodePublish(data)
	if err != nil {
		incErrorStringCode(s.api.config.Protocol, "publish", "unmarshal")
		s.handleUnmarshalError(r, w, err)
		return
	}

	resp := s.api.Publish(r.Context(), req)
	if s.config.UseOpenTelemetry && resp.Error != nil {
		span := trace.SpanFromContext(r.Context())
		span.SetStatus(codes.Error, resp.Error.Error())
	}

	if resp.Error != nil && s.useTransportErrorMode(r) {
		incError(s.api.config.Protocol, "publish", resp.Error.Code)
		statusCode := MapErrorToHTTPCode(resp.Error)
		data, _ = EncodeError(resp.Error)
		s.writeJsonCustomStatus(w, statusCode, data)
		return
	}

	data, err = responseEncoder.EncodePublish(resp)
	if err != nil {
		incErrorStringCode(s.api.config.Protocol, "publish", "marshal")
		s.handleMarshalError(r, w, err)
		return
	}
	if resp.Error != nil {
		incError(s.api.config.Protocol, "publish", resp.Error.Code)
	}

	s.writeJson(w, data)
}

func (s *Handler) handleBroadcast(w http.ResponseWriter, r *http.Request) {
	data, err := io.ReadAll(r.Body)
	if err != nil {
		incErrorStringCode(s.api.config.Protocol, "broadcast", "read_body")
		s.handleReadDataError(r, w, err)
		return
	}

	req, err := paramsDecoder.DecodeBroadcast(data)
	if err != nil {
		incErrorStringCode(s.api.config.Protocol, "broadcast", "unmarshal")
		s.handleUnmarshalError(r, w, err)
		return
	}

	resp := s.api.Broadcast(r.Context(), req)
	if s.config.UseOpenTelemetry && resp.Error != nil {
		span := trace.SpanFromContext(r.Context())
		span.SetStatus(codes.Error, resp.Error.Error())
	}

	if resp.Error != nil && s.useTransportErrorMode(r) {
		incError(s.api.config.Protocol, "broadcast", resp.Error.Code)
		statusCode := MapErrorToHTTPCode(resp.Error)
		data, _ = EncodeError(resp.Error)
		s.writeJsonCustomStatus(w, statusCode, data)
		return
	}

	data, err = responseEncoder.EncodeBroadcast(resp)
	if err != nil {
		incErrorStringCode(s.api.config.Protocol, "broadcast", "marshal")
		s.handleMarshalError(r, w, err)
		return
	}
	if resp.Error != nil {
		incError(s.api.config.Protocol, "broadcast", resp.Error.Code)
	}

	s.writeJson(w, data)
}

func (s *Handler) handleSubscribe(w http.ResponseWriter, r *http.Request) {
	data, err := io.ReadAll(r.Body)
	if err != nil {
		incErrorStringCode(s.api.config.Protocol, "subscribe", "read_body")
		s.handleReadDataError(r, w, err)
		return
	}

	req, err := paramsDecoder.DecodeSubscribe(data)
	if err != nil {
		incErrorStringCode(s.api.config.Protocol, "subscribe", "unmarshal")
		s.handleUnmarshalError(r, w, err)
		return
	}

	resp := s.api.Subscribe(r.Context(), req)
	if s.config.UseOpenTelemetry && resp.Error != nil {
		span := trace.SpanFromContext(r.Context())
		span.SetStatus(codes.Error, resp.Error.Error())
	}

	if resp.Error != nil && s.useTransportErrorMode(r) {
		incError(s.api.config.Protocol, "subscribe", resp.Error.Code)
		statusCode := MapErrorToHTTPCode(resp.Error)
		data, _ = EncodeError(resp.Error)
		s.writeJsonCustomStatus(w, statusCode, data)
		return
	}

	data, err = responseEncoder.EncodeSubscribe(resp)
	if err != nil {
		incErrorStringCode(s.api.config.Protocol, "subscribe", "marshal")
		s.handleMarshalError(r, w, err)
		return
	}
	if resp.Error != nil {
		incError(s.api.config.Protocol, "subscribe", resp.Error.Code)
	}

	s.writeJson(w, data)
}

func (s *Handler) handleUnsubscribe(w http.ResponseWriter, r *http.Request) {
	data, err := io.ReadAll(r.Body)
	if err != nil {
		incErrorStringCode(s.api.config.Protocol, "unsubscribe", "read_body")
		s.handleReadDataError(r, w, err)
		return
	}

	req, err := paramsDecoder.DecodeUnsubscribe(data)
	if err != nil {
		incErrorStringCode(s.api.config.Protocol, "unsubscribe", "unmarshal")
		s.handleUnmarshalError(r, w, err)
		return
	}

	resp := s.api.Unsubscribe(r.Context(), req)
	if s.config.UseOpenTelemetry && resp.Error != nil {
		span := trace.SpanFromContext(r.Context())
		span.SetStatus(codes.Error, resp.Error.Error())
	}

	if resp.Error != nil && s.useTransportErrorMode(r) {
		incError(s.api.config.Protocol, "unsubscribe", resp.Error.Code)
		statusCode := MapErrorToHTTPCode(resp.Error)
		data, _ = EncodeError(resp.Error)
		s.writeJsonCustomStatus(w, statusCode, data)
		return
	}

	data, err = responseEncoder.EncodeUnsubscribe(resp)
	if err != nil {
		incErrorStringCode(s.api.config.Protocol, "unsubscribe", "marshal")
		s.handleMarshalError(r, w, err)
		return
	}
	if resp.Error != nil {
		incError(s.api.config.Protocol, "unsubscribe", resp.Error.Code)
	}

	s.writeJson(w, data)
}

func (s *Handler) handleDisconnect(w http.ResponseWriter, r *http.Request) {
	data, err := io.ReadAll(r.Body)
	if err != nil {
		incErrorStringCode(s.api.config.Protocol, "disconnect", "read_body")
		s.handleReadDataError(r, w, err)
		return
	}

	req, err := paramsDecoder.DecodeDisconnect(data)
	if err != nil {
		incErrorStringCode(s.api.config.Protocol, "disconnect", "unmarshal")
		s.handleUnmarshalError(r, w, err)
		return
	}

	resp := s.api.Disconnect(r.Context(), req)
	if s.config.UseOpenTelemetry && resp.Error != nil {
		span := trace.SpanFromContext(r.Context())
		span.SetStatus(codes.Error, resp.Error.Error())
	}

	if resp.Error != nil && s.useTransportErrorMode(r) {
		incError(s.api.config.Protocol, "disconnect", resp.Error.Code)
		statusCode := MapErrorToHTTPCode(resp.Error)
		data, _ = EncodeError(resp.Error)
		s.writeJsonCustomStatus(w, statusCode, data)
		return
	}

	data, err = responseEncoder.EncodeDisconnect(resp)
	if err != nil {
		incErrorStringCode(s.api.config.Protocol, "disconnect", "marshal")
		s.handleMarshalError(r, w, err)
		return
	}
	if resp.Error != nil {
		incError(s.api.config.Protocol, "disconnect", resp.Error.Code)
	}

	s.writeJson(w, data)
}

func (s *Handler) handlePresence(w http.ResponseWriter, r *http.Request) {
	data, err := io.ReadAll(r.Body)
	if err != nil {
		incErrorStringCode(s.api.config.Protocol, "presence", "read_body")
		s.handleReadDataError(r, w, err)
		return
	}

	req, err := paramsDecoder.DecodePresence(data)
	if err != nil {
		incErrorStringCode(s.api.config.Protocol, "presence", "unmarshal")
		s.handleUnmarshalError(r, w, err)
		return
	}

	resp := s.api.Presence(r.Context(), req)
	if s.config.UseOpenTelemetry && resp.Error != nil {
		span := trace.SpanFromContext(r.Context())
		span.SetStatus(codes.Error, resp.Error.Error())
	}

	if resp.Error != nil && s.useTransportErrorMode(r) {
		incError(s.api.config.Protocol, "presence", resp.Error.Code)
		statusCode := MapErrorToHTTPCode(resp.Error)
		data, _ = EncodeError(resp.Error)
		s.writeJsonCustomStatus(w, statusCode, data)
		return
	}

	data, err = responseEncoder.EncodePresence(resp)
	if err != nil {
		incErrorStringCode(s.api.config.Protocol, "presence", "marshal")
		s.handleMarshalError(r, w, err)
		return
	}
	if resp.Error != nil {
		incError(s.api.config.Protocol, "presence", resp.Error.Code)
	}

	s.writeJson(w, data)
}

func (s *Handler) handlePresenceStats(w http.ResponseWriter, r *http.Request) {
	data, err := io.ReadAll(r.Body)
	if err != nil {
		incErrorStringCode(s.api.config.Protocol, "presence_stats", "read_body")
		s.handleReadDataError(r, w, err)
		return
	}

	req, err := paramsDecoder.DecodePresenceStats(data)
	if err != nil {
		incErrorStringCode(s.api.config.Protocol, "presence_stats", "unmarshal")
		s.handleUnmarshalError(r, w, err)
		return
	}

	resp := s.api.PresenceStats(r.Context(), req)
	if s.config.UseOpenTelemetry && resp.Error != nil {
		span := trace.SpanFromContext(r.Context())
		span.SetStatus(codes.Error, resp.Error.Error())
	}

	if resp.Error != nil && s.useTransportErrorMode(r) {
		incError(s.api.config.Protocol, "presence_stats", resp.Error.Code)
		statusCode := MapErrorToHTTPCode(resp.Error)
		data, _ = EncodeError(resp.Error)
		s.writeJsonCustomStatus(w, statusCode, data)
		return
	}

	data, err = responseEncoder.EncodePresenceStats(resp)
	if err != nil {
		incErrorStringCode(s.api.config.Protocol, "presence_stats", "marshal")
		s.handleMarshalError(r, w, err)
		return
	}
	if resp.Error != nil {
		incError(s.api.config.Protocol, "presence_stats", resp.Error.Code)
	}

	s.writeJson(w, data)
}

func (s *Handler) handleHistory(w http.ResponseWriter, r *http.Request) {
	data, err := io.ReadAll(r.Body)
	if err != nil {
		incErrorStringCode(s.api.config.Protocol, "history", "read_body")
		s.handleReadDataError(r, w, err)
		return
	}

	req, err := paramsDecoder.DecodeHistory(data)
	if err != nil {
		incErrorStringCode(s.api.config.Protocol, "history", "unmarshal")
		s.handleUnmarshalError(r, w, err)
		return
	}

	resp := s.api.History(r.Context(), req)
	if s.config.UseOpenTelemetry && resp.Error != nil {
		span := trace.SpanFromContext(r.Context())
		span.SetStatus(codes.Error, resp.Error.Error())
	}

	if resp.Error != nil && s.useTransportErrorMode(r) {
		incError(s.api.config.Protocol, "history", resp.Error.Code)
		statusCode := MapErrorToHTTPCode(resp.Error)
		data, _ = EncodeError(resp.Error)
		s.writeJsonCustomStatus(w, statusCode, data)
		return
	}

	data, err = responseEncoder.EncodeHistory(resp)
	if err != nil {
		incErrorStringCode(s.api.config.Protocol, "history", "marshal")
		s.handleMarshalError(r, w, err)
		return
	}
	if resp.Error != nil {
		incError(s.api.config.Protocol, "history", resp.Error.Code)
	}

	s.writeJson(w, data)
}

func (s *Handler) handleHistoryRemove(w http.ResponseWriter, r *http.Request) {
	data, err := io.ReadAll(r.Body)
	if err != nil {
		incErrorStringCode(s.api.config.Protocol, "history_remove", "read_body")
		s.handleReadDataError(r, w, err)
		return
	}

	req, err := paramsDecoder.DecodeHistoryRemove(data)
	if err != nil {
		incErrorStringCode(s.api.config.Protocol, "history_remove", "unmarshal")
		s.handleUnmarshalError(r, w, err)
		return
	}

	resp := s.api.HistoryRemove(r.Context(), req)
	if s.config.UseOpenTelemetry && resp.Error != nil {
		span := trace.SpanFromContext(r.Context())
		span.SetStatus(codes.Error, resp.Error.Error())
	}

	if resp.Error != nil && s.useTransportErrorMode(r) {
		incError(s.api.config.Protocol, "history_remove", resp.Error.Code)
		statusCode := MapErrorToHTTPCode(resp.Error)
		data, _ = EncodeError(resp.Error)
		s.writeJsonCustomStatus(w, statusCode, data)
		return
	}

	data, err = responseEncoder.EncodeHistoryRemove(resp)
	if err != nil {
		incErrorStringCode(s.api.config.Protocol, "history_remove", "marshal")
		s.handleMarshalError(r, w, err)
		return
	}
	if resp.Error != nil {
		incError(s.api.config.Protocol, "history_remove", resp.Error.Code)
	}

	s.writeJson(w, data)
}

func (s *Handler) handleInfo(w http.ResponseWriter, r *http.Request) {
	data, err := io.ReadAll(r.Body)
	if err != nil {
		incErrorStringCode(s.api.config.Protocol, "info", "read_body")
		s.handleReadDataError(r, w, err)
		return
	}

	req, err := paramsDecoder.DecodeInfo(data)
	if err != nil {
		incErrorStringCode(s.api.config.Protocol, "info", "unmarshal")
		s.handleUnmarshalError(r, w, err)
		return
	}

	resp := s.api.Info(r.Context(), req)
	if s.config.UseOpenTelemetry && resp.Error != nil {
		span := trace.SpanFromContext(r.Context())
		span.SetStatus(codes.Error, resp.Error.Error())
	}

	if resp.Error != nil && s.useTransportErrorMode(r) {
		incError(s.api.config.Protocol, "info", resp.Error.Code)
		statusCode := MapErrorToHTTPCode(resp.Error)
		data, _ = EncodeError(resp.Error)
		s.writeJsonCustomStatus(w, statusCode, data)
		return
	}

	data, err = responseEncoder.EncodeInfo(resp)
	if err != nil {
		incErrorStringCode(s.api.config.Protocol, "info", "marshal")
		s.handleMarshalError(r, w, err)
		return
	}
	if resp.Error != nil {
		incError(s.api.config.Protocol, "info", resp.Error.Code)
	}

	s.writeJson(w, data)
}

func (s *Handler) handleRPC(w http.ResponseWriter, r *http.Request) {
	data, err := io.ReadAll(r.Body)
	if err != nil {
		incErrorStringCode(s.api.config.Protocol, "rpc", "read_body")
		s.handleReadDataError(r, w, err)
		return
	}

	req, err := paramsDecoder.DecodeRPC(data)
	if err != nil {
		incErrorStringCode(s.api.config.Protocol, "rpc", "unmarshal")
		s.handleUnmarshalError(r, w, err)
		return
	}

	resp := s.api.RPC(r.Context(), req)
	if s.config.UseOpenTelemetry && resp.Error != nil {
		span := trace.SpanFromContext(r.Context())
		span.SetStatus(codes.Error, resp.Error.Error())
	}

	if resp.Error != nil && s.useTransportErrorMode(r) {
		incError(s.api.config.Protocol, "rpc", resp.Error.Code)
		statusCode := MapErrorToHTTPCode(resp.Error)
		data, _ = EncodeError(resp.Error)
		s.writeJsonCustomStatus(w, statusCode, data)
		return
	}

	data, err = responseEncoder.EncodeRPC(resp)
	if err != nil {
		incErrorStringCode(s.api.config.Protocol, "rpc", "marshal")
		s.handleMarshalError(r, w, err)
		return
	}
	if resp.Error != nil {
		incError(s.api.config.Protocol, "rpc", resp.Error.Code)
	}

	s.writeJson(w, data)
}

func (s *Handler) handleRefresh(w http.ResponseWriter, r *http.Request) {
	data, err := io.ReadAll(r.Body)
	if err != nil {
		incErrorStringCode(s.api.config.Protocol, "refresh", "read_body")
		s.handleReadDataError(r, w, err)
		return
	}

	req, err := paramsDecoder.DecodeRefresh(data)
	if err != nil {
		incErrorStringCode(s.api.config.Protocol, "refresh", "unmarshal")
		s.handleUnmarshalError(r, w, err)
		return
	}

	resp := s.api.Refresh(r.Context(), req)
	if s.config.UseOpenTelemetry && resp.Error != nil {
		span := trace.SpanFromContext(r.Context())
		span.SetStatus(codes.Error, resp.Error.Error())
	}

	if resp.Error != nil && s.useTransportErrorMode(r) {
		incError(s.api.config.Protocol, "refresh", resp.Error.Code)
		statusCode := MapErrorToHTTPCode(resp.Error)
		data, _ = EncodeError(resp.Error)
		s.writeJsonCustomStatus(w, statusCode, data)
		return
	}

	data, err = responseEncoder.EncodeRefresh(resp)
	if err != nil {
		incErrorStringCode(s.api.config.Protocol, "refresh", "marshal")
		s.handleMarshalError(r, w, err)
		return
	}
	if resp.Error != nil {
		incError(s.api.config.Protocol, "refresh", resp.Error.Code)
	}

	s.writeJson(w, data)
}

func (s *Handler) handleChannels(w http.ResponseWriter, r *http.Request) {
	data, err := io.ReadAll(r.Body)
	if err != nil {
		incErrorStringCode(s.api.config.Protocol, "channels", "read_body")
		s.handleReadDataError(r, w, err)
		return
	}

	req, err := paramsDecoder.DecodeChannels(data)
	if err != nil {
		incErrorStringCode(s.api.config.Protocol, "channels", "unmarshal")
		s.handleUnmarshalError(r, w, err)
		return
	}

	resp := s.api.Channels(r.Context(), req)
	if s.config.UseOpenTelemetry && resp.Error != nil {
		span := trace.SpanFromContext(r.Context())
		span.SetStatus(codes.Error, resp.Error.Error())
	}

	if resp.Error != nil && s.useTransportErrorMode(r) {
		incError(s.api.config.Protocol, "channels", resp.Error.Code)
		statusCode := MapErrorToHTTPCode(resp.Error)
		data, _ = EncodeError(resp.Error)
		s.writeJsonCustomStatus(w, statusCode, data)
		return
	}

	data, err = responseEncoder.EncodeChannels(resp)
	if err != nil {
		incErrorStringCode(s.api.config.Protocol, "channels", "marshal")
		s.handleMarshalError(r, w, err)
		return
	}
	if resp.Error != nil {
		incError(s.api.config.Protocol, "channels", resp.Error.Code)
	}

	s.writeJson(w, data)
}

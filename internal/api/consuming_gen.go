// Code generated by internal/gen/api/main.go. DO NOT EDIT.

package api

import (
	"context"

	. "github.com/centrifugal/centrifugo/v6/internal/apiproto"

	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/trace"
)

func (h *ConsumingHandler) handlePublish(ctx context.Context, data []byte) (*PublishResult, error) {
	req, err := paramsDecoder.DecodePublish(data)
	if err != nil {
		return nil, ErrInvalidData
	}
	resp := h.api.Publish(ctx, req)
	if h.config.UseOpenTelemetry && resp.Error != nil {
		span := trace.SpanFromContext(ctx)
		span.SetStatus(codes.Error, resp.Error.Error())
	}
	if resp.Error != nil {
		incError(h.api.config.Protocol, "publish", resp.Error.Code)
		return nil, resp.Error
	}
	return resp.Result, nil
}

func (h *ConsumingHandler) handleBroadcast(ctx context.Context, data []byte) (*BroadcastResult, error) {
	req, err := paramsDecoder.DecodeBroadcast(data)
	if err != nil {
		return nil, ErrInvalidData
	}
	resp := h.api.Broadcast(ctx, req)
	if h.config.UseOpenTelemetry && resp.Error != nil {
		span := trace.SpanFromContext(ctx)
		span.SetStatus(codes.Error, resp.Error.Error())
	}
	if resp.Error != nil {
		incError(h.api.config.Protocol, "broadcast", resp.Error.Code)
		return nil, resp.Error
	}
	return resp.Result, nil
}

func (h *ConsumingHandler) handleSubscribe(ctx context.Context, data []byte) (*SubscribeResult, error) {
	req, err := paramsDecoder.DecodeSubscribe(data)
	if err != nil {
		return nil, ErrInvalidData
	}
	resp := h.api.Subscribe(ctx, req)
	if h.config.UseOpenTelemetry && resp.Error != nil {
		span := trace.SpanFromContext(ctx)
		span.SetStatus(codes.Error, resp.Error.Error())
	}
	if resp.Error != nil {
		incError(h.api.config.Protocol, "subscribe", resp.Error.Code)
		return nil, resp.Error
	}
	return resp.Result, nil
}

func (h *ConsumingHandler) handleUnsubscribe(ctx context.Context, data []byte) (*UnsubscribeResult, error) {
	req, err := paramsDecoder.DecodeUnsubscribe(data)
	if err != nil {
		return nil, ErrInvalidData
	}
	resp := h.api.Unsubscribe(ctx, req)
	if h.config.UseOpenTelemetry && resp.Error != nil {
		span := trace.SpanFromContext(ctx)
		span.SetStatus(codes.Error, resp.Error.Error())
	}
	if resp.Error != nil {
		incError(h.api.config.Protocol, "unsubscribe", resp.Error.Code)
		return nil, resp.Error
	}
	return resp.Result, nil
}

func (h *ConsumingHandler) handleDisconnect(ctx context.Context, data []byte) (*DisconnectResult, error) {
	req, err := paramsDecoder.DecodeDisconnect(data)
	if err != nil {
		return nil, ErrInvalidData
	}
	resp := h.api.Disconnect(ctx, req)
	if h.config.UseOpenTelemetry && resp.Error != nil {
		span := trace.SpanFromContext(ctx)
		span.SetStatus(codes.Error, resp.Error.Error())
	}
	if resp.Error != nil {
		incError(h.api.config.Protocol, "disconnect", resp.Error.Code)
		return nil, resp.Error
	}
	return resp.Result, nil
}

func (h *ConsumingHandler) handleHistoryRemove(ctx context.Context, data []byte) (*HistoryRemoveResult, error) {
	req, err := paramsDecoder.DecodeHistoryRemove(data)
	if err != nil {
		return nil, ErrInvalidData
	}
	resp := h.api.HistoryRemove(ctx, req)
	if h.config.UseOpenTelemetry && resp.Error != nil {
		span := trace.SpanFromContext(ctx)
		span.SetStatus(codes.Error, resp.Error.Error())
	}
	if resp.Error != nil {
		incError(h.api.config.Protocol, "history_remove", resp.Error.Code)
		return nil, resp.Error
	}
	return resp.Result, nil
}

func (h *ConsumingHandler) handleRefresh(ctx context.Context, data []byte) (*RefreshResult, error) {
	req, err := paramsDecoder.DecodeRefresh(data)
	if err != nil {
		return nil, ErrInvalidData
	}
	resp := h.api.Refresh(ctx, req)
	if h.config.UseOpenTelemetry && resp.Error != nil {
		span := trace.SpanFromContext(ctx)
		span.SetStatus(codes.Error, resp.Error.Error())
	}
	if resp.Error != nil {
		incError(h.api.config.Protocol, "refresh", resp.Error.Code)
		return nil, resp.Error
	}
	return resp.Result, nil
}
